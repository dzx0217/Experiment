uuid,p_id,project,method,satd_type,start_line_before,end_line_before,start_line_after,end_line_after,comment,commit_before,commit_after,file_path,function_before,function_after,function_before_tokenized,function_after_tokenized,commit_before_time,commit_after_time,survive_time,similarity
2941,250,https://www.github.com/square/retrofit,bodySuccess404(),NOT_DESIGN,73,73,73,73,TODO assert on some indicator of 404.,https://www.github.com/square/retrofit/commit/2ca195069,https://www.github.com/square/retrofit/commit/3c14e0bf33f8a3be3bcd153c668fa42730e88f61,retrofit-adapters/rxjava/src/test/java/retrofit/ObservableCallAdapterFactoryTest.java,"@Test public void bodySuccess404() {
server.enqueue(new MockResponse().setResponseCode(404));
BlockingObservable<String> o = service.body().toBlocking();
try {
o.first();
fail();
} catch (RuntimeException e) {
// TODO assert on some indicator of 404.
}
}","@Test public void bodySuccess404() {
server.enqueue(new MockResponse().setResponseCode(404));
BlockingObservable<String> o = service.body().toBlocking();
try {
o.first();
fail();
} catch (RuntimeException e) {
Throwable cause = e.getCause();
assertThat(cause).isInstanceOf(HttpException.class).hasMessage(""HTTP 404 OK"");
}
}","@ Test public void bodySuccess404 ( ) { 
 server . enqueue ( new MockResponse ( ) . setResponseCode ( 404 ) ) ; 
 BlockingObservable < String > o = service . body ( ) . toBlocking ( ) ; 
 try { 
 o . first ( ) ; 
 fail ( ) ; 
 } catch ( RuntimeException e ) { 
 // TODO assert on some indicator of 404. 
 } 
 }  ","@ Test public void bodySuccess404 ( ) { 
 server . enqueue ( new MockResponse ( ) . setResponseCode ( 404 ) ) ; 
 BlockingObservable < String > o = service . body ( ) . toBlocking ( ) ; 
 try { 
 o . first ( ) ; 
 fail ( ) ; 
 } catch ( RuntimeException e ) { 
 Throwable cause = e . getCause ( ) ; 
 assertThat ( cause ) . isInstanceOf ( HttpException . class ) . hasMessage ( ""HTTP 404 OK"" ) ; 
 } 
 }  ",2015/6/1 1:10,2015/8/7 15:09,0,0.6661269526113947
232,177,https://www.github.com/voxeolabs/moho,"onRayoEvent(JID, Presence)",NOT_DESIGN,477,477,477,477,TODO mixer unjoin.,https://www.github.com/voxeolabs/moho/commit/81261978d,https://www.github.com/voxeolabs/moho/commit/6d82de2704215cdba333624a92a5e08d2dfb8faf,moho-remote/src/main/java/com/voxeo/moho/remote/impl/CallImpl.java,"@Override
public void onRayoEvent(JID from, Presence presence) {
if (from.getResource() != null) {
super.onRayoEvent(from, presence);
}
else {
LOG.debug(""CallImpl Recived presence, processing:""+ presence);
Object object = presence.getExtension().getObject();
if (object instanceof EndEvent) {
EndEvent event = (EndEvent) object;
EndEvent.Reason rayoReason = event.getReason();
if (rayoReason == EndEvent.Reason.HANGUP) {
MohoHangupEventImpl mohoEvent = new MohoHangupEventImpl(this);
this.dispatch(mohoEvent);
}
MohoCallCompleteEvent mohoEvent = new MohoCallCompleteEvent(this,
            getMohoReasonByRayoEndEventReason(event.getReason()), null, event.getHeaders());
this.dispatch(mohoEvent);
_state = State.DISCONNECTED;
cleanUp();
}
else if (object instanceof DtmfEvent) {
DtmfEvent event = (DtmfEvent) object;
MohoInputDetectedEvent<Call> mohoEvent = new MohoInputDetectedEvent<Call>(this, event.getSignal());
this.dispatch(mohoEvent);
}
else if (object instanceof JoinedEvent) {
JoinedEvent event = (JoinedEvent) object;
MohoJoinCompleteEvent mohoEvent = null;
String id = event.getTo();
JoinDestinationType type = event.getType();
JointImpl joint = _joints.remove(id);
if (type == JoinDestinationType.CALL) {
Call peer = (Call) this.getMohoRemote().getParticipant(id);
_joinees.add(peer, joint.getType(), joint.getDirection());
_peers.add(peer);
mohoEvent = new MohoJoinCompleteEvent(this, peer, JoinCompleteEvent.Cause.JOINED, true);
joint.done(mohoEvent);
}
else {
// TODO mixer join.
Mixer peer = (Mixer) this.getMohoRemote().getParticipant(id);
_joinees.add(peer, joint.getType(), joint.getDirection());
mohoEvent = new MohoJoinCompleteEvent(this, peer, JoinCompleteEvent.Cause.JOINED, true);
}
this.dispatch(mohoEvent);
}
else if (object instanceof UnjoinedEvent) {
UnjoinedEvent event = (UnjoinedEvent) object;
MohoUnjoinCompleteEvent mohoEvent = null;
String id = event.getFrom();
JoinDestinationType type = event.getType();
UnJointImpl unjoint = _unjoints.remove(id);
if (type == JoinDestinationType.CALL) {
Call peer = (Call) _mohoRemote.getParticipant(id);
_joinees.remove(peer);
_peers.remove(peer);
mohoEvent = new MohoUnjoinCompleteEvent(this, peer, UnjoinCompleteEvent.Cause.SUCCESS_UNJOIN, true);
}
else {
// TODO mixer unjoin.
Mixer peer = (Mixer) this.getMohoRemote().getParticipant(id);
_joinees.remove(peer);
mohoEvent = new MohoUnjoinCompleteEvent(this, peer, UnjoinCompleteEvent.Cause.SUCCESS_UNJOIN, true);
}
this.dispatch(mohoEvent);
}
else if (object instanceof OffHoldEvent) {
// TODO for conference
}
else if (object instanceof OnHoldEvent) {
// TODO for conference
}
else if (object instanceof AnsweredEvent) {
// TODO for answered
}
else if (object instanceof RingingEvent) {
// TODO for answered
}
else {
LOG.error(""CallImpl Can't process presence:"" + presence);
}
}
}","@Override
public void onRayoEvent(JID from, Presence presence) {
if (from.getResource() != null) {
super.onRayoEvent(from, presence);
}
else {
LOG.debug(""CallImpl Recived presence, processing:"" + presence);
Object object = presence.getExtension().getObject();
if (object instanceof EndEvent) {
EndEvent event = (EndEvent) object;
EndEvent.Reason rayoReason = event.getReason();
if (rayoReason == EndEvent.Reason.HANGUP) {
MohoHangupEventImpl mohoEvent = new MohoHangupEventImpl(this);
this.dispatch(mohoEvent);
}
MohoCallCompleteEvent mohoEvent = new MohoCallCompleteEvent(this,
            getMohoReasonByRayoEndEventReason(event.getReason()), null, event.getHeaders());
this.setCallState(State.DISCONNECTED);
this.dispatch(mohoEvent);
cleanUp();
}
else if (object instanceof DtmfEvent) {
DtmfEvent event = (DtmfEvent) object;
MohoInputDetectedEvent<Call> mohoEvent = new MohoInputDetectedEvent<Call>(this, event.getSignal());
this.dispatch(mohoEvent);
}
else if (object instanceof JoinedEvent) {
JoinedEvent event = (JoinedEvent) object;
MohoJoinCompleteEvent mohoEvent = null;
String id = event.getTo();
JoinDestinationType type = event.getType();
JointImpl joint = _joints.remove(id);
if (type == JoinDestinationType.CALL) {
Call peer = (Call) this.getMohoRemote().getParticipant(id);
_joinees.add(peer, joint.getType(), joint.getDirection());
_peers.add(peer);
mohoEvent = new MohoJoinCompleteEvent(this, peer, JoinCompleteEvent.Cause.JOINED, true);
}
else {
Mixer peer = (Mixer) this.getMohoRemote().getParticipant(id);
_joinees.add(peer, joint.getType(), joint.getDirection());
mohoEvent = new MohoJoinCompleteEvent(this, peer, JoinCompleteEvent.Cause.JOINED, true);
}
this.dispatch(mohoEvent);
joint.done(mohoEvent);
}
else if (object instanceof UnjoinedEvent) {
UnjoinedEvent event = (UnjoinedEvent) object;
MohoUnjoinCompleteEvent mohoEvent = null;
String id = event.getFrom();
JoinDestinationType type = event.getType();
UnJointImpl unjoint = _unjoints.remove(id);
if (type == JoinDestinationType.CALL) {
Call peer = (Call) _mohoRemote.getParticipant(id);
_joinees.remove(peer);
_peers.remove(peer);
mohoEvent = new MohoUnjoinCompleteEvent(this, peer, UnjoinCompleteEvent.Cause.SUCCESS_UNJOIN, true);
}
else {
Mixer peer = (Mixer) this.getMohoRemote().getParticipant(id);
_joinees.remove(peer);
mohoEvent = new MohoUnjoinCompleteEvent(this, peer, UnjoinCompleteEvent.Cause.SUCCESS_UNJOIN, true);
}
this.dispatch(mohoEvent);
if (unjoint != null) {
unjoint.done(mohoEvent);
}
}
else if (object instanceof OffHoldEvent) {
// TODO for conference
}
else if (object instanceof OnHoldEvent) {
// TODO for conference
}
else {
LOG.error(""CallImpl Can't process presence:"" + presence);
}
}
}","@ Override 
 public void onRayoEvent ( JID from , Presence presence ) { 
 if ( from . getResource ( ) != null ) { 
 super . onRayoEvent ( from , presence ) ; 
 } 
 else { 
 LOG . debug ( ""CallImpl Recived presence, processing:"" + presence ) ; 
 Object object = presence . getExtension ( ) . getObject ( ) ; 
 if ( object instanceof EndEvent ) { 
 EndEvent event = ( EndEvent ) object ; 
 EndEvent . Reason rayoReason = event . getReason ( ) ; 
 if ( rayoReason == EndEvent . Reason . HANGUP ) { 
 MohoHangupEventImpl mohoEvent = new MohoHangupEventImpl ( this ) ; 
 this . dispatch ( mohoEvent ) ; 
 } 
 MohoCallCompleteEvent mohoEvent = new MohoCallCompleteEvent ( this , 
 getMohoReasonByRayoEndEventReason ( event . getReason ( ) ) , null , event . getHeaders ( ) ) ; 
 this . dispatch ( mohoEvent ) ; 
 _state = State . DISCONNECTED ; 
 cleanUp ( ) ; 
 } 
 else if ( object instanceof DtmfEvent ) { 
 DtmfEvent event = ( DtmfEvent ) object ; 
 MohoInputDetectedEvent < Call > mohoEvent = new MohoInputDetectedEvent < Call > ( this , event . getSignal ( ) ) ; 
 this . dispatch ( mohoEvent ) ; 
 } 
 else if ( object instanceof JoinedEvent ) { 
 JoinedEvent event = ( JoinedEvent ) object ; 
 MohoJoinCompleteEvent mohoEvent = null ; 
 String id = event . getTo ( ) ; 
 JoinDestinationType type = event . getType ( ) ; 
 JointImpl joint = _joints . remove ( id ) ; 
 if ( type == JoinDestinationType . CALL ) { 
 Call peer = ( Call ) this . getMohoRemote ( ) . getParticipant ( id ) ; 
 _joinees . add ( peer , joint . getType ( ) , joint . getDirection ( ) ) ; 
 _peers . add ( peer ) ; 
 mohoEvent = new MohoJoinCompleteEvent ( this , peer , JoinCompleteEvent . Cause . JOINED , true ) ; 
 joint . done ( mohoEvent ) ; 
 } 
 else { 
 // TODO mixer join . 
 Mixer peer = ( Mixer ) this . getMohoRemote ( ) . getParticipant ( id ) ; 
 _joinees . add ( peer , joint . getType ( ) , joint . getDirection ( ) ) ; 
 mohoEvent = new MohoJoinCompleteEvent ( this , peer , JoinCompleteEvent . Cause . JOINED , true ) ; 
 } 
 this . dispatch ( mohoEvent ) ; 
 } 
 else if ( object instanceof UnjoinedEvent ) { 
 UnjoinedEvent event = ( UnjoinedEvent ) object ; 
 MohoUnjoinCompleteEvent mohoEvent = null ; 
 String id = event . getFrom ( ) ; 
 JoinDestinationType type = event . getType ( ) ; 
 UnJointImpl unjoint = _unjoints . remove ( id ) ; 
 if ( type == JoinDestinationType . CALL ) { 
 Call peer = ( Call ) _mohoRemote . getParticipant ( id ) ; 
 _joinees . remove ( peer ) ; 
 _peers . remove ( peer ) ; 
 mohoEvent = new MohoUnjoinCompleteEvent ( this , peer , UnjoinCompleteEvent . Cause . SUCCESS_UNJOIN , true ) ; 
 } 
 else { 
 // TODO mixer unjoin . 
 Mixer peer = ( Mixer ) this . getMohoRemote ( ) . getParticipant ( id ) ; 
 _joinees . remove ( peer ) ; 
 mohoEvent = new MohoUnjoinCompleteEvent ( this , peer , UnjoinCompleteEvent . Cause . SUCCESS_UNJOIN , true ) ; 
 } 
 this . dispatch ( mohoEvent ) ; 
 } 
 else if ( object instanceof OffHoldEvent ) { 
 // TODO for conference 
 } 
 else if ( object instanceof OnHoldEvent ) { 
 // TODO for conference 
 } 
 else if ( object instanceof AnsweredEvent ) { 
 // TODO for answered 
 } 
 else if ( object instanceof RingingEvent ) { 
 // TODO for answered 
 } 
 else { 
 LOG . error ( ""CallImpl Can't process presence:"" + presence ) ; 
 } 
 } 
 }  ","@ Override 
 public void onRayoEvent ( JID from , Presence presence ) { 
 if ( from . getResource ( ) != null ) { 
 super . onRayoEvent ( from , presence ) ; 
 } 
 else { 
 LOG . debug ( ""CallImpl Recived presence, processing:"" + presence ) ; 
 Object object = presence . getExtension ( ) . getObject ( ) ; 
 if ( object instanceof EndEvent ) { 
 EndEvent event = ( EndEvent ) object ; 
 EndEvent . Reason rayoReason = event . getReason ( ) ; 
 if ( rayoReason == EndEvent . Reason . HANGUP ) { 
 MohoHangupEventImpl mohoEvent = new MohoHangupEventImpl ( this ) ; 
 this . dispatch ( mohoEvent ) ; 
 } 
 MohoCallCompleteEvent mohoEvent = new MohoCallCompleteEvent ( this , 
 getMohoReasonByRayoEndEventReason ( event . getReason ( ) ) , null , event . getHeaders ( ) ) ; 
 this . setCallState ( State . DISCONNECTED ) ; 
 this . dispatch ( mohoEvent ) ; 
 cleanUp ( ) ; 
 } 
 else if ( object instanceof DtmfEvent ) { 
 DtmfEvent event = ( DtmfEvent ) object ; 
 MohoInputDetectedEvent < Call > mohoEvent = new MohoInputDetectedEvent < Call > ( this , event . getSignal ( ) ) ; 
 this . dispatch ( mohoEvent ) ; 
 } 
 else if ( object instanceof JoinedEvent ) { 
 JoinedEvent event = ( JoinedEvent ) object ; 
 MohoJoinCompleteEvent mohoEvent = null ; 
 String id = event . getTo ( ) ; 
 JoinDestinationType type = event . getType ( ) ; 
 JointImpl joint = _joints . remove ( id ) ; 
 if ( type == JoinDestinationType . CALL ) { 
 Call peer = ( Call ) this . getMohoRemote ( ) . getParticipant ( id ) ; 
 _joinees . add ( peer , joint . getType ( ) , joint . getDirection ( ) ) ; 
 _peers . add ( peer ) ; 
 mohoEvent = new MohoJoinCompleteEvent ( this , peer , JoinCompleteEvent . Cause . JOINED , true ) ; 
 } 
 else { 
 Mixer peer = ( Mixer ) this . getMohoRemote ( ) . getParticipant ( id ) ; 
 _joinees . add ( peer , joint . getType ( ) , joint . getDirection ( ) ) ; 
 mohoEvent = new MohoJoinCompleteEvent ( this , peer , JoinCompleteEvent . Cause . JOINED , true ) ; 
 } 
 this . dispatch ( mohoEvent ) ; 
 joint . done ( mohoEvent ) ; 
 } 
 else if ( object instanceof UnjoinedEvent ) { 
 UnjoinedEvent event = ( UnjoinedEvent ) object ; 
 MohoUnjoinCompleteEvent mohoEvent = null ; 
 String id = event . getFrom ( ) ; 
 JoinDestinationType type = event . getType ( ) ; 
 UnJointImpl unjoint = _unjoints . remove ( id ) ; 
 if ( type == JoinDestinationType . CALL ) { 
 Call peer = ( Call ) _mohoRemote . getParticipant ( id ) ; 
 _joinees . remove ( peer ) ; 
 _peers . remove ( peer ) ; 
 mohoEvent = new MohoUnjoinCompleteEvent ( this , peer , UnjoinCompleteEvent . Cause . SUCCESS_UNJOIN , true ) ; 
 } 
 else { 
 Mixer peer = ( Mixer ) this . getMohoRemote ( ) . getParticipant ( id ) ; 
 _joinees . remove ( peer ) ; 
 mohoEvent = new MohoUnjoinCompleteEvent ( this , peer , UnjoinCompleteEvent . Cause . SUCCESS_UNJOIN , true ) ; 
 } 
 this . dispatch ( mohoEvent ) ; 
 if ( unjoint != null ) { 
 unjoint . done ( mohoEvent ) ; 
 } 
 } 
 else if ( object instanceof OffHoldEvent ) { 
 // TODO for conference 
 } 
 else if ( object instanceof OnHoldEvent ) { 
 // TODO for conference 
 } 
 else { 
 LOG . error ( ""CallImpl Can't process presence:"" + presence ) ; 
 } 
 } 
 }  ",2011-09-24 18:30:50 +0800,2011-11-17 13:14:17 +0800,0,0.9877946180491965
2724,294,https://www.github.com/enginehub/craftbook,onEnable(),,228,228,232,234,TODO Why does this do its own thing?,https://www.github.com/enginehub/craftbook/commit/68718e2057,https://www.github.com/enginehub/craftbook/commit/a0651296c5a3bb5b05f26e4e2827b4cb23b5c215,vehicles/src/main/java/com/sk89q/craftbook/bukkit/VehiclesPlugin.java,"@EventHandler
public void onBlockRedstoneChange(BlockPhysicsEvent event) {
// TODO Why does this do its own thing?
if (!RedstoneUtil.isPotentialPowerSource(event.getBlock())) return;
cartman.impact(event);
}","@EventHandler
public void onBlockRedstoneChange(BlockRedstoneEvent event) {
// ignore events that are only changes in current strength
if (event.getOldCurrent() > 0 == event.getNewCurrent() > 0) return;
// remember that bukkit only gives us redstone events for wires and things that already respond to
// redstone, which is entirely unhelpful.
// So: issue four actual events per bukkit event.
for (BlockFace bf : CartMechanism.powerSupplyOptions)
cartman.impact(new SourcedBlockRedstoneEvent(event, event.getBlock().getRelative(bf)));
}","@ EventHandler 
 public void onBlockRedstoneChange ( BlockPhysicsEvent event ) { 
 // TODO Why does this do its own thing ? 
 if ( ! RedstoneUtil . isPotentialPowerSource ( event . getBlock ( ) ) ) return ; 
 cartman . impact ( event ) ; 
 }  ","@ EventHandler 
 public void onBlockRedstoneChange ( BlockRedstoneEvent event ) { 
 // ignore events that are only changes in current strength 
 if ( event . getOldCurrent ( ) > 0 == event . getNewCurrent ( ) > 0 ) return ; 
 // remember that bukkit only gives us redstone events for wires and things that already respond to 
 // redstone , which is entirely unhelpful . 
 // So : issue four actual events per bukkit event . 
 for ( BlockFace bf : CartMechanism . powerSupplyOptions ) 
 cartman . impact ( new SourcedBlockRedstoneEvent ( event , event . getBlock ( ) . getRelative ( bf ) ) ) ; 
 }  ",2012/8/1 1:50,2012-09-01 09:24:53 +1000,0,0.31964448232967085
1740,115,https://www.github.com/twilio/twilio-java,testUpdateRequest(),NOT_DESIGN,85,85,85,85,TODO: Make this work,https://www.github.com/twilio/twilio-java/commit/2062fc43f4,https://www.github.com/twilio/twilio-java/commit/271ae3b3a4d52debdbe615b2ee048614ffc8a48a,src/test/java/com/twilio/sdk/resources/CallTest.java,"@Test
public void testUpdateRequest() throws Exception {
Twilio.setMockResponses(new ConsumableResponse(CallMocks.INSTANCE_JSON, 200));
Call call = Call.build(""CAaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"");
Call.update()
.setFriendlyName(""Hello World"")
.build(call);
Request request = Twilio.getMockRequest(1);
assertNotNull(request);
URL url = request.constructURL();
assertEquals(""https://api.twilio.com/2010-04-01/Accounts/AC123/Calls/CAaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.json"", url.toString());
// TODO: Make this work
//        String formBody = request.encodeFormBody();
//        assertEquals(""FriendlyName=Hello+World"", formBody);
}","@Test
public void testUpdateRequest() throws Exception {
Twilio.setMockResponses(new ConsumableResponse(CallMocks.INSTANCE_JSON, 200));
Call.update()
.setUri(""https://www.twilio.com"")
.setMethod(""POST"")
.build(""CAaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"");
Request request = Twilio.getMockRequest();
URL url = request.constructURL();
assertEquals(
            ""https://api.twilio.com/2010-04-01/Accounts/AC123/Calls/CAaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.json"",
            url.toString()
        );
String formBody = request.encodeFormBody();
assertQueryStringsEqual(""Uri=https://www.twilio.com&Method=POST"", formBody);
}","@ Test 
 public void testUpdateRequest ( ) throws Exception { 
 Twilio . setMockResponses ( new ConsumableResponse ( CallMocks . INSTANCE_JSON , 200 ) ) ; 
 Call call = Call . build ( ""CAaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"" ) ; 
 Call . update ( ) 
 . setFriendlyName ( ""Hello World"" ) 
 . build ( call ) ; 
 Request request = Twilio . getMockRequest ( 1 ) ; 
 assertNotNull ( request ) ; 
 URL url = request . constructURL ( ) ; 
 assertEquals ( ""https://api.twilio.com/2010-04-01/Accounts/AC123/Calls/CAaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.json"" , url . toString ( ) ) ; 
 // TODO : Make this work 
 // String formBody = request . encodeFormBody ( ) ; 
 // assertEquals ( ""FriendlyName=Hello+World"" , formBody ) ; 
 }  ","@ Test 
 public void testUpdateRequest ( ) throws Exception { 
 Twilio . setMockResponses ( new ConsumableResponse ( CallMocks . INSTANCE_JSON , 200 ) ) ; 
 Call . update ( ) 
 . setUri ( ""https://www.twilio.com"" ) 
 . setMethod ( ""POST"" ) 
 . build ( ""CAaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"" ) ; 
 Request request = Twilio . getMockRequest ( ) ; 
 URL url = request . constructURL ( ) ; 
 assertEquals ( 
 ""https://api.twilio.com/2010-04-01/Accounts/AC123/Calls/CAaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.json"" , 
 url . toString ( ) 
 ) ; 
 String formBody = request . encodeFormBody ( ) ; 
 assertQueryStringsEqual ( ""Uri=https://www.twilio.com&Method=POST"" , formBody ) ; 
 }  ",2014/10/30 8:55,2014/10/31 10:42,0,0.7337075038880828
699,805,https://www.github.com/spacecowboy/notepad,getObserver(Context),,164,164,151,157,TODO does it even work ?,https://www.github.com/spacecowboy/notepad/commit/056a172f6,https://www.github.com/spacecowboy/notepad/commit/0c4c4a1222b3be2c109ea6dc20dc4ae1a5715b67,app/src/main/java/com/nononsenseapps/helpers/NotificationHelper.java,"@TargetApi(Build.VERSION_CODES.O)
@RequiresApi(Build.VERSION_CODES.O)
public static void createNotificationChannel(final Context context, NotificationManager nm) {
String name = context.getString(R.string.notification_channel_name);
String description = context.getString(R.string.notification_channel_description);
// not higher, not lower. This is equivalent to notifications before API 24
int importance = NotificationManager.IMPORTANCE_DEFAULT;
NotificationChannel channel = new NotificationChannel(CHANNEL_ID, name, importance);
channel.setDescription(description);
AudioAttributes audioAttrib = new AudioAttributes.Builder()
.setUsage(AudioAttributes.USAGE_NOTIFICATION)
.setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)
.build();
// get user-chosen ringtone from preferences
String ringtone1 = PreferenceManager
.getDefaultSharedPreferences(context)
.getString(context.getString(R.string.key_pref_ringtone), null);
Uri ringtone2 = ringtone1 == null ? null : Uri.parse(ringtone1);
// TODO choose a value for this ? or just bring the user to the channel preference page ?
//  channel.setLockscreenVisibility();
// TODO we have to update the vibration and light settings HERE, or they won't work
//  in newer android version. read values from the preferences, copy code from this file
//  channel.enableVibration(true);
channel.setSound(ringtone2, audioAttrib); // TODO does it even work ?
nm.createNotificationChannel(channel);
}","@TargetApi(Build.VERSION_CODES.O)
@RequiresApi(Build.VERSION_CODES.O)
public static void createNotificationChannel(final Context context, NotificationManager nm) {
String name = context.getString(R.string.notification_channel_name);
String description = context.getString(R.string.notification_channel_description);
// not higher, not lower. This is equivalent to notifications before API 24
int importance = NotificationManager.IMPORTANCE_DEFAULT;
NotificationChannel channel = new NotificationChannel(CHANNEL_ID, name, importance);
channel.setDescription(description);
// well if the users dislike this they can change it through the settings
channel.setLockscreenVisibility(Notification.VISIBILITY_PRIVATE);
// here you could also set:
// * the sound: channel.setSound()
// * the vibration: channel.enableVibration()
// * the light color: channel.enableLights() & channel.setLightColor()
// but the user can set all of these in the system's notification channel pref. page,
// which can be opened through our NotificationPrefs fragment. And that's
// better than us rewriting android code!
nm.createNotificationChannel(channel);
}","@ TargetApi ( Build . VERSION_CODES . O ) 
 @ RequiresApi ( Build . VERSION_CODES . O ) 
 public static void createNotificationChannel ( final Context context , NotificationManager nm ) { 
 String name = context . getString ( R . string . notification_channel_name ) ; 
 String description = context . getString ( R . string . notification_channel_description ) ; 
 // not higher , not lower . This is equivalent to notifications before API 24 
 int importance = NotificationManager . IMPORTANCE_DEFAULT ; 
 NotificationChannel channel = new NotificationChannel ( CHANNEL_ID , name , importance ) ; 
 channel . setDescription ( description ) ; 
 AudioAttributes audioAttrib = new AudioAttributes . Builder ( ) 
 . setUsage ( AudioAttributes . USAGE_NOTIFICATION ) 
 . setContentType ( AudioAttributes . CONTENT_TYPE_MUSIC ) 
 . build ( ) ; 
 // get user - chosen ringtone from preferences 
 String ringtone1 = PreferenceManager 
 . getDefaultSharedPreferences ( context ) 
 . getString ( context . getString ( R . string . key_pref_ringtone ) , null ) ; 
 Uri ringtone2 = ringtone1 == null   ? null : Uri . parse ( ringtone1 ) ; 
 // TODO choose a value for this   ? or just bring the user to the channel preference page   ? 
 // channel . setLockscreenVisibility ( ) ; 
 // TODO we have to update the vibration and light settings HERE , or they won ' t work 
 // in newer android version . read values from the preferences , copy code from this file 
 // channel . enableVibration ( true ) ; 
 channel . setSound ( ringtone2 , audioAttrib ) ; // TODO does it even work   ? 
 nm . createNotificationChannel ( channel ) ; 
 }  ","@ TargetApi ( Build . VERSION_CODES . O ) 
 @ RequiresApi ( Build . VERSION_CODES . O ) 
 public static void createNotificationChannel ( final Context context , NotificationManager nm ) { 
 String name = context . getString ( R . string . notification_channel_name ) ; 
 String description = context . getString ( R . string . notification_channel_description ) ; 
 // not higher , not lower . This is equivalent to notifications before API 24 
 int importance = NotificationManager . IMPORTANCE_DEFAULT ; 
 NotificationChannel channel = new NotificationChannel ( CHANNEL_ID , name , importance ) ; 
 channel . setDescription ( description ) ; 
 // well if the users dislike this they can change it through the settings 
 channel . setLockscreenVisibility ( Notification . VISIBILITY_PRIVATE ) ; 
 // here you could also set : 
 // * the sound : channel . setSound ( ) 
 // * the vibration : channel . enableVibration ( ) 
 // * the light color : channel . enableLights ( ) & channel . setLightColor ( ) 
 // but the user can set all of these in the system ' s notification channel pref . page , 
 // which can be opened through our NotificationPrefs fragment . And that ' s 
 // better than us rewriting android code ! 
 nm . createNotificationChannel ( channel ) ; 
 }  ",2022-11-23 17:26:24 +0100,2022-11-24 11:43:53 +0100,0,0.6577005424862421
440,149,https://www.github.com/hector-client/hector,testInheritanceOfEntity(),NOT_DESIGN,102,102,102,102,TODO fix me,https://www.github.com/hector-client/hector/commit/ec6a8b3ee,https://www.github.com/hector-client/hector/commit/e9e7902df2b40406c45f23cc394a45ace48e5f4d,object-mapper/src/test/java/me/prettyprint/hom/ClassCacheMgrTest.java,"@Test
@Ignore
// TODO fix me
public void testInheritanceOfEntity() {
ClassCacheMgr cacheMgr = new ClassCacheMgr();
CFMappingDef<MyRedTestBean, String> cfMapDef = cacheMgr.initializeCacheForClass(MyRedTestBean.class);
assertEquals( 13, cfMapDef.getAllProperties().size() );
assertNotNull( cfMapDef.getCfBaseMapDef());
assertEquals( MyRedTestBean.class, cfMapDef.getClazz() );
assertEquals( ""TestBeanColumnFamily"", cfMapDef.getColFamName() );
assertEquals( ""myType"", cfMapDef.getDiscColumn());
assertEquals( DiscriminatorType.STRING, cfMapDef.getDiscType());
assertEquals( ""baseId"", cfMapDef.getIdPropertyDef().getPropDesc().getName() );
}","@Test
public void testInheritanceOfEntity() {
ClassCacheMgr cacheMgr = new ClassCacheMgr();
CFMappingDef<MyRedTestBean, String> cfMapDef = cacheMgr
.initializeCacheForClass(MyRedTestBean.class);
// 13 is valid when custom conversion of enumerations works again
// don't like hard coding numbers into JUnits, but took easy way for now
// assertEquals( 13, cfMapDef.getAllProperties().size() );
assertEquals(12, cfMapDef.getAllProperties().size());
assertNotNull(cfMapDef.getCfBaseMapDef());
assertEquals(MyRedTestBean.class, cfMapDef.getClazz());
assertEquals(""TestBeanColumnFamily"", cfMapDef.getColFamName());
assertEquals(""myType"", cfMapDef.getDiscColumn());
assertEquals(DiscriminatorType.STRING, cfMapDef.getDiscType());
assertEquals(""baseId"", cfMapDef.getIdPropertyDef().getPropDesc().getName());
}","@ Test 
 @ Ignore 
 // TODO fix me 
 public void testInheritanceOfEntity ( ) { 
 ClassCacheMgr cacheMgr = new ClassCacheMgr ( ) ; 
 CFMappingDef < MyRedTestBean , String > cfMapDef = cacheMgr . initializeCacheForClass ( MyRedTestBean . class ) ; 
 assertEquals ( 13 , cfMapDef . getAllProperties ( ) . size ( ) ) ; 
 assertNotNull ( cfMapDef . getCfBaseMapDef ( ) ) ; 
 assertEquals ( MyRedTestBean . class , cfMapDef . getClazz ( ) ) ; 
 assertEquals ( ""TestBeanColumnFamily"" , cfMapDef . getColFamName ( ) ) ; 
 assertEquals ( ""myType"" , cfMapDef . getDiscColumn ( ) ) ; 
 assertEquals ( DiscriminatorType . STRING , cfMapDef . getDiscType ( ) ) ; 
 assertEquals ( ""baseId"" , cfMapDef . getIdPropertyDef ( ) . getPropDesc ( ) . getName ( ) ) ; 
 }  ","@ Test 
 public void testInheritanceOfEntity ( ) { 
 ClassCacheMgr cacheMgr = new ClassCacheMgr ( ) ; 
 CFMappingDef < MyRedTestBean , String > cfMapDef = cacheMgr 
 . initializeCacheForClass ( MyRedTestBean . class ) ; 
 // 13 is valid when custom conversion of enumerations works again 
 // don ' t like hard coding numbers into JUnits , but took easy way for now 
 // assertEquals ( 13 , cfMapDef . getAllProperties ( ) . size ( ) ) ; 
 assertEquals ( 12 , cfMapDef . getAllProperties ( ) . size ( ) ) ; 
 assertNotNull ( cfMapDef . getCfBaseMapDef ( ) ) ; 
 assertEquals ( MyRedTestBean . class , cfMapDef . getClazz ( ) ) ; 
 assertEquals ( ""TestBeanColumnFamily"" , cfMapDef . getColFamName ( ) ) ; 
 assertEquals ( ""myType"" , cfMapDef . getDiscColumn ( ) ) ; 
 assertEquals ( DiscriminatorType . STRING , cfMapDef . getDiscType ( ) ) ; 
 assertEquals ( ""baseId"" , cfMapDef . getIdPropertyDef ( ) . getPropDesc ( ) . getName ( ) ) ; 
 }  ",2010/12/29 21:42,2011/1/3 13:28,0,0.9176114841629955
859,361,https://www.github.com/isa-tools/isacreator,createTopPanel(),NOT_DESIGN,195,195,195,195,todo show visualisation...,https://www.github.com/isa-tools/isacreator/commit/da5c08f0f,https://www.github.com/isa-tools/isacreator/commit/edd7d1f546d75819e7f0b3cdba20afcd6ab3eb83,src/main/java/org/isatools/isacreator/ontologiser/ui/OntologiserUI.java,"private Container createTopPanel() {
Box topPanel = Box.createHorizontalBox();
termTaggerButton = new JLabel(termTaggerIcon);
termTaggerButton.setHorizontalAlignment(SwingConstants.LEFT);
termTaggerButton.addMouseListener(new MouseAdapter() {
            @Override
public void mouseEntered(MouseEvent mouseEvent) {
termTaggerButton.setIcon(termTaggerIconOver);
}
@Override
public void mouseExited(MouseEvent mouseEvent) {
termTaggerButton.setIcon(selectedSection == TERM_TAGGER_VIEW ? termTaggerIconOver : termTaggerIcon);
}
@Override
public void mousePressed(MouseEvent mouseEvent) {
resetButtons();
termTaggerButton.setIcon(termTaggerIconOver);
visualiseButton.setIcon(visualiseInactiveIcon);
suggestButton.setIcon(suggestInactiveIcon);
clearAllButton.setIcon(clearAllInactiveIcon);
selectedSection = TERM_TAGGER_VIEW;
Thread performer = new Thread(new Runnable() {
                    public void run() {
Map<String, Map<String, AnnotatorResult>> terms = getTerms();
boolean haveTerms = terms != null;
if (haveTerms) {
if (annotationPane == null) {
annotationPane = new OntologiserAnnotationPane(terms);
SwingUtilities.invokeLater(new Runnable() {
                                    public void run() {
annotationPane.createGUI();
}
                                });
}
SwingUtilities.invokeLater(new Runnable() {
                                public void run() {
swapContainers(annotationPane);
termTaggerButton.setIcon(termTaggerIconOver);
visualiseButton.setIcon(visualiseIcon);
suggestButton.setIcon(suggestIcon);
clearAllButton.setIcon(clearAllIcon);
}
                            });
} else {
// todo add info pane saying there are no terms to annotate
swapContainers(helpPane);
}
}

                });
swapContainers(UIHelper.wrapComponentInPanel(new JLabel(working)));
performer.start();
}
        });
visualiseButton = new JLabel(visualiseInactiveIcon);
visualiseButton.setHorizontalAlignment(SwingConstants.LEFT);
visualiseButton.addMouseListener(new MouseAdapter() {
            @Override
public void mouseEntered(MouseEvent mouseEvent) {
visualiseButton.setIcon((selectedSection == TERM_TAGGER_VIEW || selectedSection == VISUALISATION) ? visualiseIconOver : visualiseInactiveIcon);
}
@Override
public void mouseExited(MouseEvent mouseEvent) {
visualiseButton.setIcon((selectedSection == TERM_TAGGER_VIEW || selectedSection == VISUALISATION) ? visualiseIcon : visualiseInactiveIcon);
}
@Override
public void mousePressed(MouseEvent mouseEvent) {
if (visualiseButton.getIcon() != visualiseInactiveIcon) {
visualiseButton.setIcon(visualiseIcon);
selectedSection = VISUALISATION;
// todo show visualisation...
}
}
        });
suggestButton = new JLabel(suggestInactiveIcon);
suggestButton.setHorizontalAlignment(SwingConstants.LEFT);
suggestButton.addMouseListener(new MouseAdapter() {
            @Override
public void mouseEntered(MouseEvent mouseEvent) {
suggestButton.setIcon(selectedSection == TERM_TAGGER_VIEW ? suggestIconOver : suggestInactiveIcon);
}
@Override
public void mouseExited(MouseEvent mouseEvent) {
suggestButton.setIcon(selectedSection == TERM_TAGGER_VIEW ? suggestIcon : suggestInactiveIcon);
}
@Override
public void mousePressed(MouseEvent mouseEvent) {
if (suggestButton.getIcon() != suggestInactiveIcon) {
suggestButton.setIcon(suggestIcon);
annotationPane.autoAnnotate();
}
}
        });
clearAllButton = new JLabel(clearAllInactiveIcon);
clearAllButton.setHorizontalAlignment(SwingConstants.LEFT);
clearAllButton.addMouseListener(new MouseAdapter() {
            @Override
public void mouseEntered(MouseEvent mouseEvent) {
clearAllButton.setIcon(selectedSection == TERM_TAGGER_VIEW ? clearAllIconOver : clearAllInactiveIcon);
}
@Override
public void mouseExited(MouseEvent mouseEvent) {
clearAllButton.setIcon(selectedSection == TERM_TAGGER_VIEW ? clearAllIcon : clearAllInactiveIcon);
}
@Override
public void mousePressed(MouseEvent mouseEvent) {
if (clearAllButton.getIcon() != clearAllInactiveIcon) {
clearAllButton.setIcon(clearAllIcon);
annotationPane.clearAnnotation();
}
}
        });
helpButton = new JLabel(helpIconOver);
helpButton.setHorizontalAlignment(SwingConstants.LEFT);
helpButton.addMouseListener(new
MouseAdapter() {
                    @Override
public void mouseEntered
(MouseEvent
mouseEvent) {
helpButton.setIcon(helpIconOver);
}
@Override
public void mouseExited
(MouseEvent mouseEvent) {
helpButton.setIcon(selectedSection == HELP ? helpIconOver : helpIcon);
}
@Override
public void mousePressed
(MouseEvent
mouseEvent) {
resetButtons();
selectedSection = HELP;
helpButton.setIcon(helpIconOver);
if (helpPane == null) {
helpPane = new OntologyHelpPane();
SwingUtilities.invokeLater(new Runnable() {
                                public void run() {
helpPane.createGUI();
}
                            });
}
SwingUtilities.invokeLater(new Runnable() {
                            public void run() {
swapContainers(helpPane);
}
                        });
}
                }

        );
topPanel.add(termTaggerButton);
topPanel.add(visualiseButton);
topPanel.add(suggestButton);
topPanel.add(clearAllButton);
topPanel.add(helpButton);
topPanel.add(new JLabel(termTaggerLogo));
return topPanel;
}","private Container createTopPanel() {
Box topPanel = Box.createHorizontalBox();
termTaggerButton = new JLabel(termTaggerIconOver);
termTaggerButton.setHorizontalAlignment(SwingConstants.LEFT);
termTaggerButton.addMouseListener(new MouseAdapter() {
            @Override
public void mouseEntered(MouseEvent mouseEvent) {
termTaggerButton.setIcon(termTaggerIconOver);
}
@Override
public void mouseExited(MouseEvent mouseEvent) {
termTaggerButton.setIcon(selectedSection == TERM_TAGGER_VIEW ? termTaggerIconOver : termTaggerIcon);
}
@Override
public void mousePressed(MouseEvent mouseEvent) {
resetButtons();
termTaggerButton.setIcon(termTaggerIconOver);
visualiseButton.setIcon(visualiseInactiveIcon);
suggestButton.setIcon(suggestInactiveIcon);
clearAllButton.setIcon(clearAllInactiveIcon);
tagTerms();
}
        });
visualiseButton = new JLabel(visualiseInactiveIcon);
visualiseButton.setHorizontalAlignment(SwingConstants.LEFT);
visualiseButton.addMouseListener(new MouseAdapter() {
            @Override
public void mouseEntered(MouseEvent mouseEvent) {
}
@Override
public void mouseExited(MouseEvent mouseEvent) {
}
@Override
public void mousePressed(MouseEvent mouseEvent) {
}
        });
suggestButton = new JLabel(suggestInactiveIcon);
suggestButton.setHorizontalAlignment(SwingConstants.LEFT);
suggestButton.addMouseListener(new MouseAdapter() {
            @Override
public void mouseEntered(MouseEvent mouseEvent) {
suggestButton.setIcon((selectedSection == TERM_TAGGER_VIEW && !isLoading) ? suggestIconOver : suggestInactiveIcon);
}
@Override
public void mouseExited(MouseEvent mouseEvent) {
suggestButton.setIcon((selectedSection == TERM_TAGGER_VIEW && !isLoading) ? suggestIcon : suggestInactiveIcon);
}
@Override
public void mousePressed(MouseEvent mouseEvent) {
if (suggestButton.getIcon() != suggestInactiveIcon) {
suggestButton.setIcon(suggestIcon);
annotationPane.autoAnnotate();
}
}
        });
clearAllButton = new JLabel(clearAllInactiveIcon);
clearAllButton.setHorizontalAlignment(SwingConstants.LEFT);
clearAllButton.addMouseListener(new MouseAdapter() {
            @Override
public void mouseEntered(MouseEvent mouseEvent) {
clearAllButton.setIcon((selectedSection == TERM_TAGGER_VIEW && !isLoading) ? clearAllIconOver : clearAllInactiveIcon);
}
@Override
public void mouseExited(MouseEvent mouseEvent) {
clearAllButton.setIcon((selectedSection == TERM_TAGGER_VIEW && !isLoading)? clearAllIcon : clearAllInactiveIcon);
}
@Override
public void mousePressed(MouseEvent mouseEvent) {
if (clearAllButton.getIcon() != clearAllInactiveIcon) {
clearAllButton.setIcon(clearAllIcon);
annotationPane.clearAnnotation();
}
}
        });
helpButton = new JLabel(helpIcon);
helpButton.setHorizontalAlignment(SwingConstants.LEFT);
helpButton.addMouseListener(new
MouseAdapter() {
                    @Override
public void mouseEntered
(MouseEvent
mouseEvent) {
helpButton.setIcon(helpIconOver);
}
@Override
public void mouseExited
(MouseEvent mouseEvent) {
helpButton.setIcon(selectedSection == HELP ? helpIconOver : helpIcon);
}
@Override
public void mousePressed
(MouseEvent
mouseEvent) {
resetButtons();
selectedSection = HELP;
helpButton.setIcon(helpIconOver);
if (helpPane == null) {
helpPane = new OntologyHelpPane();
SwingUtilities.invokeLater(new Runnable() {
                                public void run() {
helpPane.createGUI();
}
                            });
}
SwingUtilities.invokeLater(new Runnable() {
                            public void run() {
swapContainers(helpPane);
}
                        });
}
                }

        );
topPanel.add(termTaggerButton);
topPanel.add(visualiseButton);
topPanel.add(suggestButton);
topPanel.add(clearAllButton);
topPanel.add(helpButton);
topPanel.add(new JLabel(termTaggerLogo));
return topPanel;
}","private Container createTopPanel ( ) { 
 Box topPanel = Box . createHorizontalBox ( ) ; 
 termTaggerButton = new JLabel ( termTaggerIcon ) ; 
 termTaggerButton . setHorizontalAlignment ( SwingConstants . LEFT ) ; 
 termTaggerButton . addMouseListener ( new MouseAdapter ( ) { 
 @ Override 
 public void mouseEntered ( MouseEvent mouseEvent ) { 
 termTaggerButton . setIcon ( termTaggerIconOver ) ; 
 } 
 @ Override 
 public void mouseExited ( MouseEvent mouseEvent ) { 
 termTaggerButton . setIcon ( selectedSection == TERM_TAGGER_VIEW   ? termTaggerIconOver : termTaggerIcon ) ; 
 } 
 @ Override 
 public void mousePressed ( MouseEvent mouseEvent ) { 
 resetButtons ( ) ; 
 termTaggerButton . setIcon ( termTaggerIconOver ) ; 
 visualiseButton . setIcon ( visualiseInactiveIcon ) ; 
 suggestButton . setIcon ( suggestInactiveIcon ) ; 
 clearAllButton . setIcon ( clearAllInactiveIcon ) ; 
 selectedSection = TERM_TAGGER_VIEW ; 
 Thread performer = new Thread ( new Runnable ( ) { 
 public void run ( ) { 
 Map < String , Map < String , AnnotatorResult >> terms = getTerms ( ) ; 
 boolean haveTerms = terms != null ; 
 if ( haveTerms ) { 
 if ( annotationPane == null ) { 
 annotationPane = new OntologiserAnnotationPane ( terms ) ; 
 SwingUtilities . invokeLater ( new Runnable ( ) { 
 public void run ( ) { 
 annotationPane . createGUI ( ) ; 
 } 
 } ) ; 
 } 
 SwingUtilities . invokeLater ( new Runnable ( ) { 
 public void run ( ) { 
 swapContainers ( annotationPane ) ; 
 termTaggerButton . setIcon ( termTaggerIconOver ) ; 
 visualiseButton . setIcon ( visualiseIcon ) ; 
 suggestButton . setIcon ( suggestIcon ) ; 
 clearAllButton . setIcon ( clearAllIcon ) ; 
 } 
 } ) ; 
 } else { 
 // todo add info pane saying there are no terms to annotate 
 swapContainers ( helpPane ) ; 
 } 
 } 
 
 } ) ; 
 swapContainers ( UIHelper . wrapComponentInPanel ( new JLabel ( working ) ) ) ; 
 performer . start ( ) ; 
 } 
 } ) ; 
 visualiseButton = new JLabel ( visualiseInactiveIcon ) ; 
 visualiseButton . setHorizontalAlignment ( SwingConstants . LEFT ) ; 
 visualiseButton . addMouseListener ( new MouseAdapter ( ) { 
 @ Override 
 public void mouseEntered ( MouseEvent mouseEvent ) { 
 visualiseButton . setIcon ( ( selectedSection == TERM_TAGGER_VIEW | | selectedSection == VISUALISATION )   ? visualiseIconOver : visualiseInactiveIcon ) ; 
 } 
 @ Override 
 public void mouseExited ( MouseEvent mouseEvent ) { 
 visualiseButton . setIcon ( ( selectedSection == TERM_TAGGER_VIEW | | selectedSection == VISUALISATION )   ? visualiseIcon : visualiseInactiveIcon ) ; 
 } 
 @ Override 
 public void mousePressed ( MouseEvent mouseEvent ) { 
 if ( visualiseButton . getIcon ( ) != visualiseInactiveIcon ) { 
 visualiseButton . setIcon ( visualiseIcon ) ; 
 selectedSection = VISUALISATION ; 
 // todo show visualisation ... 
 } 
 } 
 } ) ; 
 suggestButton = new JLabel ( suggestInactiveIcon ) ; 
 suggestButton . setHorizontalAlignment ( SwingConstants . LEFT ) ; 
 suggestButton . addMouseListener ( new MouseAdapter ( ) { 
 @ Override 
 public void mouseEntered ( MouseEvent mouseEvent ) { 
 suggestButton . setIcon ( selectedSection == TERM_TAGGER_VIEW   ? suggestIconOver : suggestInactiveIcon ) ; 
 } 
 @ Override 
 public void mouseExited ( MouseEvent mouseEvent ) { 
 suggestButton . setIcon ( selectedSection == TERM_TAGGER_VIEW   ? suggestIcon : suggestInactiveIcon ) ; 
 } 
 @ Override 
 public void mousePressed ( MouseEvent mouseEvent ) { 
 if ( suggestButton . getIcon ( ) != suggestInactiveIcon ) { 
 suggestButton . setIcon ( suggestIcon ) ; 
 annotationPane . autoAnnotate ( ) ; 
 } 
 } 
 } ) ; 
 clearAllButton = new JLabel ( clearAllInactiveIcon ) ; 
 clearAllButton . setHorizontalAlignment ( SwingConstants . LEFT ) ; 
 clearAllButton . addMouseListener ( new MouseAdapter ( ) { 
 @ Override 
 public void mouseEntered ( MouseEvent mouseEvent ) { 
 clearAllButton . setIcon ( selectedSection == TERM_TAGGER_VIEW   ? clearAllIconOver : clearAllInactiveIcon ) ; 
 } 
 @ Override 
 public void mouseExited ( MouseEvent mouseEvent ) { 
 clearAllButton . setIcon ( selectedSection == TERM_TAGGER_VIEW   ? clearAllIcon : clearAllInactiveIcon ) ; 
 } 
 @ Override 
 public void mousePressed ( MouseEvent mouseEvent ) { 
 if ( clearAllButton . getIcon ( ) != clearAllInactiveIcon ) { 
 clearAllButton . setIcon ( clearAllIcon ) ; 
 annotationPane . clearAnnotation ( ) ; 
 } 
 } 
 } ) ; 
 helpButton = new JLabel ( helpIconOver ) ; 
 helpButton . setHorizontalAlignment ( SwingConstants . LEFT ) ; 
 helpButton . addMouseListener ( new 
 MouseAdapter ( ) { 
 @ Override 
 public void mouseEntered 
 ( MouseEvent 
 mouseEvent ) { 
 helpButton . setIcon ( helpIconOver ) ; 
 } 
 @ Override 
 public void mouseExited 
 ( MouseEvent mouseEvent ) { 
 helpButton . setIcon ( selectedSection == HELP   ? helpIconOver : helpIcon ) ; 
 } 
 @ Override 
 public void mousePressed 
 ( MouseEvent 
 mouseEvent ) { 
 resetButtons ( ) ; 
 selectedSection = HELP ; 
 helpButton . setIcon ( helpIconOver ) ; 
 if ( helpPane == null ) { 
 helpPane = new OntologyHelpPane ( ) ; 
 SwingUtilities . invokeLater ( new Runnable ( ) { 
 public void run ( ) { 
 helpPane . createGUI ( ) ; 
 } 
 } ) ; 
 } 
 SwingUtilities . invokeLater ( new Runnable ( ) { 
 public void run ( ) { 
 swapContainers ( helpPane ) ; 
 } 
 } ) ; 
 } 
 } 
 
 ) ; 
 topPanel . add ( termTaggerButton ) ; 
 topPanel . add ( visualiseButton ) ; 
 topPanel . add ( suggestButton ) ; 
 topPanel . add ( clearAllButton ) ; 
 topPanel . add ( helpButton ) ; 
 topPanel . add ( new JLabel ( termTaggerLogo ) ) ; 
 return topPanel ; 
 }  ","private Container createTopPanel ( ) { 
 Box topPanel = Box . createHorizontalBox ( ) ; 
 termTaggerButton = new JLabel ( termTaggerIconOver ) ; 
 termTaggerButton . setHorizontalAlignment ( SwingConstants . LEFT ) ; 
 termTaggerButton . addMouseListener ( new MouseAdapter ( ) { 
 @ Override 
 public void mouseEntered ( MouseEvent mouseEvent ) { 
 termTaggerButton . setIcon ( termTaggerIconOver ) ; 
 } 
 @ Override 
 public void mouseExited ( MouseEvent mouseEvent ) { 
 termTaggerButton . setIcon ( selectedSection == TERM_TAGGER_VIEW   ? termTaggerIconOver : termTaggerIcon ) ; 
 } 
 @ Override 
 public void mousePressed ( MouseEvent mouseEvent ) { 
 resetButtons ( ) ; 
 termTaggerButton . setIcon ( termTaggerIconOver ) ; 
 visualiseButton . setIcon ( visualiseInactiveIcon ) ; 
 suggestButton . setIcon ( suggestInactiveIcon ) ; 
 clearAllButton . setIcon ( clearAllInactiveIcon ) ; 
 tagTerms ( ) ; 
 } 
 } ) ; 
 visualiseButton = new JLabel ( visualiseInactiveIcon ) ; 
 visualiseButton . setHorizontalAlignment ( SwingConstants . LEFT ) ; 
 visualiseButton . addMouseListener ( new MouseAdapter ( ) { 
 @ Override 
 public void mouseEntered ( MouseEvent mouseEvent ) { 
 } 
 @ Override 
 public void mouseExited ( MouseEvent mouseEvent ) { 
 } 
 @ Override 
 public void mousePressed ( MouseEvent mouseEvent ) { 
 } 
 } ) ; 
 suggestButton = new JLabel ( suggestInactiveIcon ) ; 
 suggestButton . setHorizontalAlignment ( SwingConstants . LEFT ) ; 
 suggestButton . addMouseListener ( new MouseAdapter ( ) { 
 @ Override 
 public void mouseEntered ( MouseEvent mouseEvent ) { 
 suggestButton . setIcon ( ( selectedSection == TERM_TAGGER_VIEW & &   ! isLoading )   ? suggestIconOver : suggestInactiveIcon ) ; 
 } 
 @ Override 
 public void mouseExited ( MouseEvent mouseEvent ) { 
 suggestButton . setIcon ( ( selectedSection == TERM_TAGGER_VIEW & &   ! isLoading )   ? suggestIcon : suggestInactiveIcon ) ; 
 } 
 @ Override 
 public void mousePressed ( MouseEvent mouseEvent ) { 
 if ( suggestButton . getIcon ( ) != suggestInactiveIcon ) { 
 suggestButton . setIcon ( suggestIcon ) ; 
 annotationPane . autoAnnotate ( ) ; 
 } 
 } 
 } ) ; 
 clearAllButton = new JLabel ( clearAllInactiveIcon ) ; 
 clearAllButton . setHorizontalAlignment ( SwingConstants . LEFT ) ; 
 clearAllButton . addMouseListener ( new MouseAdapter ( ) { 
 @ Override 
 public void mouseEntered ( MouseEvent mouseEvent ) { 
 clearAllButton . setIcon ( ( selectedSection == TERM_TAGGER_VIEW & &   ! isLoading )   ? clearAllIconOver : clearAllInactiveIcon ) ; 
 } 
 @ Override 
 public void mouseExited ( MouseEvent mouseEvent ) { 
 clearAllButton . setIcon ( ( selectedSection == TERM_TAGGER_VIEW & &   ! isLoading ) ? clearAllIcon : clearAllInactiveIcon ) ; 
 } 
 @ Override 
 public void mousePressed ( MouseEvent mouseEvent ) { 
 if ( clearAllButton . getIcon ( ) != clearAllInactiveIcon ) { 
 clearAllButton . setIcon ( clearAllIcon ) ; 
 annotationPane . clearAnnotation ( ) ; 
 } 
 } 
 } ) ; 
 helpButton = new JLabel ( helpIcon ) ; 
 helpButton . setHorizontalAlignment ( SwingConstants . LEFT ) ; 
 helpButton . addMouseListener ( new 
 MouseAdapter ( ) { 
 @ Override 
 public void mouseEntered 
 ( MouseEvent 
 mouseEvent ) { 
 helpButton . setIcon ( helpIconOver ) ; 
 } 
 @ Override 
 public void mouseExited 
 ( MouseEvent mouseEvent ) { 
 helpButton . setIcon ( selectedSection == HELP   ? helpIconOver : helpIcon ) ; 
 } 
 @ Override 
 public void mousePressed 
 ( MouseEvent 
 mouseEvent ) { 
 resetButtons ( ) ; 
 selectedSection = HELP ; 
 helpButton . setIcon ( helpIconOver ) ; 
 if ( helpPane == null ) { 
 helpPane = new OntologyHelpPane ( ) ; 
 SwingUtilities . invokeLater ( new Runnable ( ) { 
 public void run ( ) { 
 helpPane . createGUI ( ) ; 
 } 
 } ) ; 
 } 
 SwingUtilities . invokeLater ( new Runnable ( ) { 
 public void run ( ) { 
 swapContainers ( helpPane ) ; 
 } 
 } ) ; 
 } 
 } 
 
 ) ; 
 topPanel . add ( termTaggerButton ) ; 
 topPanel . add ( visualiseButton ) ; 
 topPanel . add ( suggestButton ) ; 
 topPanel . add ( clearAllButton ) ; 
 topPanel . add ( helpButton ) ; 
 topPanel . add ( new JLabel ( termTaggerLogo ) ) ; 
 return topPanel ; 
 }  ",2011-02-13 09:22:26 +0000,2011-06-05 21:49:25 +0100,0,0.9536882860921981
568,167,https://www.github.com/bcdev/beam,"readGlobalMetaData(File, NetcdfFile)",,259,259,259,259,@todo 1 tb/tb add QC file,https://www.github.com/bcdev/beam/commit/c415b48f32,https://www.github.com/bcdev/beam/commit/6a09db305f58ae484f24241fe62828de34b5fe97,beam-modis-reader/src/main/java/org/esa/beam/dataio/modis/ModisProductReader.java,"private void readGlobalMetaData(File inFile, NetcdfFile netcdfFile) throws  ProductIOException {
try {
_globalHdfAttrs = HdfUtils.readAttributes(_sdStart);
} catch (HDFException e) {
throw new ProductIOException(e.getMessage());
}
// check wheter daac or imapp
if (isImappFormat()) {
// @todo 1 tb/tb add QC file
_globalAttributes = new ModisImappAttributes(inFile, netcdfFile, null, _globalHdfAttrs);
} else {
_globalAttributes = new ModisDaacAttributes(_globalHdfAttrs);
}
}","private void readGlobalMetaData(File inFile, NetcdfFile netcdfFile) throws  ProductIOException {
try {
_globalHdfAttrs = HdfUtils.readAttributes(_sdStart);
} catch (HDFException e) {
throw new ProductIOException(e.getMessage());
}
// check wheter daac or imapp
if (isImappFormat()) {
_globalAttributes = new ModisImappAttributes(inFile, netcdfFile);
} else {
_globalAttributes = new ModisDaacAttributes(_globalHdfAttrs);
}
}","private void readGlobalMetaData ( File inFile , NetcdfFile netcdfFile ) throws ProductIOException { 
 try { 
 _globalHdfAttrs = HdfUtils . readAttributes ( _sdStart ) ; 
 } catch ( HDFException e ) { 
 throw new ProductIOException ( e . getMessage ( ) ) ; 
 } 
 // check wheter daac or imapp 
 if ( isImappFormat ( ) ) { 
 // @ todo 1 tb / tb add QC file 
 _globalAttributes = new ModisImappAttributes ( inFile , netcdfFile , null , _globalHdfAttrs ) ; 
 } else { 
 _globalAttributes = new ModisDaacAttributes ( _globalHdfAttrs ) ; 
 } 
 }  ","private void readGlobalMetaData ( File inFile , NetcdfFile netcdfFile ) throws ProductIOException { 
 try { 
 _globalHdfAttrs = HdfUtils . readAttributes ( _sdStart ) ; 
 } catch ( HDFException e ) { 
 throw new ProductIOException ( e . getMessage ( ) ) ; 
 } 
 // check wheter daac or imapp 
 if ( isImappFormat ( ) ) { 
 _globalAttributes = new ModisImappAttributes ( inFile , netcdfFile ) ; 
 } else { 
 _globalAttributes = new ModisDaacAttributes ( _globalHdfAttrs ) ; 
 } 
 }  ",2012-03-13 17:39:05 +0100,2012-03-14 22:05:45 +0100,0,0.9234486717335877
1274,626,https://www.github.com/apache/flume,testLifecycle(),,85,85,85,85,FIXME: Ensure proper send / received semantics.,https://www.github.com/apache/flume/commit/f60820407,https://www.github.com/apache/flume/commit/4bc8dfe6506ab5ead6f88ee0cbbcd8c74d58e135,flume-ng-node/src/test/java/org/apache/flume/source/TestNetcatSource.java,"@Test
public void testLifecycle() throws InterruptedException, LifecycleException,
      EventDeliveryException {
ExecutorService executor = Executors.newFixedThreadPool(3);
Context context = new Context();
/* FIXME: Use a random port for testing. */
context.put(""bind"", ""0.0.0.0"");
context.put(""port"", ""41414"");
Configurables.configure(source, context);
source.start();
/* FIXME: Ensure proper send / received semantics. */
Runnable clientRequestRunnable = new Runnable() {

      @Override
public void run() {
try {
SocketChannel clientChannel = SocketChannel
.open(new InetSocketAddress(41414));
Writer writer = Channels.newWriter(clientChannel, ""utf-8"");
writer.write(""Test message"");
writer.flush();
clientChannel.close();
} catch (IOException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
}

    };
ChannelSelector seclector = source.getChannelProcessor().getSelector();
Transaction tx = seclector.getAllChannels().get(0).getTransaction();
tx.begin();
for (int i = 0; i < 100; i++) {
executor.submit(clientRequestRunnable);
Event event = channel.take();
Assert.assertNotNull(event);
Assert.assertArrayEquals(""Test message"".getBytes(), event.getBody());
}
tx.commit();
tx.close();
executor.shutdown();
while (!executor.isTerminated()) {
executor.awaitTermination(500, TimeUnit.MILLISECONDS);
}
source.stop();
}","@Test
public void testLifecycle() throws InterruptedException, LifecycleException,
      EventDeliveryException {
ExecutorService executor = Executors.newFixedThreadPool(3);
Context context = new Context();
/* FIXME: Use a random port for testing. */
context.put(""bind"", ""0.0.0.0"");
context.put(""port"", ""41414"");
Configurables.configure(source, context);
source.start();
Runnable clientRequestRunnable = new Runnable() {

      @Override
public void run() {
try {
SocketChannel clientChannel = SocketChannel
.open(new InetSocketAddress(41414));
Writer writer = Channels.newWriter(clientChannel, ""utf-8"");
BufferedReader reader = new BufferedReader(
              Channels.newReader(clientChannel, ""utf-8""));
writer.write(""Test message\n"");
writer.flush();
String response = reader.readLine();
Assert.assertEquals(""Server should return OK"", ""OK"", response);
clientChannel.close();
} catch (IOException e) {
logger.error(""Caught exception: "", e);
}
}

    };
ChannelSelector selector = source.getChannelProcessor().getSelector();
Transaction tx = selector.getAllChannels().get(0).getTransaction();
tx.begin();
for (int i = 0; i < 100; i++) {
logger.info(""Sending request"");
executor.submit(clientRequestRunnable);
Event event = channel.take();
Assert.assertNotNull(event);
Assert.assertArrayEquals(""Test message"".getBytes(), event.getBody());
}
tx.commit();
tx.close();
executor.shutdown();
while (!executor.isTerminated()) {
executor.awaitTermination(500, TimeUnit.MILLISECONDS);
}
source.stop();
}","@ Test 
 public void testLifecycle ( ) throws InterruptedException , LifecycleException , 
        EventDeliveryException { 
 ExecutorService executor = Executors . newFixedThreadPool ( 3 ) ; 
 Context context = new Context ( ) ; 
 / * FIXME : Use a random port for testing . * / 
 context . put ( ""bind"" , ""0.0.0.0"" ) ; 
 context . put ( ""port"" , ""41414"" ) ; 
 Configurables . configure ( source , context ) ; 
 source . start ( ) ; 
 / * FIXME : Ensure proper send / received semantics . * / 
 Runnable clientRequestRunnable = new Runnable ( ) { 
 
 @ Override 
 public void run ( ) { 
 try { 
 SocketChannel clientChannel = SocketChannel 
 . open ( new InetSocketAddress ( 41414 ) ) ; 
 Writer writer = Channels . newWriter ( clientChannel , ""utf-8"" ) ; 
 writer . write ( ""Test message"" ) ; 
 writer . flush ( ) ; 
 clientChannel . close ( ) ; 
 } catch ( IOException e ) { 
 // TODO Auto - generated catch block 
 e . printStackTrace ( ) ; 
 } 
 } 
 
 } ; 
 ChannelSelector seclector = source . getChannelProcessor ( ) . getSelector ( ) ; 
 Transaction tx = seclector . getAllChannels ( ) . get ( 0 ) . getTransaction ( ) ; 
 tx . begin ( ) ; 
 for ( int i = 0 ; i < 100 ; i + + ) { 
 executor . submit ( clientRequestRunnable ) ; 
 Event event = channel . take ( ) ; 
 Assert . assertNotNull ( event ) ; 
 Assert . assertArrayEquals ( ""Test message"" . getBytes ( ) , event . getBody ( ) ) ; 
 } 
 tx . commit ( ) ; 
 tx . close ( ) ; 
 executor . shutdown ( ) ; 
 while ( ! executor . isTerminated ( ) ) { 
 executor . awaitTermination ( 500 , TimeUnit . MILLISECONDS ) ; 
 } 
 source . stop ( ) ; 
 }   ","@ Test 
 public void testLifecycle ( ) throws InterruptedException , LifecycleException , 
        EventDeliveryException { 
 ExecutorService executor = Executors . newFixedThreadPool ( 3 ) ; 
 Context context = new Context ( ) ; 
 / * FIXME : Use a random port for testing . * / 
 context . put ( ""bind"" , ""0.0.0.0"" ) ; 
 context . put ( ""port"" , ""41414"" ) ; 
 Configurables . configure ( source , context ) ; 
 source . start ( ) ; 
 Runnable clientRequestRunnable = new Runnable ( ) { 
 
 @ Override 
 public void run ( ) { 
 try { 
 SocketChannel clientChannel = SocketChannel 
 . open ( new InetSocketAddress ( 41414 ) ) ; 
 Writer writer = Channels . newWriter ( clientChannel , ""utf-8"" ) ; 
 BufferedReader reader = new BufferedReader ( 
 Channels . newReader ( clientChannel , ""utf-8"" ) ) ; 
 writer . write ( ""Test message\n"" ) ; 
 writer . flush ( ) ; 
 String response = reader . readLine ( ) ; 
 Assert . assertEquals ( ""Server should return OK"" , ""OK"" , response ) ; 
 clientChannel . close ( ) ; 
 } catch ( IOException e ) { 
 logger . error ( ""Caught exception: "" , e ) ; 
 } 
 } 
 
 } ; 
 ChannelSelector selector = source . getChannelProcessor ( ) . getSelector ( ) ; 
 Transaction tx = selector . getAllChannels ( ) . get ( 0 ) . getTransaction ( ) ; 
 tx . begin ( ) ; 
 for ( int i = 0 ; i < 100 ; i + + ) { 
 logger . info ( ""Sending request"" ) ; 
 executor . submit ( clientRequestRunnable ) ; 
 Event event = channel . take ( ) ; 
 Assert . assertNotNull ( event ) ; 
 Assert . assertArrayEquals ( ""Test message"" . getBytes ( ) , event . getBody ( ) ) ; 
 } 
 tx . commit ( ) ; 
 tx . close ( ) ; 
 executor . shutdown ( ) ; 
 while ( ! executor . isTerminated ( ) ) { 
 executor . awaitTermination ( 500 , TimeUnit . MILLISECONDS ) ; 
 } 
 source . stop ( ) ; 
 }   ",2011-09-05 21:51:26 +0000,2012-03-29 02:09:29 +0000,0,0.8761928252232796
1140,100,https://www.github.com/apache/cocoon,configure(Configuration),,185,185,185,185,TODO: add classloader to constructor to be able to propagate parentManager's CL,https://www.github.com/apache/cocoon/commit/164dcf8d3ef,https://www.github.com/apache/cocoon/commit/e8f3e7b66693b415c18b5a1450bfed338865ee31,src/core/java/org/apache/cocoon/core/container/CoreServiceManager.java,"public void configure(Configuration configuration) throws ConfigurationException {
ClassLoader classLoader = null;
Configuration classLoaderConfig = configuration.getChild(""classpath"", false);
// We have a specific classpath for this manager
if (classLoaderConfig != null) {
// We need a parent manager to lookup the CL factory
if (this.parentManager == null) {
throw new ConfigurationException(""Cannot set <classpath> on root ServiceManager at "" +
classLoaderConfig.getLocation());
}
try {
ClassLoaderFactory clFactory = (ClassLoaderFactory)this.parentManager.lookup(ClassLoaderFactory.ROLE);
// TODO: add classloader to constructor to be able to propagate parentManager's CL
classLoader = clFactory.createClassLoader(Thread.currentThread().getContextClassLoader(), classLoaderConfig);
} catch (ConfigurationException ce) {
throw ce;
} catch (Exception e) {
throw new ConfigurationException(""Cannot setup classloader"", e);
}
}
this.componentEnv = new ComponentEnvironment(classLoader, getLogger(), this.roleManager, this.loggerManager, this.context, this);
// Setup location
this.location = configuration.getLocation();
// Find the current URI
String currentURI;
int pos = this.location.lastIndexOf(':');
if (pos == -1) {
// No available location: start at the context
currentURI = ""context://"";
} else {
pos = this.location.lastIndexOf(':', pos);
currentURI = this.location.substring(0, pos-1);
}
try {
// and load configuration with a empty list of loaded configurations
parseConfiguration(configuration, currentURI, new HashSet());
} finally {
// Release any source resolver that may have been created to load includes
releaseCachedSourceResolver();
}
}","public void configure(Configuration configuration) throws ConfigurationException {
this.componentEnv = new ComponentEnvironment(this.classloader, getLogger(), this.roleManager, this.loggerManager, this.context, this);
// Setup location
this.location = configuration.getLocation();
// Find the current URI
String currentURI;
int pos = this.location.lastIndexOf(':');
if (pos == -1) {
// No available location: start at the context
currentURI = ""context://"";
} else {
pos = this.location.lastIndexOf(':', pos);
currentURI = this.location.substring(0, pos-1);
}
try {
// and load configuration with a empty list of loaded configurations
parseConfiguration(configuration, currentURI, new HashSet());
} finally {
// Release any source resolver that may have been created to load includes
releaseCachedSourceResolver();
}
}","public void configure ( Configuration configuration ) throws ConfigurationException { 
 ClassLoader classLoader = null ; 
 Configuration classLoaderConfig = configuration . getChild ( ""classpath"" , false ) ; 
 // We have a specific classpath for this manager 
 if ( classLoaderConfig != null ) { 
 // We need a parent manager to lookup the CL factory 
 if ( this . parentManager == null ) { 
 throw new ConfigurationException ( ""Cannot set <classpath> on root ServiceManager at "" + 
 classLoaderConfig . getLocation ( ) ) ; 
 } 
 try { 
 ClassLoaderFactory clFactory = ( ClassLoaderFactory ) this . parentManager . lookup ( ClassLoaderFactory . ROLE ) ; 
 // TODO : add classloader to constructor to be able to propagate parentManager ' s CL 
 classLoader = clFactory . createClassLoader ( Thread . currentThread ( ) . getContextClassLoader ( ) , classLoaderConfig ) ; 
 } catch ( ConfigurationException ce ) { 
 throw ce ; 
 } catch ( Exception e ) { 
 throw new ConfigurationException ( ""Cannot setup classloader"" , e ) ; 
 } 
 } 
 this . componentEnv = new ComponentEnvironment ( classLoader , getLogger ( ) , this . roleManager , this . loggerManager , this . context , this ) ; 
 // Setup location 
 this . location = configuration . getLocation ( ) ; 
 // Find the current URI 
 String currentURI ; 
 int pos = this . location . lastIndexOf ( ':' ) ; 
 if ( pos == - 1 ) { 
 // No available location : start at the context 
 currentURI = ""context://"" ; 
 } else { 
 pos = this . location . lastIndexOf ( ':' , pos ) ; 
 currentURI = this . location . substring ( 0 , pos - 1 ) ; 
 } 
 try { 
 // and load configuration with a empty list of loaded configurations 
 parseConfiguration ( configuration , currentURI , new HashSet ( ) ) ; 
 } finally { 
 // Release any source resolver that may have been created to load includes 
 releaseCachedSourceResolver ( ) ; 
 } 
 }  ","public void configure ( Configuration configuration ) throws ConfigurationException { 
 this . componentEnv = new ComponentEnvironment ( this . classloader , getLogger ( ) , this . roleManager , this . loggerManager , this . context , this ) ; 
 // Setup location 
 this . location = configuration . getLocation ( ) ; 
 // Find the current URI 
 String currentURI ; 
 int pos = this . location . lastIndexOf ( ':' ) ; 
 if ( pos == - 1 ) { 
 // No available location : start at the context 
 currentURI = ""context://"" ; 
 } else { 
 pos = this . location . lastIndexOf ( ':' , pos ) ; 
 currentURI = this . location . substring ( 0 , pos - 1 ) ; 
 } 
 try { 
 // and load configuration with a empty list of loaded configurations 
 parseConfiguration ( configuration , currentURI , new HashSet ( ) ) ; 
 } finally { 
 // Release any source resolver that may have been created to load includes 
 releaseCachedSourceResolver ( ) ; 
 } 
 }  ",2005-03-09 14:09:25 +0000,2005-03-10 22:47:14 +0000,0,0.7548898964841032
3153,49,https://www.github.com/apache/camel,testCopy(),,139,139,139,139,TODO: fix me,https://www.github.com/apache/camel/commit/bd9e5e5ce92b,https://www.github.com/apache/camel/commit/ac37cf1d5a90f20452913580c0a86e4d470ecbed,camel-core/src/test/java/org/apache/camel/impl/DefaultExchangeTest.java,"public void testCopy() {
DefaultExchange sourceExchange =  new DefaultExchange(context);
MyMessage sourceIn = new MyMessage();
sourceExchange.setIn(sourceIn);
Exchange destExchange = sourceExchange.copy();
Message destIn = destExchange.getIn();
// TODO: fix me
// assertEquals(""dest message should be of the same type as source message"", sourceIn.getClass(), destIn.getClass());
}","public void testCopy() {
DefaultExchange sourceExchange = new DefaultExchange(context);
MyMessage sourceIn = new MyMessage();
sourceExchange.setIn(sourceIn);
Exchange destExchange = sourceExchange.copy();
Message destIn = destExchange.getIn();
assertEquals(""Dest message should be of the same type as source message"",
                     sourceIn.getClass(), destIn.getClass());
}","public void testCopy ( ) { 
 DefaultExchange sourceExchange = new DefaultExchange ( context ) ; 
 MyMessage sourceIn = new MyMessage ( ) ; 
 sourceExchange . setIn ( sourceIn ) ; 
 Exchange destExchange = sourceExchange . copy ( ) ; 
 Message destIn = destExchange . getIn ( ) ; 
 // TODO : fix me 
 // assertEquals ( ""dest message should be of the same type as source message"" , sourceIn . getClass ( ) , destIn . getClass ( ) ) ; 
 }  ","public void testCopy ( ) { 
 DefaultExchange sourceExchange = new DefaultExchange ( context ) ; 
 MyMessage sourceIn = new MyMessage ( ) ; 
 sourceExchange . setIn ( sourceIn ) ; 
 Exchange destExchange = sourceExchange . copy ( ) ; 
 Message destIn = destExchange . getIn ( ) ; 
 assertEquals ( ""Dest message should be of the same type as source message"" , 
 sourceIn . getClass ( ) , destIn . getClass ( ) ) ; 
 }  ",2011-08-27 07:12:20 +0000,2011-08-29 11:42:15 +0000,0,0.9823211446284135
218,394,https://www.github.com/osmandapp/osmand,writeBinaryTransportIndex(BinaryMapIndexWriter),,1692,1692,1692,1692,TODO prepare transportStopsTree!!!,https://www.github.com/osmandapp/osmand/commit/880b5e55411,https://www.github.com/osmandapp/osmand/commit/d1c5fdfb395bcc806b4d6557ff92ce05ad1bd7ff,DataExtractionOSM/src/net/osmand/data/preparation/IndexCreator.java,"public void writeBinaryTransportIndex(BinaryMapIndexWriter writer) throws IOException, SQLException {
try {
visitedStops = null; // allow gc to collect it
PreparedStatement selectTransportRouteData = mapConnection.prepareStatement(""SELECT * FROM "" + IndexTransportRoute.getTable());
PreparedStatement selectTransportData = mapConnection.prepareStatement(""SELECT S.stop, S.direction,"" +
""  A.latitude,  A.longitude, A.name, A.name_en "" +
""FROM transport_route_stop S INNER JOIN transport_stop A ON A.id = S.stop ORDER BY S.ord ASC WHERE S.route = ?"");
writer.startWriteTransportIndex();
// expect that memory would be enough
Map<String, Integer> stringTable = createStringTableForTransport();
ResultSet rs = selectTransportRouteData.executeQuery();
List<TransportStop> directStops = new ArrayList<TransportStop>();
List<TransportStop> reverseStops = new ArrayList<TransportStop>();
while(rs.next()){
long idRoute = rs.getLong(IndexTransportRoute.ID.ordinal() + 1);
int dist = rs.getInt(IndexTransportRoute.DIST.ordinal() + 1);
String routeName = rs.getString(IndexTransportRoute.NAME.ordinal() + 1);
String routeEnName = rs.getString(IndexTransportRoute.NAME_EN.ordinal() + 1);
if(routeEnName != null && routeEnName.equals(Junidecode.unidecode(routeName))){
routeEnName = null;
}
String ref = rs.getString(IndexTransportRoute.REF.ordinal() + 1);
String operator = rs.getString(IndexTransportRoute.OPERATOR.ordinal() + 1);
String type = rs.getString(IndexTransportRoute.TYPE.ordinal() + 1);
selectTransportData.setLong(1, idRoute);
ResultSet rset = selectTransportData.executeQuery();
while (rset.next()) {
boolean dir = rset.getInt(2) != 0;
long idStop = rset.getInt(1);
String stopName = rset.getString(5);
String stopEnName = rset.getString(6);
if (stopEnName != null && stopEnName.equals(Junidecode.unidecode(stopName))) {
stopEnName = null;
}
TransportStop st = new TransportStop();
st.setId(idStop);
st.setName(stopName);
st.setLocation(rset.getDouble(3), rset.getDouble(4));
if (stopEnName != null) {
st.setEnName(stopEnName);
}
if(dir){
directStops.add(st);
} else {
reverseStops.add(st);
}
}
writer.writeTransportRoute(idRoute, routeName, routeEnName, ref, operator, type, dist, directStops, reverseStops, stringTable);
}
rs.close();
selectTransportRouteData.close();
// TODO prepare transportStopsTree!!!
PreparedStatement selectTransportStop = mapConnection.prepareStatement(
					""SELECT A.id,  A.latitude,  A.longitude, A.name, A.name_en FROM transport_stop A where A.id = ?"");
PreparedStatement selectTransportRouteStop = mapConnection.prepareStatement(
					""SELECT S.route FROM transport_route_stop S WHERE S.stop = ? "");
long rootIndex = transportStopsTree.getFileHdr().getRootIndex();
rtree.Node root = transportStopsTree.getReadNode(rootIndex);
Rect rootBounds = calcBounds(root);
if (rootBounds != null) {
writer.startTransportTreeElement(rootBounds.getMinX(), rootBounds.getMaxX(), rootBounds.getMinY(), rootBounds.getMaxY());
writeBinaryTransportTree(root, transportStopsTree, writer, selectTransportStop, selectTransportRouteStop);
writer.endWriteTransportTreeElement();
}
writer.writeTransportStringTable(stringTable);
writer.endWriteTransportIndex();
} catch (RTreeException e) {
throw new IllegalStateException(e);
}
}","public void writeBinaryTransportIndex(BinaryMapIndexWriter writer) throws IOException, SQLException {
try {
visitedStops = null; // allow gc to collect it
PreparedStatement selectTransportRouteData = mapConnection.prepareStatement(""SELECT * FROM "" + IndexTransportRoute.getTable());
PreparedStatement selectTransportData = mapConnection.prepareStatement(""SELECT S.stop, S.direction,"" +
""  A.latitude,  A.longitude, A.name, A.name_en "" +
""FROM transport_route_stop S INNER JOIN transport_stop A ON A.id = S.stop WHERE S.route = ? ORDER BY S.ord asc"");
writer.startWriteTransportIndex();
// expect that memory would be enough
Map<String, Integer> stringTable = createStringTableForTransport();
Map<Long, Long> transportRoutes = new LinkedHashMap<Long, Long>();
ResultSet rs = selectTransportRouteData.executeQuery();
List<TransportStop> directStops = new ArrayList<TransportStop>();
List<TransportStop> reverseStops = new ArrayList<TransportStop>();
while(rs.next()){
long idRoute = rs.getLong(IndexTransportRoute.ID.ordinal() + 1);
int dist = rs.getInt(IndexTransportRoute.DIST.ordinal() + 1);
String routeName = rs.getString(IndexTransportRoute.NAME.ordinal() + 1);
String routeEnName = rs.getString(IndexTransportRoute.NAME_EN.ordinal() + 1);
if(routeEnName != null && routeEnName.equals(Junidecode.unidecode(routeName))){
routeEnName = null;
}
String ref = rs.getString(IndexTransportRoute.REF.ordinal() + 1);
String operator = rs.getString(IndexTransportRoute.OPERATOR.ordinal() + 1);
String type = rs.getString(IndexTransportRoute.TYPE.ordinal() + 1);
selectTransportData.setLong(1, idRoute);
ResultSet rset = selectTransportData.executeQuery();
reverseStops.clear();
directStops.clear();
while (rset.next()) {
boolean dir = rset.getInt(2) != 0;
long idStop = rset.getInt(1);
String stopName = rset.getString(5);
String stopEnName = rset.getString(6);
if (stopEnName != null && stopEnName.equals(Junidecode.unidecode(stopName))) {
stopEnName = null;
}
TransportStop st = new TransportStop();
st.setId(idStop);
st.setName(stopName);
st.setLocation(rset.getDouble(3), rset.getDouble(4));
if (stopEnName != null) {
st.setEnName(stopEnName);
}
if(dir){
directStops.add(st);
} else {
reverseStops.add(st);
}
}
writer.writeTransportRoute(idRoute, routeName, routeEnName, ref, operator, type, dist, directStops, reverseStops, 
						stringTable, transportRoutes);
}
rs.close();
selectTransportRouteData.close();
PreparedStatement selectTransportStop = mapConnection.prepareStatement(
					""SELECT A.id,  A.latitude,  A.longitude, A.name, A.name_en FROM transport_stop A where A.id = ?"");
PreparedStatement selectTransportRouteStop = mapConnection.prepareStatement(
					""SELECT DISTINCT S.route FROM transport_route_stop S WHERE S.stop = ? "");
long rootIndex = transportStopsTree.getFileHdr().getRootIndex();
rtree.Node root = transportStopsTree.getReadNode(rootIndex);
Rect rootBounds = calcBounds(root);
if (rootBounds != null) {
writer.startTransportTreeElement(rootBounds.getMinX(), rootBounds.getMaxX(), rootBounds.getMinY(), rootBounds.getMaxY());
writeBinaryTransportTree(root, transportStopsTree, writer, selectTransportStop, selectTransportRouteStop, 
						transportRoutes, stringTable);
writer.endWriteTransportTreeElement();
}
writer.writeTransportStringTable(stringTable);
writer.endWriteTransportIndex();
} catch (RTreeException e) {
throw new IllegalStateException(e);
}
}","public void writeBinaryTransportIndex ( BinaryMapIndexWriter writer ) throws IOException , SQLException { 
 try { 
 visitedStops = null ; // allow gc to collect it 
 PreparedStatement selectTransportRouteData = mapConnection . prepareStatement ( ""SELECT * FROM "" + IndexTransportRoute . getTable ( ) ) ; 
 PreparedStatement selectTransportData = mapConnection . prepareStatement ( ""SELECT S.stop, S.direction,"" + 
 ""  A.latitude,  A.longitude, A.name, A.name_en "" + 
 ""FROM transport_route_stop S INNER JOIN transport_stop A ON A.id = S.stop ORDER BY S.ord ASC WHERE S.route = ?"" ) ; 
 writer . startWriteTransportIndex ( ) ; 
 // expect that memory would be enough 
 Map < String , Integer > stringTable = createStringTableForTransport ( ) ; 
 ResultSet rs = selectTransportRouteData . executeQuery ( ) ; 
 List < TransportStop > directStops = new ArrayList < TransportStop > ( ) ; 
 List < TransportStop > reverseStops = new ArrayList < TransportStop > ( ) ; 
 while ( rs . next ( ) ) { 
 long idRoute = rs . getLong ( IndexTransportRoute . ID . ordinal ( ) + 1 ) ; 
 int dist = rs . getInt ( IndexTransportRoute . DIST . ordinal ( ) + 1 ) ; 
 String routeName = rs . getString ( IndexTransportRoute . NAME . ordinal ( ) + 1 ) ; 
 String routeEnName = rs . getString ( IndexTransportRoute . NAME_EN . ordinal ( ) + 1 ) ; 
 if ( routeEnName != null & & routeEnName . equals ( Junidecode . unidecode ( routeName ) ) ) { 
 routeEnName = null ; 
 } 
 String ref = rs . getString ( IndexTransportRoute . REF . ordinal ( ) + 1 ) ; 
 String operator = rs . getString ( IndexTransportRoute . OPERATOR . ordinal ( ) + 1 ) ; 
 String type = rs . getString ( IndexTransportRoute . TYPE . ordinal ( ) + 1 ) ; 
 selectTransportData . setLong ( 1 , idRoute ) ; 
 ResultSet rset = selectTransportData . executeQuery ( ) ; 
 while ( rset . next ( ) ) { 
 boolean dir = rset . getInt ( 2 ) != 0 ; 
 long idStop = rset . getInt ( 1 ) ; 
 String stopName = rset . getString ( 5 ) ; 
 String stopEnName = rset . getString ( 6 ) ; 
 if ( stopEnName != null & & stopEnName . equals ( Junidecode . unidecode ( stopName ) ) ) { 
 stopEnName = null ; 
 } 
 TransportStop st = new TransportStop ( ) ; 
 st . setId ( idStop ) ; 
 st . setName ( stopName ) ; 
 st . setLocation ( rset . getDouble ( 3 ) , rset . getDouble ( 4 ) ) ; 
 if ( stopEnName != null ) { 
 st . setEnName ( stopEnName ) ; 
 } 
 if ( dir ) { 
 directStops . add ( st ) ; 
 } else { 
 reverseStops . add ( st ) ; 
 } 
 } 
 writer . writeTransportRoute ( idRoute , routeName , routeEnName , ref , operator , type , dist , directStops , reverseStops , stringTable ) ; 
 } 
 rs . close ( ) ; 
 selectTransportRouteData . close ( ) ; 
 // TODO prepare transportStopsTree ! ! ! 
 PreparedStatement selectTransportStop = mapConnection . prepareStatement ( 
 ""SELECT A.id,  A.latitude,  A.longitude, A.name, A.name_en FROM transport_stop A where A.id = ?"" ) ; 
 PreparedStatement selectTransportRouteStop = mapConnection . prepareStatement ( 
 ""SELECT S.route FROM transport_route_stop S WHERE S.stop = ? "" ) ; 
 long rootIndex = transportStopsTree . getFileHdr ( ) . getRootIndex ( ) ; 
 rtree . Node root = transportStopsTree . getReadNode ( rootIndex ) ; 
 Rect rootBounds = calcBounds ( root ) ; 
 if ( rootBounds != null ) { 
 writer . startTransportTreeElement ( rootBounds . getMinX ( ) , rootBounds . getMaxX ( ) , rootBounds . getMinY ( ) , rootBounds . getMaxY ( ) ) ; 
 writeBinaryTransportTree ( root , transportStopsTree , writer , selectTransportStop , selectTransportRouteStop ) ; 
 writer . endWriteTransportTreeElement ( ) ; 
 } 
 writer . writeTransportStringTable ( stringTable ) ; 
 writer . endWriteTransportIndex ( ) ; 
 } catch ( RTreeException e ) { 
 throw new IllegalStateException ( e ) ; 
 } 
 }  ","public void writeBinaryTransportIndex ( BinaryMapIndexWriter writer ) throws IOException , SQLException { 
 try { 
 visitedStops = null ; // allow gc to collect it 
 PreparedStatement selectTransportRouteData = mapConnection . prepareStatement ( ""SELECT * FROM "" + IndexTransportRoute . getTable ( ) ) ; 
 PreparedStatement selectTransportData = mapConnection . prepareStatement ( ""SELECT S.stop, S.direction,"" + 
 ""  A.latitude,  A.longitude, A.name, A.name_en "" + 
 ""FROM transport_route_stop S INNER JOIN transport_stop A ON A.id = S.stop WHERE S.route = ? ORDER BY S.ord asc"" ) ; 
 writer . startWriteTransportIndex ( ) ; 
 // expect that memory would be enough 
 Map < String , Integer > stringTable = createStringTableForTransport ( ) ; 
 Map < Long , Long > transportRoutes = new LinkedHashMap < Long , Long > ( ) ; 
 ResultSet rs = selectTransportRouteData . executeQuery ( ) ; 
 List < TransportStop > directStops = new ArrayList < TransportStop > ( ) ; 
 List < TransportStop > reverseStops = new ArrayList < TransportStop > ( ) ; 
 while ( rs . next ( ) ) { 
 long idRoute = rs . getLong ( IndexTransportRoute . ID . ordinal ( ) + 1 ) ; 
 int dist = rs . getInt ( IndexTransportRoute . DIST . ordinal ( ) + 1 ) ; 
 String routeName = rs . getString ( IndexTransportRoute . NAME . ordinal ( ) + 1 ) ; 
 String routeEnName = rs . getString ( IndexTransportRoute . NAME_EN . ordinal ( ) + 1 ) ; 
 if ( routeEnName != null & & routeEnName . equals ( Junidecode . unidecode ( routeName ) ) ) { 
 routeEnName = null ; 
 } 
 String ref = rs . getString ( IndexTransportRoute . REF . ordinal ( ) + 1 ) ; 
 String operator = rs . getString ( IndexTransportRoute . OPERATOR . ordinal ( ) + 1 ) ; 
 String type = rs . getString ( IndexTransportRoute . TYPE . ordinal ( ) + 1 ) ; 
 selectTransportData . setLong ( 1 , idRoute ) ; 
 ResultSet rset = selectTransportData . executeQuery ( ) ; 
 reverseStops . clear ( ) ; 
 directStops . clear ( ) ; 
 while ( rset . next ( ) ) { 
 boolean dir = rset . getInt ( 2 ) != 0 ; 
 long idStop = rset . getInt ( 1 ) ; 
 String stopName = rset . getString ( 5 ) ; 
 String stopEnName = rset . getString ( 6 ) ; 
 if ( stopEnName != null & & stopEnName . equals ( Junidecode . unidecode ( stopName ) ) ) { 
 stopEnName = null ; 
 } 
 TransportStop st = new TransportStop ( ) ; 
 st . setId ( idStop ) ; 
 st . setName ( stopName ) ; 
 st . setLocation ( rset . getDouble ( 3 ) , rset . getDouble ( 4 ) ) ; 
 if ( stopEnName != null ) { 
 st . setEnName ( stopEnName ) ; 
 } 
 if ( dir ) { 
 directStops . add ( st ) ; 
 } else { 
 reverseStops . add ( st ) ; 
 } 
 } 
 writer . writeTransportRoute ( idRoute , routeName , routeEnName , ref , operator , type , dist , directStops , reverseStops , 
 stringTable , transportRoutes ) ; 
 } 
 rs . close ( ) ; 
 selectTransportRouteData . close ( ) ; 
 PreparedStatement selectTransportStop = mapConnection . prepareStatement ( 
 ""SELECT A.id,  A.latitude,  A.longitude, A.name, A.name_en FROM transport_stop A where A.id = ?"" ) ; 
 PreparedStatement selectTransportRouteStop = mapConnection . prepareStatement ( 
 ""SELECT DISTINCT S.route FROM transport_route_stop S WHERE S.stop = ? "" ) ; 
 long rootIndex = transportStopsTree . getFileHdr ( ) . getRootIndex ( ) ; 
 rtree . Node root = transportStopsTree . getReadNode ( rootIndex ) ; 
 Rect rootBounds = calcBounds ( root ) ; 
 if ( rootBounds != null ) { 
 writer . startTransportTreeElement ( rootBounds . getMinX ( ) , rootBounds . getMaxX ( ) , rootBounds . getMinY ( ) , rootBounds . getMaxY ( ) ) ; 
 writeBinaryTransportTree ( root , transportStopsTree , writer , selectTransportStop , selectTransportRouteStop , 
 transportRoutes , stringTable ) ; 
 writer . endWriteTransportTreeElement ( ) ; 
 } 
 writer . writeTransportStringTable ( stringTable ) ; 
 writer . endWriteTransportIndex ( ) ; 
 } catch ( RTreeException e ) { 
 throw new IllegalStateException ( e ) ; 
 } 
 }  ",2010-11-05 12:11:09 +0000,2010-11-05 20:44:15 +0000,0,0.9840961054070532
2885,84,https://www.github.com/apache/openjpa,buildSequence(),,255,255,255,255,TODO: temp until a global name solution is implemented,https://www.github.com/apache/openjpa/commit/04df2fac82,https://www.github.com/apache/openjpa/commit/fadd48fe5b68577a3a75d86fb7e51746d6662c3b,openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/NativeJDBCSeq.java,"private void buildSequence() {
String seqName = Strings.getClassName(_seqName);
// JPA 2 added schema as a configurable attribute on  
// sequence generator.  OpenJPA <= 1.x allowed this via
// schema.sequence on the sequence name.  Specifying a schema
// name on the annotation or in the orm will override the old 
// behavior.
String schemaName = _schema;
if (schemaName == null || schemaName.length() == 0) {
schemaName = Strings.getPackageName(_seqName);
if (schemaName.length() == 0)
schemaName = Schemas.getNewTableSchema(_conf);
}
// build the sequence in one of the designated schemas
SchemaGroup group = new SchemaGroup();
Schema schema = group.addSchema(schemaName);
_seq = schema.addSequence(seqName);
// TODO: temp until a global name solution is implemented
schema.addDelimSequenceName(_conf.getDBDictionaryInstance().addDelimiters(seqName), _seq);
_seq.setInitialValue(_initial);
_seq.setIncrement(_increment);
_seq.setAllocate(_allocate);
}","private void buildSequence() {
QualifiedDBIdentifier path = QualifiedDBIdentifier.getPath(_seqName);
DBIdentifier seqName = path.getIdentifier();
// JPA 2 added schema as a configurable attribute on  
// sequence generator.  OpenJPA <= 1.x allowed this via
// schema.sequence on the sequence name.  Specifying a schema
// name on the annotation or in the orm will override the old 
// behavior.
DBIdentifier schemaName = _schema;
if (DBIdentifier.isEmpty(schemaName)) {
schemaName = path.getSchemaName();
if (DBIdentifier.isEmpty(schemaName))
schemaName = Schemas.getNewTableSchemaIdentifier(_conf);
}
// build the sequence in one of the designated schemas
SchemaGroup group = new SchemaGroup();
Schema schema = group.addSchema(schemaName);
_seq = schema.addSequence(seqName);
_seq.setInitialValue(_initial);
_seq.setIncrement(_increment);
_seq.setAllocate(_allocate);
}","private void buildSequence ( ) { 
 String seqName = Strings . getClassName ( _seqName ) ; 
 // JPA 2 added schema as a configurable attribute on 
 // sequence generator . OpenJPA <= 1. x allowed this via 
 // schema . sequence on the sequence name . Specifying a schema 
 // name on the annotation or in the orm will override the old 
 // behavior . 
 String schemaName = _schema ; 
 if ( schemaName == null | | schemaName . length ( ) == 0 ) { 
 schemaName = Strings . getPackageName ( _seqName ) ; 
 if ( schemaName . length ( ) == 0 ) 
 schemaName = Schemas . getNewTableSchema ( _conf ) ; 
 } 
 // build the sequence in one of the designated schemas 
 SchemaGroup group = new SchemaGroup ( ) ; 
 Schema schema = group . addSchema ( schemaName ) ; 
 _seq = schema . addSequence ( seqName ) ; 
 // TODO : temp until a global name solution is implemented 
 schema . addDelimSequenceName ( _conf . getDBDictionaryInstance ( ) . addDelimiters ( seqName ) , _seq ) ; 
 _seq . setInitialValue ( _initial ) ; 
 _seq . setIncrement ( _increment ) ; 
 _seq . setAllocate ( _allocate ) ; 
 }  ","private void buildSequence ( ) { 
 QualifiedDBIdentifier path = QualifiedDBIdentifier . getPath ( _seqName ) ; 
 DBIdentifier seqName = path . getIdentifier ( ) ; 
 // JPA 2 added schema as a configurable attribute on 
 // sequence generator . OpenJPA <= 1. x allowed this via 
 // schema . sequence on the sequence name . Specifying a schema 
 // name on the annotation or in the orm will override the old 
 // behavior . 
 DBIdentifier schemaName = _schema ; 
 if ( DBIdentifier . isEmpty ( schemaName ) ) { 
 schemaName = path . getSchemaName ( ) ; 
 if ( DBIdentifier . isEmpty ( schemaName ) ) 
 schemaName = Schemas . getNewTableSchemaIdentifier ( _conf ) ; 
 } 
 // build the sequence in one of the designated schemas 
 SchemaGroup group = new SchemaGroup ( ) ; 
 Schema schema = group . addSchema ( schemaName ) ; 
 _seq = schema . addSequence ( seqName ) ; 
 _seq . setInitialValue ( _initial ) ; 
 _seq . setIncrement ( _increment ) ; 
 _seq . setAllocate ( _allocate ) ; 
 }  ",2009-10-20 16:31:39 +0000,2010-01-15 19:38:18 +0000,0,0.8520653437182109
610,399,https://www.github.com/dropwizard/dropwizard,"run(Service, CommandLine)",,53,53,53,53,FIXME: 11/7/11 <coda> -- parameterize service,https://www.github.com/dropwizard/dropwizard/commit/d15fa5fbe6c,https://www.github.com/dropwizard/dropwizard/commit/c72ce6c2b28acd2ef982cf09108dba888c1714b5,dropwizard/src/main/java/com/yammer/dropwizard/cli/ConfiguredCommand.java,"@Override
protected final void run(Service service,
                             CommandLine params) throws Exception {
LoggingFactory.bootstrap();
final String[] args = params.getArgs();
if (args.length == 1) {
try {
// FIXME: 11/7/11 <coda> -- parameterize service
final T configuration = factory.build(new File(args[0]));
run(service, configuration, params);
} catch (ConfigurationException e) {
UsagePrinter.printCommandHelp(this, Optional.fromNullable(e.getMessage()));
}
} else {
UsagePrinter.printCommandHelp(this);
System.exit(-1);
}
}","@Override
@SuppressWarnings(""unchecked"")
protected final void run(Service<?> service,
                             CommandLine params) throws Exception {
LoggingFactory.bootstrap();
final String[] args = params.getArgs();
if (args.length == 1) {
try {
final T configuration = factory.build(new File(args[0]));
run((Service<T>) service, configuration, params);
} catch (ConfigurationException e) {
UsagePrinter.printCommandHelp(this, Optional.fromNullable(e.getMessage()));
}
} else {
UsagePrinter.printCommandHelp(this);
System.exit(-1);
}
}","@ Override 
 protected final void run ( Service service , 
 CommandLine params ) throws Exception { 
 LoggingFactory . bootstrap ( ) ; 
 final String [ ] args = params . getArgs ( ) ; 
 if ( args . length == 1 ) { 
 try { 
 // FIXME : 11 / 7 / 11 < coda > - - parameterize service 
 final T configuration = factory . build ( new File ( args [ 0 ] ) ) ; 
 run ( service , configuration , params ) ; 
 } catch ( ConfigurationException e ) { 
 UsagePrinter . printCommandHelp ( this , Optional . fromNullable ( e . getMessage ( ) ) ) ; 
 } 
 } else { 
 UsagePrinter . printCommandHelp ( this ) ; 
 System . exit ( - 1 ) ; 
 } 
 }  ","@ Override 
 @ SuppressWarnings ( ""unchecked"" ) 
 protected final void run ( Service < ? > service , 
 CommandLine params ) throws Exception { 
 LoggingFactory . bootstrap ( ) ; 
 final String [ ] args = params . getArgs ( ) ; 
 if ( args . length == 1 ) { 
 try { 
 final T configuration = factory . build ( new File ( args [ 0 ] ) ) ; 
 run ( ( Service < T > ) service , configuration , params ) ; 
 } catch ( ConfigurationException e ) { 
 UsagePrinter . printCommandHelp ( this , Optional . fromNullable ( e . getMessage ( ) ) ) ; 
 } 
 } else { 
 UsagePrinter . printCommandHelp ( this ) ; 
 System . exit ( - 1 ) ; 
 } 
 }  ",2011/11/7 18:16,2011/11/8 0:49,0,0.9235439569300501
2227,427,https://www.github.com/jbossas/console,launchNewConfigDialoge(),NOT_DESIGN,187,187,187,187,TODO: fragile (serverGroups==null),https://www.github.com/jbossas/console/commit/e9f19346f,https://www.github.com/jbossas/console/commit/35ae63dc421bb1acdb02e5c45dfb7d1e33dd8038,standalone/src/main/java/org/jboss/as/console/client/domain/hosts/ServerConfigPresenter.java,"public void launchNewConfigDialoge() {
window = new DefaultWindow(""Create Server Configuration"");
window.setWidth(320);
window.setHeight(240);
window.addCloseHandler(new CloseHandler<PopupPanel>() {
            @Override
public void onClose(CloseEvent<PopupPanel> event) {
if(selectedRecord==null)
History.back();
}
        });
window.setWidget(
                new NewServerConfigWizard(this, serverGroups).asWidget() // TODO: fragile (serverGroups==null)
        );
window.setGlassEnabled(true);
window.center();
}","public void launchNewConfigDialoge() {
window = new DefaultWindow(""Create Server Configuration"");
window.setWidth(320);
window.setHeight(240);
window.addCloseHandler(new CloseHandler<PopupPanel>() {
            @Override
public void onClose(CloseEvent<PopupPanel> event) {
if(selectedRecord==null)
History.back();
}
        });
serverGroupStore.loadServerGroups(new SimpleCallback<List<ServerGroupRecord>>() {
            @Override
public void onSuccess(List<ServerGroupRecord> result) {
serverGroups = result;
window.setWidget(
                        new NewServerConfigWizard(ServerConfigPresenter.this, serverGroups).asWidget()
                );
window.setGlassEnabled(true);
window.center();
}
        });
}","public void launchNewConfigDialoge ( ) { 
 window = new DefaultWindow ( ""Create Server Configuration"" ) ; 
 window . setWidth ( 320 ) ; 
 window . setHeight ( 240 ) ; 
 window . addCloseHandler ( new CloseHandler < PopupPanel > ( ) { 
 @ Override 
 public void onClose ( CloseEvent < PopupPanel > event ) { 
 if ( selectedRecord == null ) 
 History . back ( ) ; 
 } 
 } ) ; 
 window . setWidget ( 
 new NewServerConfigWizard ( this , serverGroups ) . asWidget ( ) // TODO : fragile ( serverGroups == null ) 
 ) ; 
 window . setGlassEnabled ( true ) ; 
 window . center ( ) ; 
 }  ","public void launchNewConfigDialoge ( ) { 
 window = new DefaultWindow ( ""Create Server Configuration"" ) ; 
 window . setWidth ( 320 ) ; 
 window . setHeight ( 240 ) ; 
 window . addCloseHandler ( new CloseHandler < PopupPanel > ( ) { 
 @ Override 
 public void onClose ( CloseEvent < PopupPanel > event ) { 
 if ( selectedRecord == null ) 
 History . back ( ) ; 
 } 
 } ) ; 
 serverGroupStore . loadServerGroups ( new SimpleCallback < List < ServerGroupRecord >> ( ) { 
 @ Override 
 public void onSuccess ( List < ServerGroupRecord > result ) { 
 serverGroups = result ; 
 window . setWidget ( 
 new NewServerConfigWizard ( ServerConfigPresenter . this , serverGroups ) . asWidget ( ) 
 ) ; 
 window . setGlassEnabled ( true ) ; 
 window . center ( ) ; 
 } 
 } ) ; 
 }  ",2011-03-28 15:26:49 +0200,2011-03-28 16:08:05 +0200,0,0.9131766045212157
1746,304,https://www.github.com/php-coder/mystamps,onApplicationEvent(DownloadingSucceeded),,81,81,81,81,TODO: replace with siteParserService.findForUrl(url) and update diagrams,https://www.github.com/php-coder/mystamps/commit/cb4cc6643f,https://www.github.com/php-coder/mystamps/commit/5f3617701fba271f0aff3b92ec53988b5e96048a,src/main/java/ru/mystamps/web/feature/series/importing/event/DownloadingSucceededEventListener.java,"@Override
public void onApplicationEvent(DownloadingSucceeded event) {
Integer requestId = event.getRequestId();
log.info(""Request #{}: downloading succeeded"", requestId);
String content = seriesImportService.getDownloadedContent(requestId);
if (content == null) {
// TODO: how to handle error? maybe publish UnexpectedErrorEvent?
log.error(""Request #{}: could not load a content from database"", requestId);
return;
}
// TODO: replace with siteParserService.findForUrl(url) and update diagrams
String url = event.getUrl();
SiteParser parser = null;
for (SiteParser candidate : siteParsers) {
if (candidate.canParse(url)) {
parser = candidate;
break;
}
}
if (parser == null) {
// TODO: how to handle error? maybe publish UnexpectedErrorEvent?
log.error(""Request #{}: could not find appropriate parser"", requestId);
return;
}
SeriesInfo info = parser.parse(content);
if (info.isEmpty()) {
eventPublisher.publishEvent(new ParsingFailed(this, requestId));
return;
}
RawParsedDataDto data = new RawParsedDataDto(
			info.getCategoryName(),
			info.getCountryName(),
			info.getImageUrl(),
			info.getIssueDate(),
			info.getQuantity(),
			info.getPerforated(),
			info.getMichelNumbers(),
			info.getSellerName(),
			info.getSellerUrl(),
			info.getPrice(),
			info.getCurrency()
		);
seriesImportService.saveParsedData(requestId, data);
}","@Override
public void onApplicationEvent(DownloadingSucceeded event) {
Integer requestId = event.getRequestId();
log.info(""Request #{}: downloading succeeded"", requestId);
SiteParser parser = siteParserService.findForUrl(event.getUrl());
if (parser == null) {
// TODO: how to handle error? maybe publish UnexpectedErrorEvent?
log.error(""Request #{}: could not find appropriate parser"", requestId);
return;
}
String content = seriesImportService.getDownloadedContent(requestId);
if (content == null) {
// TODO: how to handle error? maybe publish UnexpectedErrorEvent?
log.error(""Request #{}: could not load a content from database"", requestId);
return;
}
SeriesInfo info = parser.parse(content);
if (info.isEmpty()) {
eventPublisher.publishEvent(new ParsingFailed(this, requestId));
return;
}
RawParsedDataDto data = new RawParsedDataDto(
			info.getCategoryName(),
			info.getCountryName(),
			info.getImageUrl(),
			info.getIssueDate(),
			info.getQuantity(),
			info.getPerforated(),
			info.getMichelNumbers(),
			info.getSellerName(),
			info.getSellerUrl(),
			info.getPrice(),
			info.getCurrency()
		);
seriesImportService.saveParsedData(requestId, data);
}","@ Override 
 public void onApplicationEvent ( DownloadingSucceeded event ) { 
 Integer requestId = event . getRequestId ( ) ; 
 log . info ( ""Request #{}: downloading succeeded"" , requestId ) ; 
 String content = seriesImportService . getDownloadedContent ( requestId ) ; 
 if ( content == null ) { 
 // TODO : how to handle error ? maybe publish UnexpectedErrorEvent ? 
 log . error ( ""Request #{}: could not load a content from database"" , requestId ) ; 
 return ; 
 } 
 // TODO : replace with siteParserService . findForUrl ( url ) and update diagrams 
 String url = event . getUrl ( ) ; 
 SiteParser parser = null ; 
 for ( SiteParser candidate : siteParsers ) { 
 if ( candidate . canParse ( url ) ) { 
 parser = candidate ; 
 break ; 
 } 
 } 
 if ( parser == null ) { 
 // TODO : how to handle error ? maybe publish UnexpectedErrorEvent ? 
 log . error ( ""Request #{}: could not find appropriate parser"" , requestId ) ; 
 return ; 
 } 
 SeriesInfo info = parser . parse ( content ) ; 
 if ( info . isEmpty ( ) ) { 
 eventPublisher . publishEvent ( new ParsingFailed ( this , requestId ) ) ; 
 return ; 
 } 
 RawParsedDataDto data = new RawParsedDataDto ( 
 info . getCategoryName ( ) , 
 info . getCountryName ( ) , 
 info . getImageUrl ( ) , 
 info . getIssueDate ( ) , 
 info . getQuantity ( ) , 
 info . getPerforated ( ) , 
 info . getMichelNumbers ( ) , 
 info . getSellerName ( ) , 
 info . getSellerUrl ( ) , 
 info . getPrice ( ) , 
 info . getCurrency ( ) 
 ) ; 
 seriesImportService . saveParsedData ( requestId , data ) ; 
 }  ","@ Override 
 public void onApplicationEvent ( DownloadingSucceeded event ) { 
 Integer requestId = event . getRequestId ( ) ; 
 log . info ( ""Request #{}: downloading succeeded"" , requestId ) ; 
 SiteParser parser = siteParserService . findForUrl ( event . getUrl ( ) ) ; 
 if ( parser == null ) { 
 // TODO : how to handle error ? maybe publish UnexpectedErrorEvent ? 
 log . error ( ""Request #{}: could not find appropriate parser"" , requestId ) ; 
 return ; 
 } 
 String content = seriesImportService . getDownloadedContent ( requestId ) ; 
 if ( content == null ) { 
 // TODO : how to handle error ? maybe publish UnexpectedErrorEvent ? 
 log . error ( ""Request #{}: could not load a content from database"" , requestId ) ; 
 return ; 
 } 
 SeriesInfo info = parser . parse ( content ) ; 
 if ( info . isEmpty ( ) ) { 
 eventPublisher . publishEvent ( new ParsingFailed ( this , requestId ) ) ; 
 return ; 
 } 
 RawParsedDataDto data = new RawParsedDataDto ( 
 info . getCategoryName ( ) , 
 info . getCountryName ( ) , 
 info . getImageUrl ( ) , 
 info . getIssueDate ( ) , 
 info . getQuantity ( ) , 
 info . getPerforated ( ) , 
 info . getMichelNumbers ( ) , 
 info . getSellerName ( ) , 
 info . getSellerUrl ( ) , 
 info . getPrice ( ) , 
 info . getCurrency ( ) 
 ) ; 
 seriesImportService . saveParsedData ( requestId , data ) ; 
 }  ",2018-12-15 17:44:23 +0000,2018-12-15 21:12:33 +0000,0,0.9459900529687904
2416,66,https://www.github.com/apache/wicket,setRecreateChoices(boolean),,78,78,78,78,FIXME Unknown: Unknown,https://www.github.com/apache/wicket/commit/56fe177eaa8,https://www.github.com/apache/wicket/commit/7b4992255329d6699317d75b6e604343412d1b5d,wicket-extensions/src/java/wicket/extensions/markup/html/form/select/SelectOptions.java,"protected void onBeginRequest()
{
if (size() == 0 || recreateChoices)
{
// populate this repeating view with SelectOption components
removeAll();
Object modelObject = getModelObject();
if (modelObject != null)
{
if (!(modelObject instanceof Collection))
{
// FIXME Unknown: Unknown
throw new WicketRuntimeException(""Model not a collection"");
}
// iterator over model objects for SelectOption components
Iterator it = ((Collection)modelObject).iterator();
while (it.hasNext())
{
// we need a container to represent a row in repeater
WebMarkupContainer row = new WebMarkupContainer(newChildId());
row.setRenderBodyOnly(true);
add(row);
// we add our actual SelectOption component to the row
Object value = it.next();
String text = renderer.getDisplayValue(value);
IModel model = renderer.getModel(value);
row.add(new SimpleSelectOption(""option"", model, text));
}
}
}
}","protected void onBeginRequest()
{
if (size() == 0 || recreateChoices)
{
// populate this repeating view with SelectOption components
removeAll();
Object modelObject = getModelObject();
if (modelObject != null)
{
if (!(modelObject instanceof Collection))
{
throw new WicketRuntimeException(""Model object "" + modelObject + "" not a collection"");
}
// iterator over model objects for SelectOption components
Iterator it = ((Collection)modelObject).iterator();
while (it.hasNext())
{
// we need a container to represent a row in repeater
WebMarkupContainer row = new WebMarkupContainer(newChildId());
row.setRenderBodyOnly(true);
add(row);
// we add our actual SelectOption component to the row
Object value = it.next();
String text = renderer.getDisplayValue(value);
IModel model = renderer.getModel(value);
row.add(new SimpleSelectOption(""option"", model, text));
}
}
}
}","protected void onBeginRequest ( ) 
 { 
 if ( size ( ) == 0 | | recreateChoices ) 
 { 
 // populate this repeating view with SelectOption components 
 removeAll ( ) ; 
 Object modelObject = getModelObject ( ) ; 
 if ( modelObject != null ) 
 { 
 if ( ! ( modelObject instanceof Collection ) ) 
 { 
 // FIXME Unknown : Unknown 
 throw new WicketRuntimeException ( ""Model not a collection"" ) ; 
 } 
 // iterator over model objects for SelectOption components 
 Iterator it = ( ( Collection ) modelObject ) . iterator ( ) ; 
 while ( it . hasNext ( ) ) 
 { 
 // we need a container to represent a row in repeater 
 WebMarkupContainer row = new WebMarkupContainer ( newChildId ( ) ) ; 
 row . setRenderBodyOnly ( true ) ; 
 add ( row ) ; 
 // we add our actual SelectOption component to the row 
 Object value = it . next ( ) ; 
 String text = renderer . getDisplayValue ( value ) ; 
 IModel model = renderer . getModel ( value ) ; 
 row . add ( new SimpleSelectOption ( ""option"" , model , text ) ) ; 
 } 
 } 
 } 
 }  ","protected void onBeginRequest ( ) 
 { 
 if ( size ( ) == 0 | | recreateChoices ) 
 { 
 // populate this repeating view with SelectOption components 
 removeAll ( ) ; 
 Object modelObject = getModelObject ( ) ; 
 if ( modelObject != null ) 
 { 
 if ( ! ( modelObject instanceof Collection ) ) 
 { 
 throw new WicketRuntimeException ( ""Model object "" + modelObject + "" not a collection"" ) ; 
 } 
 // iterator over model objects for SelectOption components 
 Iterator it = ( ( Collection ) modelObject ) . iterator ( ) ; 
 while ( it . hasNext ( ) ) 
 { 
 // we need a container to represent a row in repeater 
 WebMarkupContainer row = new WebMarkupContainer ( newChildId ( ) ) ; 
 row . setRenderBodyOnly ( true ) ; 
 add ( row ) ; 
 // we add our actual SelectOption component to the row 
 Object value = it . next ( ) ; 
 String text = renderer . getDisplayValue ( value ) ; 
 IModel model = renderer . getModel ( value ) ; 
 row . add ( new SimpleSelectOption ( ""option"" , model , text ) ) ; 
 } 
 } 
 } 
 }  ",2006-01-17 20:35:38 +0000,2006-02-08 18:57:38 +0000,0,0.9863989200758656
520,245,https://www.github.com/cyanogenmod/android_packages_inputmethods_latinime,hashCode(),,1342,1342,1342,1342,TODO: Will call InputConnection.commitCorrection() here.,https://www.github.com/cyanogenmod/android_packages_inputmethods_latinime/commit/55b9d333c5,https://www.github.com/cyanogenmod/android_packages_inputmethods_latinime/commit/4ca16dbd65150359c3884da7cb59a30f19abd4b7,java/src/com/android/inputmethod/latin/LatinIME.java,"private void handleSeparator(int primaryCode) {
mVoiceConnector.handleSeparator();
// Should dismiss the ""Touch again to save"" message when handling separator
if (mCandidateView != null && mCandidateView.dismissAddToDictionaryHint()) {
mHandler.postUpdateSuggestions();
}
boolean pickedDefault = false;
// Handle separator
final InputConnection ic = getCurrentInputConnection();
if (ic != null) {
ic.beginBatchEdit();
abortCorrection(false);
}
if (mPredicting) {
// In certain languages where single quote is a separator, it's better
// not to auto correct, but accept the typed word. For instance,
// in Italian dov' should not be expanded to dove' because the elision
// requires the last vowel to be removed.
if (mAutoCorrectOn && primaryCode != '\'' && !mJustReverted) {
pickedDefault = pickDefaultSuggestion();
// Picked the suggestion by the space key.  We consider this
// as ""added an auto space"".
if (primaryCode == Keyboard.CODE_SPACE) {
mJustAddedAutoSpace = true;
}
} else {
commitTyped(ic);
}
}
if (mJustAddedAutoSpace && primaryCode == Keyboard.CODE_ENTER) {
removeTrailingSpace();
mJustAddedAutoSpace = false;
}
sendKeyChar((char)primaryCode);
// Handle the case of "". ."" -> "" .."" with auto-space if necessary
// before changing the TextEntryState.
if (TextEntryState.getState() == TextEntryState.State.PUNCTUATION_AFTER_ACCEPTED
&& primaryCode == Keyboard.CODE_PERIOD) {
reswapPeriodAndSpace();
}
TextEntryState.typedCharacter((char) primaryCode, true);
if (TextEntryState.getState() == TextEntryState.State.PUNCTUATION_AFTER_ACCEPTED
&& primaryCode != Keyboard.CODE_ENTER) {
swapPunctuationAndSpace();
} else if (isPredictionOn() && primaryCode == Keyboard.CODE_SPACE) {
doubleSpace();
}
if (pickedDefault) {
CharSequence typedWord = mWord.getTypedWord();
TextEntryState.backToAcceptedDefault(typedWord);
if (!TextUtils.isEmpty(typedWord) && !typedWord.equals(mBestWord)) {
// TODO: Will call InputConnection.commitCorrection() here.
if (mCandidateView != null)
mCandidateView.onAutoCorrectionInverted(mBestWord);
}
setPunctuationSuggestions();
}
mKeyboardSwitcher.updateShiftState();
if (ic != null) {
ic.endBatchEdit();
}
}","private void handleSeparator(int primaryCode) {
mVoiceConnector.handleSeparator();
// Should dismiss the ""Touch again to save"" message when handling separator
if (mCandidateView != null && mCandidateView.dismissAddToDictionaryHint()) {
mHandler.postUpdateSuggestions();
}
boolean pickedDefault = false;
// Handle separator
final InputConnection ic = getCurrentInputConnection();
if (ic != null) {
ic.beginBatchEdit();
abortCorrection(false);
}
if (mPredicting) {
// In certain languages where single quote is a separator, it's better
// not to auto correct, but accept the typed word. For instance,
// in Italian dov' should not be expanded to dove' because the elision
// requires the last vowel to be removed.
if (mAutoCorrectOn && primaryCode != '\'' && !mJustReverted) {
pickedDefault = pickDefaultSuggestion();
// Picked the suggestion by the space key.  We consider this
// as ""added an auto space"".
if (primaryCode == Keyboard.CODE_SPACE) {
mJustAddedAutoSpace = true;
}
} else {
commitTyped(ic);
}
}
if (mJustAddedAutoSpace && primaryCode == Keyboard.CODE_ENTER) {
removeTrailingSpace();
mJustAddedAutoSpace = false;
}
sendKeyChar((char)primaryCode);
// Handle the case of "". ."" -> "" .."" with auto-space if necessary
// before changing the TextEntryState.
if (TextEntryState.getState() == TextEntryState.State.PUNCTUATION_AFTER_ACCEPTED
&& primaryCode == Keyboard.CODE_PERIOD) {
reswapPeriodAndSpace();
}
TextEntryState.typedCharacter((char) primaryCode, true);
if (TextEntryState.getState() == TextEntryState.State.PUNCTUATION_AFTER_ACCEPTED
&& primaryCode != Keyboard.CODE_ENTER) {
swapPunctuationAndSpace();
} else if (isPredictionOn() && primaryCode == Keyboard.CODE_SPACE) {
doubleSpace();
}
if (pickedDefault) {
CharSequence typedWord = mWord.getTypedWord();
TextEntryState.backToAcceptedDefault(typedWord);
if (!TextUtils.isEmpty(typedWord) && !typedWord.equals(mBestWord)) {
if (ic != null) {
CorrectionInfo correctionInfo = new CorrectionInfo(
                            mLastSelectionEnd - typedWord.length(), typedWord, mBestWord);
ic.commitCorrection(correctionInfo);
}
if (mCandidateView != null)
mCandidateView.onAutoCorrectionInverted(mBestWord);
}
setPunctuationSuggestions();
}
mKeyboardSwitcher.updateShiftState();
if (ic != null) {
ic.endBatchEdit();
}
}","private void handleSeparator ( int primaryCode ) { 
 mVoiceConnector . handleSeparator ( ) ; 
 // Should dismiss the ""Touch again to save"" message when handling separator 
 if ( mCandidateView != null & & mCandidateView . dismissAddToDictionaryHint ( ) ) { 
 mHandler . postUpdateSuggestions ( ) ; 
 } 
 boolean pickedDefault = false ; 
 // Handle separator 
 final InputConnection ic = getCurrentInputConnection ( ) ; 
 if ( ic != null ) { 
 ic . beginBatchEdit ( ) ; 
 abortCorrection ( false ) ; 
 } 
 if ( mPredicting ) { 
 // In certain languages where single quote is a separator , it ' s better 
 // not to auto correct , but accept the typed word . For instance , 
 // in Italian dov ' should not be expanded to dove' because the elision 
 // requires the last vowel to be removed . 
 if ( mAutoCorrectOn & & primaryCode != '\'' & &   ! mJustReverted ) { 
 pickedDefault = pickDefaultSuggestion ( ) ; 
 // Picked the suggestion by the space key . We consider this 
 // as ""added an auto space"" . 
 if ( primaryCode == Keyboard . CODE_SPACE ) { 
 mJustAddedAutoSpace = true ; 
 } 
 } else { 
 commitTyped ( ic ) ; 
 } 
 } 
 if ( mJustAddedAutoSpace & & primaryCode == Keyboard . CODE_ENTER ) { 
 removeTrailingSpace ( ) ; 
 mJustAddedAutoSpace = false ; 
 } 
 sendKeyChar ( ( char ) primaryCode ) ; 
 // Handle the case of "". ."" -> "" .."" with auto - space if necessary 
 // before changing the TextEntryState . 
 if ( TextEntryState . getState ( ) == TextEntryState . State . PUNCTUATION_AFTER_ACCEPTED 
 & & primaryCode == Keyboard . CODE_PERIOD ) { 
 reswapPeriodAndSpace ( ) ; 
 } 
 TextEntryState . typedCharacter ( ( char ) primaryCode , true ) ; 
 if ( TextEntryState . getState ( ) == TextEntryState . State . PUNCTUATION_AFTER_ACCEPTED 
 & & primaryCode != Keyboard . CODE_ENTER ) { 
 swapPunctuationAndSpace ( ) ; 
 } else if ( isPredictionOn ( ) & & primaryCode == Keyboard . CODE_SPACE ) { 
 doubleSpace ( ) ; 
 } 
 if ( pickedDefault ) { 
 CharSequence typedWord = mWord . getTypedWord ( ) ; 
 TextEntryState . backToAcceptedDefault ( typedWord ) ; 
 if ( ! TextUtils . isEmpty ( typedWord ) & &   ! typedWord . equals ( mBestWord ) ) { 
 // TODO : Will call InputConnection . commitCorrection ( ) here . 
 if ( mCandidateView != null ) 
 mCandidateView . onAutoCorrectionInverted ( mBestWord ) ; 
 } 
 setPunctuationSuggestions ( ) ; 
 } 
 mKeyboardSwitcher . updateShiftState ( ) ; 
 if ( ic != null ) { 
 ic . endBatchEdit ( ) ; 
 } 
 }  ","private void handleSeparator ( int primaryCode ) { 
 mVoiceConnector . handleSeparator ( ) ; 
 // Should dismiss the ""Touch again to save"" message when handling separator 
 if ( mCandidateView != null & & mCandidateView . dismissAddToDictionaryHint ( ) ) { 
 mHandler . postUpdateSuggestions ( ) ; 
 } 
 boolean pickedDefault = false ; 
 // Handle separator 
 final InputConnection ic = getCurrentInputConnection ( ) ; 
 if ( ic != null ) { 
 ic . beginBatchEdit ( ) ; 
 abortCorrection ( false ) ; 
 } 
 if ( mPredicting ) { 
 // In certain languages where single quote is a separator , it ' s better 
 // not to auto correct , but accept the typed word . For instance , 
 // in Italian dov ' should not be expanded to dove' because the elision 
 // requires the last vowel to be removed . 
 if ( mAutoCorrectOn & & primaryCode != '\'' & &   ! mJustReverted ) { 
 pickedDefault = pickDefaultSuggestion ( ) ; 
 // Picked the suggestion by the space key . We consider this 
 // as ""added an auto space"" . 
 if ( primaryCode == Keyboard . CODE_SPACE ) { 
 mJustAddedAutoSpace = true ; 
 } 
 } else { 
 commitTyped ( ic ) ; 
 } 
 } 
 if ( mJustAddedAutoSpace & & primaryCode == Keyboard . CODE_ENTER ) { 
 removeTrailingSpace ( ) ; 
 mJustAddedAutoSpace = false ; 
 } 
 sendKeyChar ( ( char ) primaryCode ) ; 
 // Handle the case of "". ."" -> "" .."" with auto - space if necessary 
 // before changing the TextEntryState . 
 if ( TextEntryState . getState ( ) == TextEntryState . State . PUNCTUATION_AFTER_ACCEPTED 
 & & primaryCode == Keyboard . CODE_PERIOD ) { 
 reswapPeriodAndSpace ( ) ; 
 } 
 TextEntryState . typedCharacter ( ( char ) primaryCode , true ) ; 
 if ( TextEntryState . getState ( ) == TextEntryState . State . PUNCTUATION_AFTER_ACCEPTED 
 & & primaryCode != Keyboard . CODE_ENTER ) { 
 swapPunctuationAndSpace ( ) ; 
 } else if ( isPredictionOn ( ) & & primaryCode == Keyboard . CODE_SPACE ) { 
 doubleSpace ( ) ; 
 } 
 if ( pickedDefault ) { 
 CharSequence typedWord = mWord . getTypedWord ( ) ; 
 TextEntryState . backToAcceptedDefault ( typedWord ) ; 
 if ( ! TextUtils . isEmpty ( typedWord ) & &   ! typedWord . equals ( mBestWord ) ) { 
 if ( ic != null ) { 
 CorrectionInfo correctionInfo = new CorrectionInfo ( 
 mLastSelectionEnd - typedWord . length ( ) , typedWord , mBestWord ) ; 
 ic . commitCorrection ( correctionInfo ) ; 
 } 
 if ( mCandidateView != null ) 
 mCandidateView . onAutoCorrectionInverted ( mBestWord ) ; 
 } 
 setPunctuationSuggestions ( ) ; 
 } 
 mKeyboardSwitcher . updateShiftState ( ) ; 
 if ( ic != null ) { 
 ic . endBatchEdit ( ) ; 
 } 
 }  ",2010-12-09 20:37:07 +0900,2010-12-12 22:23:39 +0900,0,0.9667856559107263
3665,5,https://www.github.com/junit-team/junit4,run(EachTestNotifier),DESIGN,37,37,37,37,"TODO: (Oct 5, 2007 11:27:11 AM) Now what?  Is there a useful thing to do with this?",https://www.github.com/junit-team/junit4/commit/b333208cc,https://www.github.com/junit-team/junit4/commit/f0ef837a40922ac08c608661385abf71732975d3,src/org/junit/internal/runners/links/WithTimeout.java,"@Override
public void run(final EachTestNotifier context) throws Throwable {
ExecutorService service= Executors.newSingleThreadExecutor();
Callable<Object> callable= new Callable<Object>() {
			public Object call() throws Exception {
try {
fNext.run(context);
} catch (Exception e) {
throw e;
} catch (Error e) {
throw e;
} catch (Throwable e) {
// TODO: (Oct 5, 2007 11:27:11 AM) Now what?  Is there a useful thing to do with this?
}
return null;
}
		};
Future<Object> result= service.submit(callable);
service.shutdown();
try {
boolean terminated= service.awaitTermination(fTimeout,
					TimeUnit.MILLISECONDS);
if (!terminated)
service.shutdownNow();
result.get(0, TimeUnit.MILLISECONDS); // throws the exception if one occurred during the invocation
} catch (TimeoutException e) {
throw new Exception(String.format(
					""test timed out after %d milliseconds"", fTimeout));
} catch (ExecutionException e) {
throw e.getCause();
}
}","@Override
public void run(final FailureListener listener) {
ExecutorService service= Executors.newSingleThreadExecutor();
Callable<Object> callable= new Callable<Object>() {
			public Object call() throws Exception {
fNext.run(listener);
return null;
}
		};
Future<Object> result= service.submit(callable);
service.shutdown();
try {
boolean terminated= service.awaitTermination(fTimeout,
					TimeUnit.MILLISECONDS);
if (!terminated)
service.shutdownNow();
result.get(0, TimeUnit.MILLISECONDS); // throws the exception if one occurred during the invocation
} catch (TimeoutException e) {
listener.addFailure(new Exception(String.format(
					""test timed out after %d milliseconds"", fTimeout)));
} catch (ExecutionException e) {
listener.addFailure(e.getCause());
} catch (InterruptedException e) {
listener.addFailure(e);
}
}","@ Override 
 public void run ( final EachTestNotifier context ) throws Throwable { 
 ExecutorService service = Executors . newSingleThreadExecutor ( ) ; 
 Callable < Object > callable = new Callable < Object > ( ) { 
 public Object call ( ) throws Exception { 
 try { 
 fNext . run ( context ) ; 
 } catch ( Exception e ) { 
 throw e ; 
 } catch ( Error e ) { 
 throw e ; 
 } catch ( Throwable e ) { 
 // TODO : ( Oct 5 , 2007 11 : 27 : 11 AM ) Now what ? Is there a useful thing to do with this ? 
 } 
 return null ; 
 } 
 } ; 
 Future < Object > result = service . submit ( callable ) ; 
 service . shutdown ( ) ; 
 try { 
 boolean terminated = service . awaitTermination ( fTimeout , 
 TimeUnit . MILLISECONDS ) ; 
 if ( ! terminated ) 
 service . shutdownNow ( ) ; 
 result . get ( 0 , TimeUnit . MILLISECONDS ) ; // throws the exception if one occurred during the invocation 
 } catch ( TimeoutException e ) { 
 throw new Exception ( String . format ( 
 ""test timed out after %d milliseconds"" , fTimeout ) ) ; 
 } catch ( ExecutionException e ) { 
 throw e . getCause ( ) ; 
 } 
 }  ","@ Override 
 public void run ( final FailureListener listener ) { 
 ExecutorService service = Executors . newSingleThreadExecutor ( ) ; 
 Callable < Object > callable = new Callable < Object > ( ) { 
 public Object call ( ) throws Exception { 
 fNext . run ( listener ) ; 
 return null ; 
 } 
 } ; 
 Future < Object > result = service . submit ( callable ) ; 
 service . shutdown ( ) ; 
 try { 
 boolean terminated = service . awaitTermination ( fTimeout , 
 TimeUnit . MILLISECONDS ) ; 
 if ( ! terminated ) 
 service . shutdownNow ( ) ; 
 result . get ( 0 , TimeUnit . MILLISECONDS ) ; // throws the exception if one occurred during the invocation 
 } catch ( TimeoutException e ) { 
 listener . addFailure ( new Exception ( String . format ( 
 ""test timed out after %d milliseconds"" , fTimeout ) ) ) ; 
 } catch ( ExecutionException e ) { 
 listener . addFailure ( e . getCause ( ) ) ; 
 } catch ( InterruptedException e ) { 
 listener . addFailure ( e ) ; 
 } 
 }  ",2007-10-09 18:20:39 +0000,2007-10-10 15:57:15 +0000,0,0.7127050130682779
302,152,https://www.github.com/jclouds/legacy-jclouds,testGetScreenTicket(),,685,685,801,801,TODO how to check?,https://www.github.com/jclouds/legacy-jclouds/commit/7c80f7a9898,https://www.github.com/jclouds/legacy-jclouds/commit/78b5a16e29e21b53ac1792af49d4e8c33d384c9f,labs/vcloud-director/src/test/java/org/jclouds/vcloud/director/v1_5/features/VAppClientLiveTest.java,"@Test(testName = ""GET /vApp/{id}/screen/action/acquireTicket"", dependsOnMethods = { ""testGetVApp"" })
public void testGetScreenTicket() {
// The method under test
byte[] image = vAppClient.getScreenImage(vApp.getHref());
// TODO how to check?
}","@Test(testName = ""GET /vApp/{id}/screen/action/acquireTicket"", dependsOnMethods = { ""testGetVApp"" })
public void testGetScreenTicket() {
// The method under test
ScreenTicket ticket = vAppClient.getScreenTicket(vApp.getHref());
// Check the retrieved object is well formed
checkScreenTicket(ticket);
}","@ Test ( testName = ""GET /vApp/{id}/screen/action/acquireTicket"" , dependsOnMethods = { ""testGetVApp"" } ) 
 public void testGetScreenTicket ( ) { 
 // The method under test 
 byte [ ] image = vAppClient . getScreenImage ( vApp . getHref ( ) ) ; 
 // TODO how to check ? 
 }  ","@ Test ( testName = ""GET /vApp/{id}/screen/action/acquireTicket"" , dependsOnMethods = { ""testGetVApp"" } ) 
 public void testGetScreenTicket ( ) { 
 // The method under test 
 ScreenTicket ticket = vAppClient . getScreenTicket ( vApp . getHref ( ) ) ; 
 // Check the retrieved object is well formed 
 checkScreenTicket ( ticket ) ; 
 }  ",2012-03-14 16:02:35 +0000,2012-03-16 10:38:49 +0000,0,0.6900040247567283
257,800,https://www.github.com/apavlo/h-store,"procedureInvocation(byte[], RpcCallback<byte[]>)",,535,535,543,543,"TODO: If the dest_partition isn't local, then we need to ship it off to the right location",https://www.github.com/apavlo/h-store/commit/8ee2a445f2,https://www.github.com/apavlo/h-store/commit/a43ad6ad8429281dd87c7ac1ba734aead2b1902c,src/frontend/edu/mit/hstore/HStoreSite.java,"@Override
public void procedureInvocation(byte[] serializedRequest, RpcCallback<byte[]> done) {
if (this.status_monitor != null && !this.status_monitor.isAlive()) this.status_monitor.start();
// The serializedRequest is a ProcedureInvocation object
StoredProcedureInvocation request = null;
FastDeserializer fds = new FastDeserializer(serializedRequest);
try {
request = fds.readObject(StoredProcedureInvocation.class);
} catch (IOException e) {
e.printStackTrace();
throw new RuntimeException(e);
}
if (request == null) {
throw new RuntimeException(""Failed to get ProcedureInvocation object from request bytes"");
}
// Extract the stuff we need to figure out whether this guy belongs at our site
long client_handle = request.getClientHandle();
request.buildParameterSet();
assert(request.getParams() != null) : ""The parameters object is null for new txn from client #"" + client_handle;
Object args[] = request.getParams().toArray();
// LOG.info(""Parameter Size = "" + request.getParameters())
Procedure catalog_proc = this.catalog_db.getProcedures().get(request.getProcName());
final boolean sysproc = catalog_proc.getSystemproc();
if (catalog_proc == null) throw new RuntimeException(""Unknown procedure '"" + request.getProcName() + ""'"");
if (debug.get()) LOG.trace(""Received new stored procedure invocation request for "" + catalog_proc);
// First figure out where this sucker needs to go
Integer dest_partition;
// If it's a sysproc, then it doesn't need to go to a specific partition
if (sysproc) {
// Just pick the first one for now
dest_partition = CollectionUtil.getFirst(this.executors.keySet());
// HACK: Check if we should shutdown. This allows us to kill things even if the
// DTXN coordinator is stuck.
if (catalog_proc.getName().equals(""@Shutdown"")) {
this.shutdownCluster(); // Non-blocking...
ClientResponseImpl cresponse = new ClientResponseImpl(1, ClientResponse.SUCCESS, new VoltTable[0], """");
FastSerializer out = new FastSerializer();
try {
out.writeObject(cresponse);
} catch (IOException e) {
throw new RuntimeException(e);
}
//                done.run(out.getBytes());
return;
}
// Otherwise we use the PartitionEstimator to know where it is going
} else {
try {
dest_partition = this.p_estimator.getBasePartition(catalog_proc, args);
} catch (Exception ex) {
throw new RuntimeException(ex);
}
}
// assert(dest_partition >= 0);
if (trace.get()) {
LOG.trace(""Client Handle = "" + client_handle);
LOG.trace(""Destination Partition = "" + dest_partition);
}
// TODO: If the dest_partition isn't local, then we need to ship it off to the right location
if (this.executors.containsKey(dest_partition) == false) {
if (debug.get()) LOG.debug(""StoredProcedureInvocation request for "" + catalog_proc + "" needs to be forwarded to Partition #"" + dest_partition);
// Make a wrapper for the original callback so that when the result comes back frm the remote partition
// we will just forward it back to the client. How sweet is that??
ForwardTxnRequestCallback callback = new ForwardTxnRequestCallback(done);
this.messenger.forwardTransaction(serializedRequest, callback, dest_partition);
return;
}
// IMPORTANT: We have two txn ids here. We have the real one that we're going to use internally
// and the fake one that we pass to Evan. We don't care about the fake one and will always ignore the
// txn ids found in any Dtxn.Coordinator messages. 
long real_txn_id = this.txnid_manager.getNextUniqueTransactionId();
long dtxn_txn_id = real_txn_id; // this.dtxn_txn_id_counter.getAndIncrement();
// Grab the TransactionEstimator for the destination partition and figure out whether
// this mofo is likely to be single-partition or not. Anything that we can't estimate
// will just have to be multi-partitioned. This includes sysprocs
ExecutionSite executor = this.executors.get(dest_partition);
TransactionEstimator t_estimator = executor.getTransactionEstimator();
Boolean single_partition = null;
if (sysproc) {
single_partition = false;
} else if (!t_estimator.canEstimate(catalog_proc)) {
single_partition = false;
} else {
if (trace.get()) LOG.trace(""Using TransactionEstimator to check whether txn #"" + real_txn_id + "" is single-partition"");
TransactionEstimator.Estimate estimate = t_estimator.startTransaction(real_txn_id, catalog_proc, args);
single_partition = estimate.isSinglePartition(this.thresholds);
}
assert (single_partition != null);
//LOG.debug(""Single-Partition = "" + single_partition);
InitiateTaskMessage wrapper = new InitiateTaskMessage(real_txn_id, dest_partition, dest_partition, client_handle, request);
if (single_partition) this.singlepart_ctr.incrementAndGet();
else this.multipart_ctr.incrementAndGet();
this.inflight_txns.put(real_txn_id, dest_partition);
if (debug.get()) LOG.debug(""Passing "" + catalog_proc.getName() + "" to Coordinator as "" + (single_partition ? ""single"" : ""multi"") + ""-partition txn #"" + real_txn_id + "" for partition "" + dest_partition);
// Construct the message for the Dtxn.Coordinator
ProtoRpcController rpc = new ProtoRpcController();
Dtxn.CoordinatorFragment.Builder requestBuilder = Dtxn.CoordinatorFragment.newBuilder();
// Note that we pass the fake txn id to the Dtxn.Coordinator. 
requestBuilder.setTransactionId(dtxn_txn_id);
// FIXME: Need to use TransactionEstimator to determine this
requestBuilder.setLastFragment(true);
// NOTE: Evan betrayed our love so we can't use his txn ids because they are meaningless to us
// So we're going to pack in our txn id in the payload. Any message they we get from Evan
// will have this payload so that we can figure out what the hell is going on...
requestBuilder.setPayload(HStoreSite.encodeTxnId(real_txn_id));
// Pack the StoredProcedureInvocation into a Dtxn.PartitionFragment
requestBuilder.addFragment(Dtxn.CoordinatorFragment.PartitionFragment.newBuilder()
.setPartitionId(dest_partition)
// TODO: Use copyFrom(ByteBuffer) in the newer version of protobuf
.setWork(ByteString.copyFrom(wrapper.getBufferForMessaging(this.buffer_pool).b.array())))
.setLastFragment(single_partition);
// Create a latch so that we don't start executing until we know the coordinator confirmed are initialization request
CountDownLatch latch = new CountDownLatch(1);
InitiateCallback callback = new InitiateCallback(this, real_txn_id, latch);
this.client_callbacks.put(real_txn_id, done);
this.init_latches.put(real_txn_id, latch);
if (trace.get()) LOG.trace(""Passing "" + catalog_proc.getName() + "" through Dtxn.Coordinator using "" + callback.getClass().getSimpleName() + "" "" +
""[real_txn_id="" + real_txn_id + "", dtxn_txn_id="" + dtxn_txn_id + ""]"");
//        assert(requestBuilder.getTransactionId() != callback.getTransactionId());
this.coordinator.execute(rpc, requestBuilder.build(), callback);
}","@Override
public void procedureInvocation(byte[] serializedRequest, RpcCallback<byte[]> done) {
if (this.status_monitor != null && !this.status_monitor.isAlive()) this.status_monitor.start();
// The serializedRequest is a ProcedureInvocation object
StoredProcedureInvocation request = null;
FastDeserializer fds = new FastDeserializer(serializedRequest);
try {
request = fds.readObject(StoredProcedureInvocation.class);
} catch (IOException e) {
e.printStackTrace();
throw new RuntimeException(e);
}
if (request == null) {
throw new RuntimeException(""Failed to get ProcedureInvocation object from request bytes"");
}
// Extract the stuff we need to figure out whether this guy belongs at our site
request.buildParameterSet();
assert(request.getParams() != null) : ""The parameters object is null for new txn from client #"" + request.getClientHandle();
Object args[] = request.getParams().toArray();
// LOG.info(""Parameter Size = "" + request.getParameters())
Procedure catalog_proc = this.catalog_db.getProcedures().get(request.getProcName());
final boolean sysproc = catalog_proc.getSystemproc();
if (catalog_proc == null) throw new RuntimeException(""Unknown procedure '"" + request.getProcName() + ""'"");
if (debug.get()) LOG.trace(""Received new stored procedure invocation request for "" + catalog_proc);
// First figure out where this sucker needs to go
Integer dest_partition;
// If it's a sysproc, then it doesn't need to go to a specific partition
if (sysproc) {
// Just pick the first one for now
dest_partition = CollectionUtil.getFirst(this.executors.keySet());
// HACK: Check if we should shutdown. This allows us to kill things even if the
// DTXN coordinator is stuck.
if (catalog_proc.getName().equals(""@Shutdown"")) {
this.shutdownCluster(); // Non-blocking...
ClientResponseImpl cresponse = new ClientResponseImpl(1, ClientResponse.SUCCESS, new VoltTable[0], """");
FastSerializer out = new FastSerializer();
try {
out.writeObject(cresponse);
} catch (IOException e) {
throw new RuntimeException(e);
}
//                done.run(out.getBytes());
return;
}
// Otherwise we use the PartitionEstimator to know where it is going
} else {
try {
dest_partition = this.p_estimator.getBasePartition(catalog_proc, args);
} catch (Exception ex) {
throw new RuntimeException(ex);
}
}
// assert(dest_partition >= 0);
if (trace.get()) {
LOG.trace(""Client Handle = "" + request.getClientHandle());
LOG.trace(""Destination Partition = "" + dest_partition);
}
// If the dest_partition isn't local, then we need to ship it off to the right location
if (this.executors.containsKey(dest_partition) == false) {
if (debug.get()) LOG.debug(""StoredProcedureInvocation request for "" + catalog_proc + "" needs to be forwarded to Partition #"" + dest_partition);
// Make a wrapper for the original callback so that when the result comes back frm the remote partition
// we will just forward it back to the client. How sweet is that??
ForwardTxnRequestCallback callback = new ForwardTxnRequestCallback(done);
this.messenger.forwardTransaction(serializedRequest, callback, dest_partition);
return;
}
// IMPORTANT: We have two txn ids here. We have the real one that we're going to use internally
// and the fake one that we pass to Evan. We don't care about the fake one and will always ignore the
// txn ids found in any Dtxn.Coordinator messages. 
long txn_id = this.txnid_manager.getNextUniqueTransactionId();
// Grab the TransactionEstimator for the destination partition and figure out whether
// this mofo is likely to be single-partition or not. Anything that we can't estimate
// will just have to be multi-partitioned. This includes sysprocs
ExecutionSite executor = this.executors.get(dest_partition);
TransactionEstimator t_estimator = executor.getTransactionEstimator();
Boolean single_partition = null;
if (sysproc) {
single_partition = false;
} else if (!t_estimator.canEstimate(catalog_proc)) {
single_partition = false;
} else {
if (trace.get()) LOG.trace(""Using TransactionEstimator to check whether txn #"" + txn_id + "" is single-partition"");
TransactionEstimator.Estimate estimate = t_estimator.startTransaction(txn_id, catalog_proc, args);
single_partition = estimate.isSinglePartition(this.thresholds);
}
assert (single_partition != null);
if (single_partition) this.singlepart_ctr.incrementAndGet();
else this.multipart_ctr.incrementAndGet();
this.initializeInvocation(txn_id, dest_partition, single_partition, request, done);
//LOG.debug(""Single-Partition = "" + single_partition);
}","@ Override 
 public void procedureInvocation ( byte [ ] serializedRequest , RpcCallback < byte [ ] > done ) { 
 if ( this . status_monitor != null & &   ! this . status_monitor . isAlive ( ) ) this . status_monitor . start ( ) ; 
 // The serializedRequest is a ProcedureInvocation object 
 StoredProcedureInvocation request = null ; 
 FastDeserializer fds = new FastDeserializer ( serializedRequest ) ; 
 try { 
 request = fds . readObject ( StoredProcedureInvocation . class ) ; 
 } catch ( IOException e ) { 
 e . printStackTrace ( ) ; 
 throw new RuntimeException ( e ) ; 
 } 
 if ( request == null ) { 
 throw new RuntimeException ( ""Failed to get ProcedureInvocation object from request bytes"" ) ; 
 } 
 // Extract the stuff we need to figure out whether this guy belongs at our site 
 long client_handle = request . getClientHandle ( ) ; 
 request . buildParameterSet ( ) ; 
 assert ( request . getParams ( ) != null ) : ""The parameters object is null for new txn from client #"" + client_handle ; 
 Object args [ ] = request . getParams ( ) . toArray ( ) ; 
 // LOG . info ( ""Parameter Size = "" + request . getParameters ( ) ) 
 Procedure catalog_proc = this . catalog_db . getProcedures ( ) . get ( request . getProcName ( ) ) ; 
 final boolean sysproc = catalog_proc . getSystemproc ( ) ; 
 if ( catalog_proc == null ) throw new RuntimeException ( ""Unknown procedure '"" + request . getProcName ( ) + ""'"" ) ; 
 if ( debug . get ( ) ) LOG . trace ( ""Received new stored procedure invocation request for "" + catalog_proc ) ; 
 // First figure out where this sucker needs to go 
 Integer dest_partition ; 
 // If it 's a sysproc, then it doesn' t need to go to a specific partition 
 if ( sysproc ) { 
 // Just pick the first one for now 
 dest_partition = CollectionUtil . getFirst ( this . executors . keySet ( ) ) ; 
 // HACK : Check if we should shutdown . This allows us to kill things even if the 
 // DTXN coordinator is stuck . 
 if ( catalog_proc . getName ( ) . equals ( ""@Shutdown"" ) ) { 
 this . shutdownCluster ( ) ; // Non - blocking ... 
 ClientResponseImpl cresponse = new ClientResponseImpl ( 1 , ClientResponse . SUCCESS , new VoltTable [ 0 ] , """" ) ; 
 FastSerializer out = new FastSerializer ( ) ; 
 try { 
 out . writeObject ( cresponse ) ; 
 } catch ( IOException e ) { 
 throw new RuntimeException ( e ) ; 
 } 
 // done . run ( out . getBytes ( ) ) ; 
 return ; 
 } 
 // Otherwise we use the PartitionEstimator to know where it is going 
 } else { 
 try { 
 dest_partition = this . p_estimator . getBasePartition ( catalog_proc , args ) ; 
 } catch ( Exception ex ) { 
 throw new RuntimeException ( ex ) ; 
 } 
 } 
 // assert ( dest_partition >= 0 ) ; 
 if ( trace . get ( ) ) { 
 LOG . trace ( ""Client Handle = "" + client_handle ) ; 
 LOG . trace ( ""Destination Partition = "" + dest_partition ) ; 
 } 
 // TODO : If the dest_partition isn ' t local , then we need to ship it off to the right location 
 if ( this . executors . containsKey ( dest_partition ) == false ) { 
 if ( debug . get ( ) ) LOG . debug ( ""StoredProcedureInvocation request for "" + catalog_proc + "" needs to be forwarded to Partition #"" + dest_partition ) ; 
 // Make a wrapper for the original callback so that when the result comes back frm the remote partition 
 // we will just forward it back to the client . How sweet is that ? ? 
 ForwardTxnRequestCallback callback = new ForwardTxnRequestCallback ( done ) ; 
 this . messenger . forwardTransaction ( serializedRequest , callback , dest_partition ) ; 
 return ; 
 } 
 // IMPORTANT : We have two txn ids here . We have the real one that we ' re going to use internally 
 // and the fake one that we pass to Evan . We don ' t care about the fake one and will always ignore the 
 // txn ids found in any Dtxn . Coordinator messages . 
 long real_txn_id = this . txnid_manager . getNextUniqueTransactionId ( ) ; 
 long dtxn_txn_id = real_txn_id ; // this . dtxn_txn_id_counter . getAndIncrement ( ) ; 
 // Grab the TransactionEstimator for the destination partition and figure out whether 
 // this mofo is likely to be single - partition or not . Anything that we can ' t estimate 
 // will just have to be multi - partitioned . This includes sysprocs 
 ExecutionSite executor = this . executors . get ( dest_partition ) ; 
 TransactionEstimator t_estimator = executor . getTransactionEstimator ( ) ; 
 Boolean single_partition = null ; 
 if ( sysproc ) { 
 single_partition = false ; 
 } else if ( ! t_estimator . canEstimate ( catalog_proc ) ) { 
 single_partition = false ; 
 } else { 
 if ( trace . get ( ) ) LOG . trace ( ""Using TransactionEstimator to check whether txn #"" + real_txn_id + "" is single-partition"" ) ; 
 TransactionEstimator . Estimate estimate = t_estimator . startTransaction ( real_txn_id , catalog_proc , args ) ; 
 single_partition = estimate . isSinglePartition ( this . thresholds ) ; 
 } 
 assert ( single_partition != null ) ; 
 // LOG . debug ( ""Single-Partition = "" + single_partition ) ; 
 InitiateTaskMessage wrapper = new InitiateTaskMessage ( real_txn_id , dest_partition , dest_partition , client_handle , request ) ; 
 if ( single_partition ) this . singlepart_ctr . incrementAndGet ( ) ; 
 else this . multipart_ctr . incrementAndGet ( ) ; 
 this . inflight_txns . put ( real_txn_id , dest_partition ) ; 
 if ( debug . get ( ) ) LOG . debug ( ""Passing "" + catalog_proc . getName ( ) + "" to Coordinator as "" + ( single_partition   ? ""single"" : ""multi"" ) + ""-partition txn #"" + real_txn_id + "" for partition "" + dest_partition ) ; 
 // Construct the message for the Dtxn . Coordinator 
 ProtoRpcController rpc = new ProtoRpcController ( ) ; 
 Dtxn . CoordinatorFragment . Builder requestBuilder = Dtxn . CoordinatorFragment . newBuilder ( ) ; 
 // Note that we pass the fake txn id to the Dtxn . Coordinator . 
 requestBuilder . setTransactionId ( dtxn_txn_id ) ; 
 // FIXME : Need to use TransactionEstimator to determine this 
 requestBuilder . setLastFragment ( true ) ; 
 // NOTE : Evan betrayed our love so we can ' t use his txn ids because they are meaningless to us 
 // So we ' re going to pack in our txn id in the payload . Any message they we get from Evan 
 // will have this payload so that we can figure out what the hell is going on ... 
 requestBuilder . setPayload ( HStoreSite . encodeTxnId ( real_txn_id ) ) ; 
 // Pack the StoredProcedureInvocation into a Dtxn . PartitionFragment 
 requestBuilder . addFragment ( Dtxn . CoordinatorFragment . PartitionFragment . newBuilder ( ) 
 . setPartitionId ( dest_partition ) 
 // TODO : Use copyFrom ( ByteBuffer ) in the newer version of protobuf 
 . setWork ( ByteString . copyFrom ( wrapper . getBufferForMessaging ( this . buffer_pool ) . b . array ( ) ) ) ) 
 . setLastFragment ( single_partition ) ; 
 // Create a latch so that we don ' t start executing until we know the coordinator confirmed are initialization request 
 CountDownLatch latch = new CountDownLatch ( 1 ) ; 
 InitiateCallback callback = new InitiateCallback ( this , real_txn_id , latch ) ; 
 this . client_callbacks . put ( real_txn_id , done ) ; 
 this . init_latches . put ( real_txn_id , latch ) ; 
 if ( trace . get ( ) ) LOG . trace ( ""Passing "" + catalog_proc . getName ( ) + "" through Dtxn.Coordinator using "" + callback . getClass ( ) . getSimpleName ( ) + "" "" + 
 ""[real_txn_id="" + real_txn_id + "", dtxn_txn_id="" + dtxn_txn_id + ""]"" ) ; 
 // assert ( requestBuilder . getTransactionId ( ) != callback . getTransactionId ( ) ) ; 
 this . coordinator . execute ( rpc , requestBuilder . build ( ) , callback ) ; 
 }  ","@ Override 
 public void procedureInvocation ( byte [ ] serializedRequest , RpcCallback < byte [ ] > done ) { 
 if ( this . status_monitor != null & &   ! this . status_monitor . isAlive ( ) ) this . status_monitor . start ( ) ; 
 // The serializedRequest is a ProcedureInvocation object 
 StoredProcedureInvocation request = null ; 
 FastDeserializer fds = new FastDeserializer ( serializedRequest ) ; 
 try { 
 request = fds . readObject ( StoredProcedureInvocation . class ) ; 
 } catch ( IOException e ) { 
 e . printStackTrace ( ) ; 
 throw new RuntimeException ( e ) ; 
 } 
 if ( request == null ) { 
 throw new RuntimeException ( ""Failed to get ProcedureInvocation object from request bytes"" ) ; 
 } 
 // Extract the stuff we need to figure out whether this guy belongs at our site 
 request . buildParameterSet ( ) ; 
 assert ( request . getParams ( ) != null ) : ""The parameters object is null for new txn from client #"" + request . getClientHandle ( ) ; 
 Object args [ ] = request . getParams ( ) . toArray ( ) ; 
 // LOG . info ( ""Parameter Size = "" + request . getParameters ( ) ) 
 Procedure catalog_proc = this . catalog_db . getProcedures ( ) . get ( request . getProcName ( ) ) ; 
 final boolean sysproc = catalog_proc . getSystemproc ( ) ; 
 if ( catalog_proc == null ) throw new RuntimeException ( ""Unknown procedure '"" + request . getProcName ( ) + ""'"" ) ; 
 if ( debug . get ( ) ) LOG . trace ( ""Received new stored procedure invocation request for "" + catalog_proc ) ; 
 // First figure out where this sucker needs to go 
 Integer dest_partition ; 
 // If it 's a sysproc, then it doesn' t need to go to a specific partition 
 if ( sysproc ) { 
 // Just pick the first one for now 
 dest_partition = CollectionUtil . getFirst ( this . executors . keySet ( ) ) ; 
 // HACK : Check if we should shutdown . This allows us to kill things even if the 
 // DTXN coordinator is stuck . 
 if ( catalog_proc . getName ( ) . equals ( ""@Shutdown"" ) ) { 
 this . shutdownCluster ( ) ; // Non - blocking ... 
 ClientResponseImpl cresponse = new ClientResponseImpl ( 1 , ClientResponse . SUCCESS , new VoltTable [ 0 ] , """" ) ; 
 FastSerializer out = new FastSerializer ( ) ; 
 try { 
 out . writeObject ( cresponse ) ; 
 } catch ( IOException e ) { 
 throw new RuntimeException ( e ) ; 
 } 
 // done . run ( out . getBytes ( ) ) ; 
 return ; 
 } 
 // Otherwise we use the PartitionEstimator to know where it is going 
 } else { 
 try { 
 dest_partition = this . p_estimator . getBasePartition ( catalog_proc , args ) ; 
 } catch ( Exception ex ) { 
 throw new RuntimeException ( ex ) ; 
 } 
 } 
 // assert ( dest_partition >= 0 ) ; 
 if ( trace . get ( ) ) { 
 LOG . trace ( ""Client Handle = "" + request . getClientHandle ( ) ) ; 
 LOG . trace ( ""Destination Partition = "" + dest_partition ) ; 
 } 
 // If the dest_partition isn ' t local , then we need to ship it off to the right location 
 if ( this . executors . containsKey ( dest_partition ) == false ) { 
 if ( debug . get ( ) ) LOG . debug ( ""StoredProcedureInvocation request for "" + catalog_proc + "" needs to be forwarded to Partition #"" + dest_partition ) ; 
 // Make a wrapper for the original callback so that when the result comes back frm the remote partition 
 // we will just forward it back to the client . How sweet is that ? ? 
 ForwardTxnRequestCallback callback = new ForwardTxnRequestCallback ( done ) ; 
 this . messenger . forwardTransaction ( serializedRequest , callback , dest_partition ) ; 
 return ; 
 } 
 // IMPORTANT : We have two txn ids here . We have the real one that we ' re going to use internally 
 // and the fake one that we pass to Evan . We don ' t care about the fake one and will always ignore the 
 // txn ids found in any Dtxn . Coordinator messages . 
 long txn_id = this . txnid_manager . getNextUniqueTransactionId ( ) ; 
 // Grab the TransactionEstimator for the destination partition and figure out whether 
 // this mofo is likely to be single - partition or not . Anything that we can ' t estimate 
 // will just have to be multi - partitioned . This includes sysprocs 
 ExecutionSite executor = this . executors . get ( dest_partition ) ; 
 TransactionEstimator t_estimator = executor . getTransactionEstimator ( ) ; 
 Boolean single_partition = null ; 
 if ( sysproc ) { 
 single_partition = false ; 
 } else if ( ! t_estimator . canEstimate ( catalog_proc ) ) { 
 single_partition = false ; 
 } else { 
 if ( trace . get ( ) ) LOG . trace ( ""Using TransactionEstimator to check whether txn #"" + txn_id + "" is single-partition"" ) ; 
 TransactionEstimator . Estimate estimate = t_estimator . startTransaction ( txn_id , catalog_proc , args ) ; 
 single_partition = estimate . isSinglePartition ( this . thresholds ) ; 
 } 
 assert ( single_partition != null ) ; 
 if ( single_partition ) this . singlepart_ctr . incrementAndGet ( ) ; 
 else this . multipart_ctr . incrementAndGet ( ) ; 
 this . initializeInvocation ( txn_id , dest_partition , single_partition , request , done ) ; 
 // LOG . debug ( ""Single-Partition = "" + single_partition ) ; 
 }  ",2010-10-07 17:00:06 +0000,2011-01-24 00:55:25 +0000,0,0.8663931617960994
0,201,https://www.github.com/jenkinsci/gerrit-trigger-plugin,start(),NOT_DESIGN,248,248,248,248,TODO fix ignoreEmail,https://www.github.com/jenkinsci/gerrit-trigger-plugin/commit/7b52ff8e3,https://www.github.com/jenkinsci/gerrit-trigger-plugin/commit/b7611bbfdeee6d1ece88b24aec43d07bccd2e48e,gerrithudsontrigger/src/main/java/com/sonyericsson/hudson/plugins/gerrit/trigger/PluginImpl.java,"@Override
public void start() throws Exception {
logger.info(""Starting Gerrit-Trigger Plugin"");
doXStreamRegistrations();
logger.trace(""Loading configs"");
load();
GerritSendCommandQueue.initialize(pluginConfig);
//TODO fix ignoreEmail
gerritEventManager = new GerritHandler(pluginConfig.getNumberOfReceivingWorkerThreads(), null);
for (GerritServer s : servers) {
s.start();
}
}","@Override
public void start() throws Exception {
logger.info(""Starting Gerrit-Trigger Plugin"");
doXStreamRegistrations();
logger.trace(""Loading configs"");
load();
GerritSendCommandQueue.initialize(pluginConfig);
gerritEventManager = new GerritHandler(pluginConfig.getNumberOfReceivingWorkerThreads());
for (GerritServer s : servers) {
s.start();
}
}","@ Override 
 public void start ( ) throws Exception { 
 logger . info ( ""Starting Gerrit-Trigger Plugin"" ) ; 
 doXStreamRegistrations ( ) ; 
 logger . trace ( ""Loading configs"" ) ; 
 load ( ) ; 
 GerritSendCommandQueue . initialize ( pluginConfig ) ; 
 // TODO fix ignoreEmail 
 gerritEventManager = new GerritHandler ( pluginConfig . getNumberOfReceivingWorkerThreads ( ) , null ) ; 
 for ( GerritServer s : servers ) { 
 s . start ( ) ; 
 } 
 }  ","@ Override 
 public void start ( ) throws Exception { 
 logger . info ( ""Starting Gerrit-Trigger Plugin"" ) ; 
 doXStreamRegistrations ( ) ; 
 logger . trace ( ""Loading configs"" ) ; 
 load ( ) ; 
 GerritSendCommandQueue . initialize ( pluginConfig ) ; 
 gerritEventManager = new GerritHandler ( pluginConfig . getNumberOfReceivingWorkerThreads ( ) ) ; 
 for ( GerritServer s : servers ) { 
 s . start ( ) ; 
 } 
 }  ",2013-11-14 18:46:25 +0100,2013-11-19 18:35:05 +0900,0,0.9595387662245549
2599,156,https://www.github.com/felixb/websms,"onReceive(Context, Intent)",NOT_DESIGN,140,140,146,146,TODO: send back broadcast to WebSMS,https://www.github.com/felixb/websms/commit/d0f89e357,https://www.github.com/felixb/websms/commit/fc34c9ff2dc80f9ee59dd29e5f204545d2479cd3,src/de/ub0r/android/websms/connector/sms/CommandReceiverSMS.java,"@Override
public final void onReceive(final Context context, final Intent intent) {
final String action = intent.getAction();
Log.d(TAG, ""action: "" + action);
if (action == null) {
return;
}
if (Constants.ACTION_CONNECTOR_UPDATE.equals(action)) {
final ConnectorSpec specs = CommandReceiverSMS.getSpecs(context);
final Intent i = new Intent(Constants.ACTION_CONNECTOR_INFO);
i.putExtra(Constants.EXTRAS_CONNECTOR, specs.getBundle());
Log.d(TAG, ""send broadcast: "" + i.getAction());
context.sendBroadcast(i);
} else if (Constants.ACTION_CONNECTOR_RUN.equals(action)) {
final Bundle extras = intent.getExtras();
if (extras != null) {
final ConnectorCommand command = new ConnectorCommand(extras
.getBundle(Constants.EXTRAS_COMMAND));
if (command.getType() == ConnectorCommand.TYPE_SEND) {
final ConnectorSpec specs = CommandReceiverSMS
.getSpecs(context);
if (specs.hasStatus(ConnectorSpec.STATUS_READY)) {
// check internal status
try {
this.send(command);
} catch (WebSMSException e) {
// TODO Auto-generated catch block
Log.e(TAG, null, e);
} finally {
// TODO: send back broadcast to WebSMS
}
}
}
}
}
}","@Override
public final void onReceive(final Context context, final Intent intent) {
final String action = intent.getAction();
Log.d(TAG, ""action: "" + action);
if (action == null) {
return;
}
if (Constants.ACTION_CONNECTOR_UPDATE.equals(action)) {
this.sendInfo(context, null);
} else if (Constants.ACTION_CONNECTOR_RUN.equals(action)) {
final ConnectorCommand command = new ConnectorCommand(intent);
if (command.getType() == ConnectorCommand.TYPE_SEND) {
final ConnectorSpec specs = CommandReceiverSMS
.getSpecs(context);
if (specs.hasStatus(ConnectorSpec.STATUS_READY)) {
// check internal status
try {
this.send(command);
} catch (WebSMSException e) {
Log.e(TAG, null, e);
Toast.makeText(context,
								specs.getName() + "": "" + e.getMessage(),
								Toast.LENGTH_LONG).show();
} finally {
this.sendInfo(context, specs);
}
}
}
}
}","@ Override 
 public final void onReceive ( final Context context , final Intent intent ) { 
 final String action = intent . getAction ( ) ; 
 Log . d ( TAG , ""action: "" + action ) ; 
 if ( action == null ) { 
 return ; 
 } 
 if ( Constants . ACTION_CONNECTOR_UPDATE . equals ( action ) ) { 
 final ConnectorSpec specs = CommandReceiverSMS . getSpecs ( context ) ; 
 final Intent i = new Intent ( Constants . ACTION_CONNECTOR_INFO ) ; 
 i . putExtra ( Constants . EXTRAS_CONNECTOR , specs . getBundle ( ) ) ; 
 Log . d ( TAG , ""send broadcast: "" + i . getAction ( ) ) ; 
 context . sendBroadcast ( i ) ; 
 } else if ( Constants . ACTION_CONNECTOR_RUN . equals ( action ) ) { 
 final Bundle extras = intent . getExtras ( ) ; 
 if ( extras != null ) { 
 final ConnectorCommand command = new ConnectorCommand ( extras 
 . getBundle ( Constants . EXTRAS_COMMAND ) ) ; 
 if ( command . getType ( ) == ConnectorCommand . TYPE_SEND ) { 
 final ConnectorSpec specs = CommandReceiverSMS 
 . getSpecs ( context ) ; 
 if ( specs . hasStatus ( ConnectorSpec . STATUS_READY ) ) { 
 // check internal status 
 try { 
 this . send ( command ) ; 
 } catch ( WebSMSException e ) { 
 // TODO Auto - generated catch block 
 Log . e ( TAG , null , e ) ; 
 } finally { 
 // TODO : send back broadcast to WebSMS 
 } 
 } 
 } 
 } 
 } 
 }  ","@ Override 
 public final void onReceive ( final Context context , final Intent intent ) { 
 final String action = intent . getAction ( ) ; 
 Log . d ( TAG , ""action: "" + action ) ; 
 if ( action == null ) { 
 return ; 
 } 
 if ( Constants . ACTION_CONNECTOR_UPDATE . equals ( action ) ) { 
 this . sendInfo ( context , null ) ; 
 } else if ( Constants . ACTION_CONNECTOR_RUN . equals ( action ) ) { 
 final ConnectorCommand command = new ConnectorCommand ( intent ) ; 
 if ( command . getType ( ) == ConnectorCommand . TYPE_SEND ) { 
 final ConnectorSpec specs = CommandReceiverSMS 
 . getSpecs ( context ) ; 
 if ( specs . hasStatus ( ConnectorSpec . STATUS_READY ) ) { 
 // check internal status 
 try { 
 this . send ( command ) ; 
 } catch ( WebSMSException e ) { 
 Log . e ( TAG , null , e ) ; 
 Toast . makeText ( context , 
 specs . getName ( ) + "": "" + e . getMessage ( ) , 
 Toast . LENGTH_LONG ) . show ( ) ; 
 } finally { 
 this . sendInfo ( context , specs ) ; 
 } 
 } 
 } 
 } 
 }  ",2010-01-16 09:11:04 +0100,2010-01-16 15:45:05 +0100,0,0.831177198860527
1265,198,https://www.github.com/tesla/m2e-core-tests,createContentSection(SashForm),NOT_DESIGN,181,181,181,181,XXX implement actions,https://www.github.com/tesla/m2e-core-tests/commit/0d8af9c9a,https://www.github.com/tesla/m2e-core-tests/commit/906fa26a6665d08391f63bdb3f8fa788d52532d4,org.maven.ide.eclipse.editor/src/org/maven/ide/eclipse/editor/composites/ReportingComposite.java,"private void createContentSection(SashForm horizontalSash) {
Composite composite_1 = toolkit.createComposite(horizontalSash, SWT.NONE);
GridLayout gridLayout = new GridLayout();
gridLayout.marginWidth = 0;
gridLayout.marginHeight = 0;
composite_1.setLayout(gridLayout);
toolkit.paintBordersFor(composite_1);
Section contentSection = toolkit.createSection(composite_1, Section.TITLE_BAR);
contentSection.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, false));
contentSection.setText(""Content"");
Composite composite = toolkit.createComposite(contentSection, SWT.NONE);
composite.setLayout(new GridLayout(2, false));
contentSection.setClient(composite);
toolkit.paintBordersFor(composite);
toolkit.createLabel(composite, ""Output Folder:"", SWT.NONE);
outputFolderText = toolkit.createText(composite, null, SWT.NONE);
outputFolderText.setLayoutData(new GridData(SWT.FILL, SWT.CENTER, true, false));
excludeDefaultsButton = toolkit.createButton(composite, ""Exclude Defaults"", SWT.CHECK);
excludeDefaultsButton.setLayoutData(new GridData(SWT.RIGHT, SWT.CENTER, false, false, 2, 1));
Section reportingPluginsSection = toolkit.createSection(composite_1, Section.TITLE_BAR);
reportingPluginsSection.setLayoutData(new GridData(SWT.FILL, SWT.FILL, false, true));
reportingPluginsSection.setText(""Reporting Plugins"");
reportPluginsEditor = new ListEditorComposite<ReportPlugin>(reportingPluginsSection, SWT.NONE);
reportingPluginsSection.setClient(reportPluginsEditor);
toolkit.paintBordersFor(reportPluginsEditor);
toolkit.adapt(reportPluginsEditor);
reportPluginsEditor.setContentProvider(new ListEditorContentProvider<ReportPlugin>());
reportPluginsEditor.setLabelProvider(new LabelProvider() {
      public String getText(Object element) {
if(element instanceof ReportPlugin) {
ReportPlugin reportPlugin = (ReportPlugin) element;
String groupId = reportPlugin.getGroupId();
String artifactId = reportPlugin.getArtifactId();
String version = reportPlugin.getVersion();
String label = groupId==null ? ""[unknown]"" : groupId;
label += "" : "" + (artifactId==null ? ""[unknown]"" : artifactId);
if(version!=null) {
label += "" : "" + version;
}
return label;
}
return super.getText(element);
}
public Image getImage(Object element) {
return MavenEditorImages.IMG_PLUGIN;
}
    });
reportPluginsEditor.addSelectionListener(new ISelectionChangedListener() {
      public void selectionChanged(SelectionChangedEvent event) {
List<ReportPlugin> selection = reportPluginsEditor.getSelection();
updateReportPluginDetails(selection.size()==1 ? selection.get(0) : null);
}
    });
// XXX implement actions
}","private void createContentSection(SashForm horizontalSash) {
Composite composite_1 = toolkit.createComposite(horizontalSash, SWT.NONE);
GridLayout gridLayout = new GridLayout();
gridLayout.marginWidth = 0;
gridLayout.marginHeight = 0;
composite_1.setLayout(gridLayout);
toolkit.paintBordersFor(composite_1);
Section contentSection = toolkit.createSection(composite_1, Section.TITLE_BAR);
contentSection.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, false));
contentSection.setText(""Content"");
Composite composite = toolkit.createComposite(contentSection, SWT.NONE);
composite.setLayout(new GridLayout(2, false));
contentSection.setClient(composite);
toolkit.paintBordersFor(composite);
toolkit.createLabel(composite, ""Output Folder:"", SWT.NONE);
outputFolderText = toolkit.createText(composite, null, SWT.NONE);
outputFolderText.setLayoutData(new GridData(SWT.FILL, SWT.CENTER, true, false));
excludeDefaultsButton = toolkit.createButton(composite, ""Exclude Defaults"", SWT.CHECK);
excludeDefaultsButton.setLayoutData(new GridData(SWT.RIGHT, SWT.CENTER, false, false, 2, 1));
Section reportingPluginsSection = toolkit.createSection(composite_1, Section.TITLE_BAR);
reportingPluginsSection.setLayoutData(new GridData(SWT.FILL, SWT.FILL, false, true));
reportingPluginsSection.setText(""Reporting Plugins"");
reportPluginsEditor = new ListEditorComposite<ReportPlugin>(reportingPluginsSection, SWT.NONE);
reportingPluginsSection.setClient(reportPluginsEditor);
toolkit.paintBordersFor(reportPluginsEditor);
toolkit.adapt(reportPluginsEditor);
reportPluginsEditor.setContentProvider(new ListEditorContentProvider<ReportPlugin>());
reportPluginsEditor.setLabelProvider(new LabelProvider() {
      public String getText(Object element) {
if(element instanceof ReportPlugin) {
ReportPlugin reportPlugin = (ReportPlugin) element;
String groupId = reportPlugin.getGroupId();
String artifactId = reportPlugin.getArtifactId();
String version = reportPlugin.getVersion();
String label = groupId == null ? ""[unknown]"" : groupId;
label += "" : "" + (artifactId == null ? ""[unknown]"" : artifactId);
if(version != null) {
label += "" : "" + version;
}
return label;
}
return super.getText(element);
}
public Image getImage(Object element) {
return MavenEditorImages.IMG_PLUGIN;
}
    });
reportPluginsEditor.addSelectionListener(new ISelectionChangedListener() {
      public void selectionChanged(SelectionChangedEvent event) {
List<ReportPlugin> selection = reportPluginsEditor.getSelection();
updateReportPluginDetails(selection.size() == 1 ? selection.get(0) : null);
}
    });
reportPluginsEditor.setAddListener(new SelectionAdapter() {
      public void widgetSelected(SelectionEvent e) {
CompoundCommand compoundCommand = new CompoundCommand();
EditingDomain editingDomain = parent.getEditingDomain();
boolean reportsCreated = false;
Model model = parent.getModel();
Reporting reporting = model.getReporting();
if(reporting == null) {
reporting = PomFactory.eINSTANCE.createReporting();
Command addReporting = SetCommand.create(editingDomain, model, POM_PACKAGE.getModel_Reporting(), reporting);
compoundCommand.append(addReporting);
reportsCreated = true;
}
ReportPlugins reportPlugins = reporting.getPlugins();
if(reportPlugins == null) {
reportPlugins = PomFactory.eINSTANCE.createReportPlugins();
Command addReportPlugins = SetCommand.create(editingDomain, reporting, POM_PACKAGE.getReporting_Plugins(),
              reportPlugins);
compoundCommand.append(addReportPlugins);
reportsCreated = true;
}
ReportPlugin reportPlugin = PomFactory.eINSTANCE.createReportPlugin();
Command addReportPlugin = AddCommand.create(editingDomain, reportPlugins,
            POM_PACKAGE.getReportPlugins_Plugin(), reportPlugin);
compoundCommand.append(addReportPlugin);
editingDomain.getCommandStack().execute(compoundCommand);
if(reportsCreated) {
updateContent(reporting);
} else {
updateReportPluginDetails(reportPlugin);
}
reportPluginsEditor.setSelection(Collections.singletonList(reportPlugin));
groupIdText.setFocus();
}
    });
reportPluginsEditor.setRemoveListener(new SelectionAdapter() {
      public void widgetSelected(SelectionEvent e) {
CompoundCommand compoundCommand = new CompoundCommand();
EditingDomain editingDomain = parent.getEditingDomain();
Model model = parent.getModel();
Reporting reporting = model.getReporting();
ReportPlugins reportPlugins = reporting == null ? null : reporting.getPlugins();
if(reportPlugins != null) {
List<ReportPlugin> pluginList = reportPluginsEditor.getSelection();
for(ReportPlugin reportPlugin : pluginList) {
Command removeCommand = RemoveCommand.create(editingDomain, reportPlugins, POM_PACKAGE.getPlugins_Plugin(),
                reportPlugin);
compoundCommand.append(removeCommand);
}
editingDomain.getCommandStack().execute(compoundCommand);
updateContent(reporting);
}
}
    });
}","private void createContentSection ( SashForm horizontalSash ) { 
 Composite composite_1 = toolkit . createComposite ( horizontalSash , SWT . NONE ) ; 
 GridLayout gridLayout = new GridLayout ( ) ; 
 gridLayout . marginWidth = 0 ; 
 gridLayout . marginHeight = 0 ; 
 composite_1 . setLayout ( gridLayout ) ; 
 toolkit . paintBordersFor ( composite_1 ) ; 
 Section contentSection = toolkit . createSection ( composite_1 , Section . TITLE_BAR ) ; 
 contentSection . setLayoutData ( new GridData ( SWT . FILL , SWT . FILL , true , false ) ) ; 
 contentSection . setText ( ""Content"" ) ; 
 Composite composite = toolkit . createComposite ( contentSection , SWT . NONE ) ; 
 composite . setLayout ( new GridLayout ( 2 , false ) ) ; 
 contentSection . setClient ( composite ) ; 
 toolkit . paintBordersFor ( composite ) ; 
 toolkit . createLabel ( composite , ""Output Folder:"" , SWT . NONE ) ; 
 outputFolderText = toolkit . createText ( composite , null , SWT . NONE ) ; 
 outputFolderText . setLayoutData ( new GridData ( SWT . FILL , SWT . CENTER , true , false ) ) ; 
 excludeDefaultsButton = toolkit . createButton ( composite , ""Exclude Defaults"" , SWT . CHECK ) ; 
 excludeDefaultsButton . setLayoutData ( new GridData ( SWT . RIGHT , SWT . CENTER , false , false , 2 , 1 ) ) ; 
 Section reportingPluginsSection = toolkit . createSection ( composite_1 , Section . TITLE_BAR ) ; 
 reportingPluginsSection . setLayoutData ( new GridData ( SWT . FILL , SWT . FILL , false , true ) ) ; 
 reportingPluginsSection . setText ( ""Reporting Plugins"" ) ; 
 reportPluginsEditor = new ListEditorComposite < ReportPlugin > ( reportingPluginsSection , SWT . NONE ) ; 
 reportingPluginsSection . setClient ( reportPluginsEditor ) ; 
 toolkit . paintBordersFor ( reportPluginsEditor ) ; 
 toolkit . adapt ( reportPluginsEditor ) ; 
 reportPluginsEditor . setContentProvider ( new ListEditorContentProvider < ReportPlugin > ( ) ) ; 
 reportPluginsEditor . setLabelProvider ( new LabelProvider ( ) { 
 public String getText ( Object element ) { 
 if ( element instanceof ReportPlugin ) { 
 ReportPlugin reportPlugin = ( ReportPlugin ) element ; 
 String groupId = reportPlugin . getGroupId ( ) ; 
 String artifactId = reportPlugin . getArtifactId ( ) ; 
 String version = reportPlugin . getVersion ( ) ; 
 String label = groupId == null   ? ""[unknown]"" : groupId ; 
 label += "" : "" + ( artifactId == null   ? ""[unknown]"" : artifactId ) ; 
 if ( version != null ) { 
 label += "" : "" + version ; 
 } 
 return label ; 
 } 
 return super . getText ( element ) ; 
 } 
 public Image getImage ( Object element ) { 
 return MavenEditorImages . IMG_PLUGIN ; 
 } 
 } ) ; 
 reportPluginsEditor . addSelectionListener ( new ISelectionChangedListener ( ) { 
 public void selectionChanged ( SelectionChangedEvent event ) { 
 List < ReportPlugin > selection = reportPluginsEditor . getSelection ( ) ; 
 updateReportPluginDetails ( selection . size ( ) == 1   ? selection . get ( 0 ) : null ) ; 
 } 
 } ) ; 
 // XXX implement actions 
 }  ","private void createContentSection ( SashForm horizontalSash ) { 
 Composite composite_1 = toolkit . createComposite ( horizontalSash , SWT . NONE ) ; 
 GridLayout gridLayout = new GridLayout ( ) ; 
 gridLayout . marginWidth = 0 ; 
 gridLayout . marginHeight = 0 ; 
 composite_1 . setLayout ( gridLayout ) ; 
 toolkit . paintBordersFor ( composite_1 ) ; 
 Section contentSection = toolkit . createSection ( composite_1 , Section . TITLE_BAR ) ; 
 contentSection . setLayoutData ( new GridData ( SWT . FILL , SWT . FILL , true , false ) ) ; 
 contentSection . setText ( ""Content"" ) ; 
 Composite composite = toolkit . createComposite ( contentSection , SWT . NONE ) ; 
 composite . setLayout ( new GridLayout ( 2 , false ) ) ; 
 contentSection . setClient ( composite ) ; 
 toolkit . paintBordersFor ( composite ) ; 
 toolkit . createLabel ( composite , ""Output Folder:"" , SWT . NONE ) ; 
 outputFolderText = toolkit . createText ( composite , null , SWT . NONE ) ; 
 outputFolderText . setLayoutData ( new GridData ( SWT . FILL , SWT . CENTER , true , false ) ) ; 
 excludeDefaultsButton = toolkit . createButton ( composite , ""Exclude Defaults"" , SWT . CHECK ) ; 
 excludeDefaultsButton . setLayoutData ( new GridData ( SWT . RIGHT , SWT . CENTER , false , false , 2 , 1 ) ) ; 
 Section reportingPluginsSection = toolkit . createSection ( composite_1 , Section . TITLE_BAR ) ; 
 reportingPluginsSection . setLayoutData ( new GridData ( SWT . FILL , SWT . FILL , false , true ) ) ; 
 reportingPluginsSection . setText ( ""Reporting Plugins"" ) ; 
 reportPluginsEditor = new ListEditorComposite < ReportPlugin > ( reportingPluginsSection , SWT . NONE ) ; 
 reportingPluginsSection . setClient ( reportPluginsEditor ) ; 
 toolkit . paintBordersFor ( reportPluginsEditor ) ; 
 toolkit . adapt ( reportPluginsEditor ) ; 
 reportPluginsEditor . setContentProvider ( new ListEditorContentProvider < ReportPlugin > ( ) ) ; 
 reportPluginsEditor . setLabelProvider ( new LabelProvider ( ) { 
 public String getText ( Object element ) { 
 if ( element instanceof ReportPlugin ) { 
 ReportPlugin reportPlugin = ( ReportPlugin ) element ; 
 String groupId = reportPlugin . getGroupId ( ) ; 
 String artifactId = reportPlugin . getArtifactId ( ) ; 
 String version = reportPlugin . getVersion ( ) ; 
 String label = groupId == null   ? ""[unknown]"" : groupId ; 
 label += "" : "" + ( artifactId == null   ? ""[unknown]"" : artifactId ) ; 
 if ( version != null ) { 
 label += "" : "" + version ; 
 } 
 return label ; 
 } 
 return super . getText ( element ) ; 
 } 
 public Image getImage ( Object element ) { 
 return MavenEditorImages . IMG_PLUGIN ; 
 } 
 } ) ; 
 reportPluginsEditor . addSelectionListener ( new ISelectionChangedListener ( ) { 
 public void selectionChanged ( SelectionChangedEvent event ) { 
 List < ReportPlugin > selection = reportPluginsEditor . getSelection ( ) ; 
 updateReportPluginDetails ( selection . size ( ) == 1   ? selection . get ( 0 ) : null ) ; 
 } 
 } ) ; 
 reportPluginsEditor . setAddListener ( new SelectionAdapter ( ) { 
 public void widgetSelected ( SelectionEvent e ) { 
 CompoundCommand compoundCommand = new CompoundCommand ( ) ; 
 EditingDomain editingDomain = parent . getEditingDomain ( ) ; 
 boolean reportsCreated = false ; 
 Model model = parent . getModel ( ) ; 
 Reporting reporting = model . getReporting ( ) ; 
 if ( reporting == null ) { 
 reporting = PomFactory . eINSTANCE . createReporting ( ) ; 
 Command addReporting = SetCommand . create ( editingDomain , model , POM_PACKAGE . getModel_Reporting ( ) , reporting ) ; 
 compoundCommand . append ( addReporting ) ; 
 reportsCreated = true ; 
 } 
 ReportPlugins reportPlugins = reporting . getPlugins ( ) ; 
 if ( reportPlugins == null ) { 
 reportPlugins = PomFactory . eINSTANCE . createReportPlugins ( ) ; 
 Command addReportPlugins = SetCommand . create ( editingDomain , reporting , POM_PACKAGE . getReporting_Plugins ( ) , 
 reportPlugins ) ; 
 compoundCommand . append ( addReportPlugins ) ; 
 reportsCreated = true ; 
 } 
 ReportPlugin reportPlugin = PomFactory . eINSTANCE . createReportPlugin ( ) ; 
 Command addReportPlugin = AddCommand . create ( editingDomain , reportPlugins , 
 POM_PACKAGE . getReportPlugins_Plugin ( ) , reportPlugin ) ; 
 compoundCommand . append ( addReportPlugin ) ; 
 editingDomain . getCommandStack ( ) . execute ( compoundCommand ) ; 
 if ( reportsCreated ) { 
 updateContent ( reporting ) ; 
 } else { 
 updateReportPluginDetails ( reportPlugin ) ; 
 } 
 reportPluginsEditor . setSelection ( Collections . singletonList ( reportPlugin ) ) ; 
 groupIdText . setFocus ( ) ; 
 } 
 } ) ; 
 reportPluginsEditor . setRemoveListener ( new SelectionAdapter ( ) { 
 public void widgetSelected ( SelectionEvent e ) { 
 CompoundCommand compoundCommand = new CompoundCommand ( ) ; 
 EditingDomain editingDomain = parent . getEditingDomain ( ) ; 
 Model model = parent . getModel ( ) ; 
 Reporting reporting = model . getReporting ( ) ; 
 ReportPlugins reportPlugins = reporting == null   ? null : reporting . getPlugins ( ) ; 
 if ( reportPlugins != null ) { 
 List < ReportPlugin > pluginList = reportPluginsEditor . getSelection ( ) ; 
 for ( ReportPlugin reportPlugin : pluginList ) { 
 Command removeCommand = RemoveCommand . create ( editingDomain , reportPlugins , POM_PACKAGE . getPlugins_Plugin ( ) , 
 reportPlugin ) ; 
 compoundCommand . append ( removeCommand ) ; 
 } 
 editingDomain . getCommandStack ( ) . execute ( compoundCommand ) ; 
 updateContent ( reporting ) ; 
 } 
 } 
 } ) ; 
 }  ",2008-06-19 04:24:58 +0000,2008-06-25 16:39:41 +0000,0,0.7647240840081928
1849,304,https://www.github.com/php-coder/mystamps,"saveParsedData(Integer, RawParsedDataDto)",,178,178,181,183,TODO: handle it gracefully by publishing ParsingFailed event,https://www.github.com/php-coder/mystamps/commit/29f6dc9a14,https://www.github.com/php-coder/mystamps/commit/4ed41b45ab3bb7f8c3d45566db348af33f8552cc,src/main/java/ru/mystamps/web/service/SeriesImportServiceImpl.java,"@Override
@Transactional
public void saveParsedData(Integer requestId, RawParsedDataDto data) {
Validate.isTrue(requestId != null, ""Request id must be non null"");
Validate.isTrue(data != null, ""Parsed data must be non null"");
SaveParsedDataDbDto processedData = new SaveParsedDataDbDto();
processedData.setImageUrl(data.getImageUrl());
Date now = new Date();
processedData.setCreatedAt(now);
processedData.setUpdatedAt(now);
List<Integer> categoryIds = extractorService.extractCategory(data.getCategoryName());
if (!categoryIds.isEmpty()) {
processedData.setCategoryId(categoryIds.get(0));
}
List<Integer> countryIds = extractorService.extractCountry(data.getCountryName());
if (!countryIds.isEmpty()) {
processedData.setCountryId(countryIds.get(0));
}
Integer releaseYear = extractorService.extractReleaseYear(data.getReleaseYear());
if (releaseYear != null) {
processedData.setReleaseYear(releaseYear);
}
// TODO: handle it gracefully by publishing ParsingFailed event
Validate.validState(processedData.hasAtLeastOneFieldFilled(), """");
seriesImportDao.addParsedContent(requestId, processedData);
log.info(""Request #{}: page were parsed ({})"", requestId, processedData);
changeStatus(
			requestId,
			SeriesImportRequestStatus.DOWNLOADING_SUCCEEDED,
			SeriesImportRequestStatus.PARSING_SUCCEEDED
		);
}","@Override
@Transactional
public void saveParsedData(Integer requestId, RawParsedDataDto data) {
Validate.isTrue(requestId != null, ""Request id must be non null"");
Validate.isTrue(data != null, ""Parsed data must be non null"");
SaveParsedDataDbDto processedData = new SaveParsedDataDbDto();
processedData.setImageUrl(data.getImageUrl());
Date now = new Date();
processedData.setCreatedAt(now);
processedData.setUpdatedAt(now);
List<Integer> categoryIds = extractorService.extractCategory(data.getCategoryName());
if (!categoryIds.isEmpty()) {
processedData.setCategoryId(categoryIds.get(0));
}
List<Integer> countryIds = extractorService.extractCountry(data.getCountryName());
if (!countryIds.isEmpty()) {
processedData.setCountryId(countryIds.get(0));
}
Integer releaseYear = extractorService.extractReleaseYear(data.getReleaseYear());
if (releaseYear != null) {
processedData.setReleaseYear(releaseYear);
}
// IMPORTANT: don't add code that modifies database above this line!
// @todo #684 Series import: add integration test
//  for the case when parsed value don't match database
if (!processedData.hasAtLeastOneFieldFilled()) {
eventPublisher.publishEvent(new ParsingFailed(this, requestId));
return;
}
seriesImportDao.addParsedContent(requestId, processedData);
log.info(""Request #{}: page were parsed ({})"", requestId, processedData);
changeStatus(
			requestId,
			SeriesImportRequestStatus.DOWNLOADING_SUCCEEDED,
			SeriesImportRequestStatus.PARSING_SUCCEEDED
		);
}","@ Override 
 @ Transactional 
 public void saveParsedData ( Integer requestId , RawParsedDataDto data ) { 
 Validate . isTrue ( requestId != null , ""Request id must be non null"" ) ; 
 Validate . isTrue ( data != null , ""Parsed data must be non null"" ) ; 
 SaveParsedDataDbDto processedData = new SaveParsedDataDbDto ( ) ; 
 processedData . setImageUrl ( data . getImageUrl ( ) ) ; 
 Date now = new Date ( ) ; 
 processedData . setCreatedAt ( now ) ; 
 processedData . setUpdatedAt ( now ) ; 
 List < Integer > categoryIds = extractorService . extractCategory ( data . getCategoryName ( ) ) ; 
 if ( ! categoryIds . isEmpty ( ) ) { 
 processedData . setCategoryId ( categoryIds . get ( 0 ) ) ; 
 } 
 List < Integer > countryIds = extractorService . extractCountry ( data . getCountryName ( ) ) ; 
 if ( ! countryIds . isEmpty ( ) ) { 
 processedData . setCountryId ( countryIds . get ( 0 ) ) ; 
 } 
 Integer releaseYear = extractorService . extractReleaseYear ( data . getReleaseYear ( ) ) ; 
 if ( releaseYear != null ) { 
 processedData . setReleaseYear ( releaseYear ) ; 
 } 
 // TODO : handle it gracefully by publishing ParsingFailed event 
 Validate . validState ( processedData . hasAtLeastOneFieldFilled ( ) , """" ) ; 
 seriesImportDao . addParsedContent ( requestId , processedData ) ; 
 log . info ( ""Request #{}: page were parsed ({})"" , requestId , processedData ) ; 
 changeStatus ( 
 requestId , 
 SeriesImportRequestStatus . DOWNLOADING_SUCCEEDED , 
 SeriesImportRequestStatus . PARSING_SUCCEEDED 
 ) ; 
 }  ","@ Override 
 @ Transactional 
 public void saveParsedData ( Integer requestId , RawParsedDataDto data ) { 
 Validate . isTrue ( requestId != null , ""Request id must be non null"" ) ; 
 Validate . isTrue ( data != null , ""Parsed data must be non null"" ) ; 
 SaveParsedDataDbDto processedData = new SaveParsedDataDbDto ( ) ; 
 processedData . setImageUrl ( data . getImageUrl ( ) ) ; 
 Date now = new Date ( ) ; 
 processedData . setCreatedAt ( now ) ; 
 processedData . setUpdatedAt ( now ) ; 
 List < Integer > categoryIds = extractorService . extractCategory ( data . getCategoryName ( ) ) ; 
 if ( ! categoryIds . isEmpty ( ) ) { 
 processedData . setCategoryId ( categoryIds . get ( 0 ) ) ; 
 } 
 List < Integer > countryIds = extractorService . extractCountry ( data . getCountryName ( ) ) ; 
 if ( ! countryIds . isEmpty ( ) ) { 
 processedData . setCountryId ( countryIds . get ( 0 ) ) ; 
 } 
 Integer releaseYear = extractorService . extractReleaseYear ( data . getReleaseYear ( ) ) ; 
 if ( releaseYear != null ) { 
 processedData . setReleaseYear ( releaseYear ) ; 
 } 
 // IMPORTANT : don ' t add code that modifies database above this line ! 
 // @ todo #684 Series import: add integration test 
 // for the case when parsed value don ' t match database 
 if ( ! processedData . hasAtLeastOneFieldFilled ( ) ) { 
 eventPublisher . publishEvent ( new ParsingFailed ( this , requestId ) ) ; 
 return ; 
 } 
 seriesImportDao . addParsedContent ( requestId , processedData ) ; 
 log . info ( ""Request #{}: page were parsed ({})"" , requestId , processedData ) ; 
 changeStatus ( 
 requestId , 
 SeriesImportRequestStatus . DOWNLOADING_SUCCEEDED , 
 SeriesImportRequestStatus . PARSING_SUCCEEDED 
 ) ; 
 }  ",2017-11-08 00:23:32 +0100,2017-12-05 00:06:35 +0100,0,0.9463842486808225
519,179,https://www.github.com/flyingsaucerproject/flyingsaucer,"paintChildren(Context, Box)",DESIGN,42,42,42,42,TODO: wouldn't the box itself know if it was block layout?,https://www.github.com/flyingsaucerproject/flyingsaucer/commit/e17d1b28c,https://www.github.com/flyingsaucerproject/flyingsaucer/commit/bbe26e114cd1f823901a5ca3d63b5fccfdfedf81,src/java/org/xhtmlrenderer/render/InlineRenderer.java,"public void paintChildren(Context c, Box box) {
if (box.isAnonymous()) {
return;
}
//TODO: wouldn't the box itself know if it was block layout?
if (LayoutUtil.isBlockLayout(box.getElement(), c)) {
super.paintChildren(c, box);
}
}","public void paintChildren(Context c, Box box) {
if (box.isAnonymous()) {
return;
}
if (box instanceof BlockBox) {
super.paintChildren(c, box);
}
}","public void paintChildren ( Context c , Box box ) { 
 if ( box . isAnonymous ( ) ) { 
 return ; 
 } 
 // TODO : wouldn ' t the box itself know if it was block layout ? 
 if ( LayoutUtil . isBlockLayout ( box . getElement ( ) , c ) ) { 
 super . paintChildren ( c , box ) ; 
 } 
 }  ","public void paintChildren ( Context c , Box box ) { 
 if ( box . isAnonymous ( ) ) { 
 return ; 
 } 
 if ( box instanceof BlockBox ) { 
 super . paintChildren ( c , box ) ; 
 } 
 }  ",2004-12-09 00:11:50 +0000,2004-12-10 06:50:59 +0000,0,0.8506789022526219
1980,626,https://www.github.com/apache/flume,append(Event),,48,48,48,48,TODO (jon) clean this up.,https://www.github.com/apache/flume/commit/31ecbbf79,https://www.github.com/apache/flume/commit/4d32423dadc1d1ee56a3395d1cdc0e4a83981cbe,src/java/com/cloudera/flume/handlers/debug/DelayDecorator.java,"@Override
public void append(Event e) throws IOException {
try {
Thread.sleep(millis);
super.append(e);
} catch (InterruptedException e1) {
// TODO (jon) clean this up.
throw new IOException("""", e1);
}
}","@Override
public void append(Event e) throws IOException {
try {
Thread.sleep(millis);
super.append(e);
} catch (InterruptedException e1) {
throw new IOException(e1.getMessage(), e1);
}
}","@ Override 
 public void append ( Event e ) throws IOException { 
 try { 
 Thread . sleep ( millis ) ; 
 super . append ( e ) ; 
 } catch ( InterruptedException e1 ) { 
 // TODO ( jon ) clean this up . 
 throw new IOException ( """" , e1 ) ; 
 } 
 }  ","@ Override 
 public void append ( Event e ) throws IOException { 
 try { 
 Thread . sleep ( millis ) ; 
 super . append ( e ) ; 
 } catch ( InterruptedException e1 ) { 
 throw new IOException ( e1 . getMessage ( ) , e1 ) ; 
 } 
 }  ",2011-08-02 16:03:58 +0000,2011-08-02 16:04:12 +0000,0,0.8635959068035448
255,509,https://www.github.com/stoicflame/enunciate,testCanvas(),NOT_DESIGN,449,449,449,449,todo: uncomment with support for @XmlElements,https://www.github.com/stoicflame/enunciate/commit/85110fb2bf,https://www.github.com/stoicflame/enunciate/commit/db9906147dc64494f2c8561d84bc8ca410ae9d38,ruby/src/test/java/org/codehaus/enunciate/modules/ruby/TestRubySerialization.java,"public void testCanvas() throws Exception {
if (this.skipRubyTests) {
System.out.println(""Ruby tests have been disabled."");
return;
}
Canvas canvas = new Canvas();
Bus bus = new Bus();
bus.setId(""busId"");
Rectangle busFrame = new Rectangle();
busFrame.setWidth(100);
bus.setFrame(busFrame);
Cat cat = new Cat();
cat.setId(""catId"");
Circle catFace = new Circle();
catFace.setRadius(30);
cat.setFace(catFace);
House house = new House();
house.setId(""houseId"");
Rectangle houseBase = new Rectangle();
houseBase.setWidth(76);
house.setBase(houseBase);
canvas.setFigures(Arrays.asList(bus, cat, house));
Rectangle rectangle = new Rectangle();
rectangle.setHeight(50);
rectangle.setId(""rectId"");
Circle circle = new Circle();
circle.setRadius(10);
circle.setId(""circleId"");
Triangle triangle = new Triangle();
triangle.setBase(80);
triangle.setId(""triId"");
canvas.setShapes(Arrays.asList(rectangle, circle, triangle));
//    byte[] swaRefBytes = ""This is a bunch of random bytes that are to be used as an SWA ref attachment."".getBytes();
//    byte[] explicitBase64Bytes = ""This is some more random bytes that are to be used as a base 64 encoded attachment."".getBytes();
//    byte[] attachment1Bytes = ""This is some more random bytes that are to be used as the first MTOM attachment."".getBytes();
//    byte[] attachment2Bytes = ""This is some more random bytes that are to be used as the second MTOM attachment."".getBytes();
//    byte[] attachment3Bytes = ""This is some more random bytes that are to be used as the third MTOM attachment."".getBytes();
//    CanvasAttachment attachment1 = new CanvasAttachment();
//    attachment1.setValue(attachment1Bytes);
//    CanvasAttachment attachment2 = new CanvasAttachment();
//    attachment2.setValue(attachment2Bytes);
//    CanvasAttachment attachment3 = new CanvasAttachment();
//    attachment3.setValue(attachment3Bytes);
//    ByteArrayDataSource dataSource = new ByteArrayDataSource(swaRefBytes, ""application/octet-stream"");
//    dataSource.setName(""somename"");
//    canvas.setBackgroundImage(new DataHandler(dataSource));
//    canvas.setExplicitBase64Attachment(explicitBase64Bytes);
//    canvas.setOtherAttachments(Arrays.asList(attachment1, attachment2, attachment3));
canvas = processThroughJson(canvas);
Collection shapes = canvas.getShapes();
assertEquals(3, shapes.size());
//todo: uncomment with support for @XmlElementRefs.
//    for (Object Shape : shapes) {
//      if (Shape instanceof Circle) {
//        assertEquals(""circleId"", ((Circle) Shape).getId());
//        assertEquals(10, ((Circle) Shape).getRadius());
//      }
//      else if (Shape instanceof Rectangle) {
//        assertEquals(""rectId"", ((Rectangle) Shape).getId());
//        assertEquals(50, ((Rectangle) Shape).getHeight());
//      }
//      else if (Shape instanceof Triangle) {
//        assertEquals(""triId"", ((Triangle) Shape).getId());
//        assertEquals(80, ((Triangle) Shape).getBase());
//      }
//      else {
//        fail(""Unknown shape: "" + Shape);
//      }
//    }
Collection figures = canvas.getFigures();
assertEquals(3, figures.size());
//todo: uncomment with support for @XmlElements
//    for (Object Figure : figures) {
//      if (Figure instanceof Bus) {
//        bus = (Bus) Figure;
//        assertEquals(""busId"", bus.getId());
//        Rectangle BusFrame = bus.getFrame();
//        assertNotNull(BusFrame);
//        assertEquals(100, busFrame.getWidth());
//      }
//      else if (Figure instanceof Cat) {
//        cat = (Cat) Figure;
//        assertEquals(""catId"", cat.getId());
//        Circle CatFace = cat.getFace();
//        assertNotNull(CatFace);
//        assertEquals(30, CatFace.getRadius());
//      }
//      else if (Figure instanceof House) {
//        house = (House) Figure;
//        assertEquals(""houseId"", house.getId());
//        Rectangle HouseBase = house.getBase();
//        assertNotNull(HouseBase);
//        assertEquals(76, HouseBase.getWidth());
//      }
//      else {
//        fail(""Unknown figure: "" + Figure);
//      }
//    }
//    todo: uncomment when you figure out the attachment stuff...
//    DataHandler backgroundImage = canvas.getBackgroundImage();
//    InputStream attachmentStream = backgroundImage.getInputStream();
//    ByteArrayOutputStream bgImageIn = new ByteArrayOutputStream();
//    int byteIn = attachmentStream.read();
//    while (byteIn > 0) {
//      bgImageIn.write(byteIn);
//      byteIn = attachmentStream.read();
//    }
//
//    assertTrue(Arrays.equals(swaRefBytes, bgImageIn.toByteArray()));
//
//    byte[] base64Attachment = canvas.getExplicitBase64Attachment();
//    assertNotNull(base64Attachment);
//    assertTrue(Arrays.equals(explicitBase64Bytes, base64Attachment));
//
//    Collection<CanvasAttachment> otherAttachments = canvas.getOtherAttachments();
//    assertEquals(3, otherAttachments.size());
//    Iterator<CanvasAttachment> attachmentsIt = otherAttachments.iterator();
//    int attachmentCount = 0;
//    while (attachmentsIt.hasNext()) {
//      CanvasAttachment otherAttachment = (CanvasAttachment) attachmentsIt.next();
//      byte[] otherAttachmentBytes = otherAttachment.getValue();
//      if (Arrays.equals(attachment1Bytes, otherAttachmentBytes)) {
//        attachmentCount++;
//      }
//      else if (Arrays.equals(attachment2Bytes, otherAttachmentBytes)) {
//        attachmentCount++;
//      }
//      else if (Arrays.equals(attachment3Bytes, otherAttachmentBytes)) {
//        attachmentCount++;
//      }
//      else {
//        fail(""Unknown attachment."");
//      }
//    }
//    assertEquals(3, attachmentCount);
//todo: test element ref to an attachment element
//todo: test element refs of attachment elements.
}","public void testCanvas() throws Exception {
if (this.skipRubyTests) {
System.out.println(""Ruby tests have been disabled."");
return;
}
Canvas canvas = new Canvas();
Bus bus = new Bus();
bus.setId(""busId"");
Rectangle busFrame = new Rectangle();
busFrame.setWidth(100);
bus.setFrame(busFrame);
Cat cat = new Cat();
cat.setId(""catId"");
Circle catFace = new Circle();
catFace.setRadius(30);
cat.setFace(catFace);
House house = new House();
house.setId(""houseId"");
Rectangle houseBase = new Rectangle();
houseBase.setWidth(76);
house.setBase(houseBase);
canvas.setFigures(Arrays.asList(bus, cat, house));
Rectangle rectangle = new Rectangle();
rectangle.setHeight(50);
rectangle.setId(""rectId"");
Circle circle = new Circle();
circle.setRadius(10);
circle.setId(""circleId"");
Triangle triangle = new Triangle();
triangle.setBase(80);
triangle.setId(""triId"");
//canvas.setShapes(Arrays.asList(rectangle, circle, triangle));
//    byte[] swaRefBytes = ""This is a bunch of random bytes that are to be used as an SWA ref attachment."".getBytes();
//    byte[] explicitBase64Bytes = ""This is some more random bytes that are to be used as a base 64 encoded attachment."".getBytes();
//    byte[] attachment1Bytes = ""This is some more random bytes that are to be used as the first MTOM attachment."".getBytes();
//    byte[] attachment2Bytes = ""This is some more random bytes that are to be used as the second MTOM attachment."".getBytes();
//    byte[] attachment3Bytes = ""This is some more random bytes that are to be used as the third MTOM attachment."".getBytes();
//    CanvasAttachment attachment1 = new CanvasAttachment();
//    attachment1.setValue(attachment1Bytes);
//    CanvasAttachment attachment2 = new CanvasAttachment();
//    attachment2.setValue(attachment2Bytes);
//    CanvasAttachment attachment3 = new CanvasAttachment();
//    attachment3.setValue(attachment3Bytes);
//    ByteArrayDataSource dataSource = new ByteArrayDataSource(swaRefBytes, ""application/octet-stream"");
//    dataSource.setName(""somename"");
//    canvas.setBackgroundImage(new DataHandler(dataSource));
//    canvas.setExplicitBase64Attachment(explicitBase64Bytes);
//    canvas.setOtherAttachments(Arrays.asList(attachment1, attachment2, attachment3));
canvas = processThroughJson(canvas);
//Collection shapes = canvas.getShapes();
//assertEquals(3, shapes.size());
//todo: uncomment with support for @XmlElementRefs.
//    for (Object Shape : shapes) {
//      if (Shape instanceof Circle) {
//        assertEquals(""circleId"", ((Circle) Shape).getId());
//        assertEquals(10, ((Circle) Shape).getRadius());
//      }
//      else if (Shape instanceof Rectangle) {
//        assertEquals(""rectId"", ((Rectangle) Shape).getId());
//        assertEquals(50, ((Rectangle) Shape).getHeight());
//      }
//      else if (Shape instanceof Triangle) {
//        assertEquals(""triId"", ((Triangle) Shape).getId());
//        assertEquals(80, ((Triangle) Shape).getBase());
//      }
//      else {
//        fail(""Unknown shape: "" + Shape);
//      }
//    }
Collection figures = canvas.getFigures();
assertEquals(3, figures.size());
for (Object Figure : figures) {
if (Figure instanceof Bus) {
bus = (Bus) Figure;
assertEquals(""busId"", bus.getId());
Rectangle BusFrame = bus.getFrame();
assertNotNull(BusFrame);
assertEquals(100, busFrame.getWidth());
}
else if (Figure instanceof Cat) {
cat = (Cat) Figure;
assertEquals(""catId"", cat.getId());
Circle CatFace = cat.getFace();
assertNotNull(CatFace);
assertEquals(30, CatFace.getRadius());
}
else if (Figure instanceof House) {
house = (House) Figure;
assertEquals(""houseId"", house.getId());
Rectangle HouseBase = house.getBase();
assertNotNull(HouseBase);
assertEquals(76, HouseBase.getWidth());
}
else {
fail(""Unknown figure: "" + Figure);
}
}
//    todo: uncomment when you figure out the attachment stuff...
//    DataHandler backgroundImage = canvas.getBackgroundImage();
//    InputStream attachmentStream = backgroundImage.getInputStream();
//    ByteArrayOutputStream bgImageIn = new ByteArrayOutputStream();
//    int byteIn = attachmentStream.read();
//    while (byteIn > 0) {
//      bgImageIn.write(byteIn);
//      byteIn = attachmentStream.read();
//    }
//
//    assertTrue(Arrays.equals(swaRefBytes, bgImageIn.toByteArray()));
//
//    byte[] base64Attachment = canvas.getExplicitBase64Attachment();
//    assertNotNull(base64Attachment);
//    assertTrue(Arrays.equals(explicitBase64Bytes, base64Attachment));
//
//    Collection<CanvasAttachment> otherAttachments = canvas.getOtherAttachments();
//    assertEquals(3, otherAttachments.size());
//    Iterator<CanvasAttachment> attachmentsIt = otherAttachments.iterator();
//    int attachmentCount = 0;
//    while (attachmentsIt.hasNext()) {
//      CanvasAttachment otherAttachment = (CanvasAttachment) attachmentsIt.next();
//      byte[] otherAttachmentBytes = otherAttachment.getValue();
//      if (Arrays.equals(attachment1Bytes, otherAttachmentBytes)) {
//        attachmentCount++;
//      }
//      else if (Arrays.equals(attachment2Bytes, otherAttachmentBytes)) {
//        attachmentCount++;
//      }
//      else if (Arrays.equals(attachment3Bytes, otherAttachmentBytes)) {
//        attachmentCount++;
//      }
//      else {
//        fail(""Unknown attachment."");
//      }
//    }
//    assertEquals(3, attachmentCount);
//todo: test element ref to an attachment element
//todo: test element refs of attachment elements.
}","public void testCanvas ( ) throws Exception { 
 if ( this . skipRubyTests ) { 
 System . out . println ( ""Ruby tests have been disabled."" ) ; 
 return ; 
 } 
 Canvas canvas = new Canvas ( ) ; 
 Bus bus = new Bus ( ) ; 
 bus . setId ( ""busId"" ) ; 
 Rectangle busFrame = new Rectangle ( ) ; 
 busFrame . setWidth ( 100 ) ; 
 bus . setFrame ( busFrame ) ; 
 Cat cat = new Cat ( ) ; 
 cat . setId ( ""catId"" ) ; 
 Circle catFace = new Circle ( ) ; 
 catFace . setRadius ( 30 ) ; 
 cat . setFace ( catFace ) ; 
 House house = new House ( ) ; 
 house . setId ( ""houseId"" ) ; 
 Rectangle houseBase = new Rectangle ( ) ; 
 houseBase . setWidth ( 76 ) ; 
 house . setBase ( houseBase ) ; 
 canvas . setFigures ( Arrays . asList ( bus , cat , house ) ) ; 
 Rectangle rectangle = new Rectangle ( ) ; 
 rectangle . setHeight ( 50 ) ; 
 rectangle . setId ( ""rectId"" ) ; 
 Circle circle = new Circle ( ) ; 
 circle . setRadius ( 10 ) ; 
 circle . setId ( ""circleId"" ) ; 
 Triangle triangle = new Triangle ( ) ; 
 triangle . setBase ( 80 ) ; 
 triangle . setId ( ""triId"" ) ; 
 canvas . setShapes ( Arrays . asList ( rectangle , circle , triangle ) ) ; 
 // byte [ ] swaRefBytes = ""This is a bunch of random bytes that are to be used as an SWA ref attachment."" . getBytes ( ) ; 
 // byte [ ] explicitBase64Bytes = ""This is some more random bytes that are to be used as a base 64 encoded attachment."" . getBytes ( ) ; 
 // byte [ ] attachment1Bytes = ""This is some more random bytes that are to be used as the first MTOM attachment."" . getBytes ( ) ; 
 // byte [ ] attachment2Bytes = ""This is some more random bytes that are to be used as the second MTOM attachment."" . getBytes ( ) ; 
 // byte [ ] attachment3Bytes = ""This is some more random bytes that are to be used as the third MTOM attachment."" . getBytes ( ) ; 
 // CanvasAttachment attachment1 = new CanvasAttachment ( ) ; 
 // attachment1 . setValue ( attachment1Bytes ) ; 
 // CanvasAttachment attachment2 = new CanvasAttachment ( ) ; 
 // attachment2 . setValue ( attachment2Bytes ) ; 
 // CanvasAttachment attachment3 = new CanvasAttachment ( ) ; 
 // attachment3 . setValue ( attachment3Bytes ) ; 
 // ByteArrayDataSource dataSource = new ByteArrayDataSource ( swaRefBytes , ""application/octet-stream"" ) ; 
 // dataSource . setName ( ""somename"" ) ; 
 // canvas . setBackgroundImage ( new DataHandler ( dataSource ) ) ; 
 // canvas . setExplicitBase64Attachment ( explicitBase64Bytes ) ; 
 // canvas . setOtherAttachments ( Arrays . asList ( attachment1 , attachment2 , attachment3 ) ) ; 
 canvas = processThroughJson ( canvas ) ; 
 Collection shapes = canvas . getShapes ( ) ; 
 assertEquals ( 3 , shapes . size ( ) ) ; 
 // todo : uncomment with support for @ XmlElementRefs . 
 // for ( Object Shape : shapes ) { 
 // if ( Shape instanceof Circle ) { 
 // assertEquals ( ""circleId"" , ( ( Circle ) Shape ) . getId ( ) ) ; 
 // assertEquals ( 10 , ( ( Circle ) Shape ) . getRadius ( ) ) ; 
 // } 
 // else if ( Shape instanceof Rectangle ) { 
 // assertEquals ( ""rectId"" , ( ( Rectangle ) Shape ) . getId ( ) ) ; 
 // assertEquals ( 50 , ( ( Rectangle ) Shape ) . getHeight ( ) ) ; 
 // } 
 // else if ( Shape instanceof Triangle ) { 
 // assertEquals ( ""triId"" , ( ( Triangle ) Shape ) . getId ( ) ) ; 
 // assertEquals ( 80 , ( ( Triangle ) Shape ) . getBase ( ) ) ; 
 // } 
 // else { 
 // fail ( ""Unknown shape: "" + Shape ) ; 
 // } 
 // } 
 Collection figures = canvas . getFigures ( ) ; 
 assertEquals ( 3 , figures . size ( ) ) ; 
 // todo : uncomment with support for @ XmlElements 
 // for ( Object Figure : figures ) { 
 // if ( Figure instanceof Bus ) { 
 // bus = ( Bus ) Figure ; 
 // assertEquals ( ""busId"" , bus . getId ( ) ) ; 
 // Rectangle BusFrame = bus . getFrame ( ) ; 
 // assertNotNull ( BusFrame ) ; 
 // assertEquals ( 100 , busFrame . getWidth ( ) ) ; 
 // } 
 // else if ( Figure instanceof Cat ) { 
 // cat = ( Cat ) Figure ; 
 // assertEquals ( ""catId"" , cat . getId ( ) ) ; 
 // Circle CatFace = cat . getFace ( ) ; 
 // assertNotNull ( CatFace ) ; 
 // assertEquals ( 30 , CatFace . getRadius ( ) ) ; 
 // } 
 // else if ( Figure instanceof House ) { 
 // house = ( House ) Figure ; 
 // assertEquals ( ""houseId"" , house . getId ( ) ) ; 
 // Rectangle HouseBase = house . getBase ( ) ; 
 // assertNotNull ( HouseBase ) ; 
 // assertEquals ( 76 , HouseBase . getWidth ( ) ) ; 
 // } 
 // else { 
 // fail ( ""Unknown figure: "" + Figure ) ; 
 // } 
 // } 
 // todo : uncomment when you figure out the attachment stuff ... 
 // DataHandler backgroundImage = canvas . getBackgroundImage ( ) ; 
 // InputStream attachmentStream = backgroundImage . getInputStream ( ) ; 
 // ByteArrayOutputStream bgImageIn = new ByteArrayOutputStream ( ) ; 
 // int byteIn = attachmentStream . read ( ) ; 
 // while ( byteIn > 0 ) { 
 // bgImageIn . write ( byteIn ) ; 
 // byteIn = attachmentStream . read ( ) ; 
 // } 
 // 
 // assertTrue ( Arrays . equals ( swaRefBytes , bgImageIn . toByteArray ( ) ) ) ; 
 // 
 // byte [ ] base64Attachment = canvas . getExplicitBase64Attachment ( ) ; 
 // assertNotNull ( base64Attachment ) ; 
 // assertTrue ( Arrays . equals ( explicitBase64Bytes , base64Attachment ) ) ; 
 // 
 // Collection < CanvasAttachment > otherAttachments = canvas . getOtherAttachments ( ) ; 
 // assertEquals ( 3 , otherAttachments . size ( ) ) ; 
 // Iterator < CanvasAttachment > attachmentsIt = otherAttachments . iterator ( ) ; 
 // int attachmentCount = 0 ; 
 // while ( attachmentsIt . hasNext ( ) ) { 
 // CanvasAttachment otherAttachment = ( CanvasAttachment ) attachmentsIt . next ( ) ; 
 // byte [ ] otherAttachmentBytes = otherAttachment . getValue ( ) ; 
 // if ( Arrays . equals ( attachment1Bytes , otherAttachmentBytes ) ) { 
 // attachmentCount + + ; 
 // } 
 // else if ( Arrays . equals ( attachment2Bytes , otherAttachmentBytes ) ) { 
 // attachmentCount + + ; 
 // } 
 // else if ( Arrays . equals ( attachment3Bytes , otherAttachmentBytes ) ) { 
 // attachmentCount + + ; 
 // } 
 // else { 
 // fail ( ""Unknown attachment."" ) ; 
 // } 
 // } 
 // assertEquals ( 3 , attachmentCount ) ; 
 // todo : test element ref to an attachment element 
 // todo : test element refs of attachment elements . 
 }  ","public void testCanvas ( ) throws Exception { 
 if ( this . skipRubyTests ) { 
 System . out . println ( ""Ruby tests have been disabled."" ) ; 
 return ; 
 } 
 Canvas canvas = new Canvas ( ) ; 
 Bus bus = new Bus ( ) ; 
 bus . setId ( ""busId"" ) ; 
 Rectangle busFrame = new Rectangle ( ) ; 
 busFrame . setWidth ( 100 ) ; 
 bus . setFrame ( busFrame ) ; 
 Cat cat = new Cat ( ) ; 
 cat . setId ( ""catId"" ) ; 
 Circle catFace = new Circle ( ) ; 
 catFace . setRadius ( 30 ) ; 
 cat . setFace ( catFace ) ; 
 House house = new House ( ) ; 
 house . setId ( ""houseId"" ) ; 
 Rectangle houseBase = new Rectangle ( ) ; 
 houseBase . setWidth ( 76 ) ; 
 house . setBase ( houseBase ) ; 
 canvas . setFigures ( Arrays . asList ( bus , cat , house ) ) ; 
 Rectangle rectangle = new Rectangle ( ) ; 
 rectangle . setHeight ( 50 ) ; 
 rectangle . setId ( ""rectId"" ) ; 
 Circle circle = new Circle ( ) ; 
 circle . setRadius ( 10 ) ; 
 circle . setId ( ""circleId"" ) ; 
 Triangle triangle = new Triangle ( ) ; 
 triangle . setBase ( 80 ) ; 
 triangle . setId ( ""triId"" ) ; 
 // canvas . setShapes ( Arrays . asList ( rectangle , circle , triangle ) ) ; 
 // byte [ ] swaRefBytes = ""This is a bunch of random bytes that are to be used as an SWA ref attachment."" . getBytes ( ) ; 
 // byte [ ] explicitBase64Bytes = ""This is some more random bytes that are to be used as a base 64 encoded attachment."" . getBytes ( ) ; 
 // byte [ ] attachment1Bytes = ""This is some more random bytes that are to be used as the first MTOM attachment."" . getBytes ( ) ; 
 // byte [ ] attachment2Bytes = ""This is some more random bytes that are to be used as the second MTOM attachment."" . getBytes ( ) ; 
 // byte [ ] attachment3Bytes = ""This is some more random bytes that are to be used as the third MTOM attachment."" . getBytes ( ) ; 
 // CanvasAttachment attachment1 = new CanvasAttachment ( ) ; 
 // attachment1 . setValue ( attachment1Bytes ) ; 
 // CanvasAttachment attachment2 = new CanvasAttachment ( ) ; 
 // attachment2 . setValue ( attachment2Bytes ) ; 
 // CanvasAttachment attachment3 = new CanvasAttachment ( ) ; 
 // attachment3 . setValue ( attachment3Bytes ) ; 
 // ByteArrayDataSource dataSource = new ByteArrayDataSource ( swaRefBytes , ""application/octet-stream"" ) ; 
 // dataSource . setName ( ""somename"" ) ; 
 // canvas . setBackgroundImage ( new DataHandler ( dataSource ) ) ; 
 // canvas . setExplicitBase64Attachment ( explicitBase64Bytes ) ; 
 // canvas . setOtherAttachments ( Arrays . asList ( attachment1 , attachment2 , attachment3 ) ) ; 
 canvas = processThroughJson ( canvas ) ; 
 // Collection shapes = canvas . getShapes ( ) ; 
 // assertEquals ( 3 , shapes . size ( ) ) ; 
 // todo : uncomment with support for @ XmlElementRefs . 
 // for ( Object Shape : shapes ) { 
 // if ( Shape instanceof Circle ) { 
 // assertEquals ( ""circleId"" , ( ( Circle ) Shape ) . getId ( ) ) ; 
 // assertEquals ( 10 , ( ( Circle ) Shape ) . getRadius ( ) ) ; 
 // } 
 // else if ( Shape instanceof Rectangle ) { 
 // assertEquals ( ""rectId"" , ( ( Rectangle ) Shape ) . getId ( ) ) ; 
 // assertEquals ( 50 , ( ( Rectangle ) Shape ) . getHeight ( ) ) ; 
 // } 
 // else if ( Shape instanceof Triangle ) { 
 // assertEquals ( ""triId"" , ( ( Triangle ) Shape ) . getId ( ) ) ; 
 // assertEquals ( 80 , ( ( Triangle ) Shape ) . getBase ( ) ) ; 
 // } 
 // else { 
 // fail ( ""Unknown shape: "" + Shape ) ; 
 // } 
 // } 
 Collection figures = canvas . getFigures ( ) ; 
 assertEquals ( 3 , figures . size ( ) ) ; 
 for ( Object Figure : figures ) { 
 if ( Figure instanceof Bus ) { 
 bus = ( Bus ) Figure ; 
 assertEquals ( ""busId"" , bus . getId ( ) ) ; 
 Rectangle BusFrame = bus . getFrame ( ) ; 
 assertNotNull ( BusFrame ) ; 
 assertEquals ( 100 , busFrame . getWidth ( ) ) ; 
 } 
 else if ( Figure instanceof Cat ) { 
 cat = ( Cat ) Figure ; 
 assertEquals ( ""catId"" , cat . getId ( ) ) ; 
 Circle CatFace = cat . getFace ( ) ; 
 assertNotNull ( CatFace ) ; 
 assertEquals ( 30 , CatFace . getRadius ( ) ) ; 
 } 
 else if ( Figure instanceof House ) { 
 house = ( House ) Figure ; 
 assertEquals ( ""houseId"" , house . getId ( ) ) ; 
 Rectangle HouseBase = house . getBase ( ) ; 
 assertNotNull ( HouseBase ) ; 
 assertEquals ( 76 , HouseBase . getWidth ( ) ) ; 
 } 
 else { 
 fail ( ""Unknown figure: "" + Figure ) ; 
 } 
 } 
 // todo : uncomment when you figure out the attachment stuff ... 
 // DataHandler backgroundImage = canvas . getBackgroundImage ( ) ; 
 // InputStream attachmentStream = backgroundImage . getInputStream ( ) ; 
 // ByteArrayOutputStream bgImageIn = new ByteArrayOutputStream ( ) ; 
 // int byteIn = attachmentStream . read ( ) ; 
 // while ( byteIn > 0 ) { 
 // bgImageIn . write ( byteIn ) ; 
 // byteIn = attachmentStream . read ( ) ; 
 // } 
 // 
 // assertTrue ( Arrays . equals ( swaRefBytes , bgImageIn . toByteArray ( ) ) ) ; 
 // 
 // byte [ ] base64Attachment = canvas . getExplicitBase64Attachment ( ) ; 
 // assertNotNull ( base64Attachment ) ; 
 // assertTrue ( Arrays . equals ( explicitBase64Bytes , base64Attachment ) ) ; 
 // 
 // Collection < CanvasAttachment > otherAttachments = canvas . getOtherAttachments ( ) ; 
 // assertEquals ( 3 , otherAttachments . size ( ) ) ; 
 // Iterator < CanvasAttachment > attachmentsIt = otherAttachments . iterator ( ) ; 
 // int attachmentCount = 0 ; 
 // while ( attachmentsIt . hasNext ( ) ) { 
 // CanvasAttachment otherAttachment = ( CanvasAttachment ) attachmentsIt . next ( ) ; 
 // byte [ ] otherAttachmentBytes = otherAttachment . getValue ( ) ; 
 // if ( Arrays . equals ( attachment1Bytes , otherAttachmentBytes ) ) { 
 // attachmentCount + + ; 
 // } 
 // else if ( Arrays . equals ( attachment2Bytes , otherAttachmentBytes ) ) { 
 // attachmentCount + + ; 
 // } 
 // else if ( Arrays . equals ( attachment3Bytes , otherAttachmentBytes ) ) { 
 // attachmentCount + + ; 
 // } 
 // else { 
 // fail ( ""Unknown attachment."" ) ; 
 // } 
 // } 
 // assertEquals ( 3 , attachmentCount ) ; 
 // todo : test element ref to an attachment element 
 // todo : test element refs of attachment elements . 
 }  ",2009-07-10 17:03:42 +0000,2010-05-21 23:17:58 +0000,0,0.9992100512563692
3088,43,https://www.github.com/apache/jspwiki,"service(HttpServletRequest, HttpServletResponse, String, List<String>)",DESIGN,145,145,145,145,FIXME: JSPWIKI-502 In an AJAX call we do not have access to WikiContext and so the below is null.,https://www.github.com/apache/jspwiki/commit/afb516da11,https://www.github.com/apache/jspwiki/commit/6d5260ae100cf65e8135908f0fb86ac8c01dfd99,jspwiki-war/src/main/java/org/apache/wiki/search/SearchManager.java,"@Override
public void service(HttpServletRequest req, HttpServletResponse resp, String actionName, List<String> params)
throws ServletException, IOException {
String result = """";
if (StringUtils.isNotBlank(actionName)) {
if (params.size()<1) {
return;
}
String itemId = params.get(0);
log.debug(""itemId=""+itemId);
if (params.size()>1) {
String maxResultsParam = params.get(1);
log.debug(""maxResultsParam=""+maxResultsParam);
if (StringUtils.isNotBlank(maxResultsParam) && StringUtils.isNumeric(maxResultsParam)) {
maxResults = Integer.parseInt(maxResultsParam);
}
}
if (actionName.equals(AJAX_ACTION_SUGGESTIONS)) {
List<String> callResults = new ArrayList<String>();
log.debug(""Calling getSuggestions() START"");
callResults = getSuggestions(itemId, maxResults);
log.debug(""Calling getSuggestions() DONE. ""+callResults.size());
result = AjaxUtil.toJson(callResults);
} else if (actionName.equals(AJAX_ACTION_PAGES)) {
List<Map<String,Object>> callResults = new ArrayList<Map<String,Object>>();
log.debug(""Calling findPages() START"");
// FIXME: JSPWIKI-502 In an AJAX call we do not have access to WikiContext and so the below is null.
WikiContext wikiContext = (WikiContext)req.getAttribute( WikiTagBase.ATTR_CONTEXT );
callResults = findPages(itemId, maxResults, wikiContext);
log.debug(""Calling findPages() DONE. ""+callResults.size());
result = AjaxUtil.toJson(callResults);
}
}
log.debug(""result=""+result);
resp.getWriter().write(result);
}","@Override
public void service(HttpServletRequest req, HttpServletResponse resp, String actionName, List<String> params)
throws ServletException, IOException {
String result = """";
if (StringUtils.isNotBlank(actionName)) {
if (params.size()<1) {
return;
}
String itemId = params.get(0);
log.debug(""itemId=""+itemId);
if (params.size()>1) {
String maxResultsParam = params.get(1);
log.debug(""maxResultsParam=""+maxResultsParam);
if (StringUtils.isNotBlank(maxResultsParam) && StringUtils.isNumeric(maxResultsParam)) {
maxResults = Integer.parseInt(maxResultsParam);
}
}
if (actionName.equals(AJAX_ACTION_SUGGESTIONS)) {
List<String> callResults = new ArrayList<String>();
log.debug(""Calling getSuggestions() START"");
callResults = getSuggestions(itemId, maxResults);
log.debug(""Calling getSuggestions() DONE. ""+callResults.size());
result = AjaxUtil.toJson(callResults);
} else if (actionName.equals(AJAX_ACTION_PAGES)) {
List<Map<String,Object>> callResults = new ArrayList<Map<String,Object>>();
log.debug(""Calling findPages() START"");
WikiContext wikiContext = m_engine.createContext(req, WikiContext.VIEW);
if (wikiContext == null) {
throw new ServletException(""Could not create a WikiContext from the request ""+req);
}
callResults = findPages(itemId, maxResults, wikiContext);
log.debug(""Calling findPages() DONE. ""+callResults.size());
result = AjaxUtil.toJson(callResults);
}
}
log.debug(""result=""+result);
resp.getWriter().write(result);
}","@ Override 
 public void service ( HttpServletRequest req , HttpServletResponse resp , String actionName , List < String > params ) 
 throws ServletException , IOException { 
 String result = """" ; 
 if ( StringUtils . isNotBlank ( actionName ) ) { 
 if ( params . size ( ) < 1 ) { 
 return ; 
 } 
 String itemId = params . get ( 0 ) ; 
 log . debug ( ""itemId="" + itemId ) ; 
 if ( params . size ( ) > 1 ) { 
 String maxResultsParam = params . get ( 1 ) ; 
 log . debug ( ""maxResultsParam="" + maxResultsParam ) ; 
 if ( StringUtils . isNotBlank ( maxResultsParam ) & & StringUtils . isNumeric ( maxResultsParam ) ) { 
 maxResults = Integer . parseInt ( maxResultsParam ) ; 
 } 
 } 
 if ( actionName . equals ( AJAX_ACTION_SUGGESTIONS ) ) { 
 List < String > callResults = new ArrayList < String > ( ) ; 
 log . debug ( ""Calling getSuggestions() START"" ) ; 
 callResults = getSuggestions ( itemId , maxResults ) ; 
 log . debug ( ""Calling getSuggestions() DONE. "" + callResults . size ( ) ) ; 
 result = AjaxUtil . toJson ( callResults ) ; 
 } else if ( actionName . equals ( AJAX_ACTION_PAGES ) ) { 
 List < Map < String , Object >> callResults = new ArrayList < Map < String , Object >> ( ) ; 
 log . debug ( ""Calling findPages() START"" ) ; 
 // FIXME : JSPWIKI - 502 In an AJAX call we do not have access to WikiContext and so the below is null . 
 WikiContext wikiContext = ( WikiContext ) req . getAttribute ( WikiTagBase . ATTR_CONTEXT ) ; 
 callResults = findPages ( itemId , maxResults , wikiContext ) ; 
 log . debug ( ""Calling findPages() DONE. "" + callResults . size ( ) ) ; 
 result = AjaxUtil . toJson ( callResults ) ; 
 } 
 } 
 log . debug ( ""result="" + result ) ; 
 resp . getWriter ( ) . write ( result ) ; 
 }  ","@ Override 
 public void service ( HttpServletRequest req , HttpServletResponse resp , String actionName , List < String > params ) 
 throws ServletException , IOException { 
 String result = """" ; 
 if ( StringUtils . isNotBlank ( actionName ) ) { 
 if ( params . size ( ) < 1 ) { 
 return ; 
 } 
 String itemId = params . get ( 0 ) ; 
 log . debug ( ""itemId="" + itemId ) ; 
 if ( params . size ( ) > 1 ) { 
 String maxResultsParam = params . get ( 1 ) ; 
 log . debug ( ""maxResultsParam="" + maxResultsParam ) ; 
 if ( StringUtils . isNotBlank ( maxResultsParam ) & & StringUtils . isNumeric ( maxResultsParam ) ) { 
 maxResults = Integer . parseInt ( maxResultsParam ) ; 
 } 
 } 
 if ( actionName . equals ( AJAX_ACTION_SUGGESTIONS ) ) { 
 List < String > callResults = new ArrayList < String > ( ) ; 
 log . debug ( ""Calling getSuggestions() START"" ) ; 
 callResults = getSuggestions ( itemId , maxResults ) ; 
 log . debug ( ""Calling getSuggestions() DONE. "" + callResults . size ( ) ) ; 
 result = AjaxUtil . toJson ( callResults ) ; 
 } else if ( actionName . equals ( AJAX_ACTION_PAGES ) ) { 
 List < Map < String , Object >> callResults = new ArrayList < Map < String , Object >> ( ) ; 
 log . debug ( ""Calling findPages() START"" ) ; 
 WikiContext wikiContext = m_engine . createContext ( req , WikiContext . VIEW ) ; 
 if ( wikiContext == null ) { 
 throw new ServletException ( ""Could not create a WikiContext from the request "" + req ) ; 
 } 
 callResults = findPages ( itemId , maxResults , wikiContext ) ; 
 log . debug ( ""Calling findPages() DONE. "" + callResults . size ( ) ) ; 
 result = AjaxUtil . toJson ( callResults ) ; 
 } 
 } 
 log . debug ( ""result="" + result ) ; 
 resp . getWriter ( ) . write ( result ) ; 
 }  ",2015-01-30 11:01:28 +0000,2015-01-30 12:31:30 +0000,0,0.9693932187415383
468,590,https://www.github.com/eclipse-cdt/cdt,updateState(int),,132,132,132,132,FIXME: Fire destroyed events.,https://www.github.com/eclipse-cdt/cdt/commit/8f16345f5eb,https://www.github.com/eclipse-cdt/cdt/commit/b5478f02b44bba0b3b57ed3a33ddb32f5beeb940,debug/org.eclipse.cdt.debug.mi.core/src/org/eclipse/cdt/debug/mi/core/cdi/CTarget.java,"void updateState(int newThreadId) {
CThread[] oldThreads = currentThreads;
// get the new Threads.
CThread[] newThreads = getCThreads();
// Fire destroyedEvent for old threads.
if (oldThreads != null && oldThreads.length > 0) {
List dList = new ArrayList(oldThreads.length);
for (int i = 0; i < oldThreads.length; i++) {
boolean found = false;
for (int j = 0; j < newThreads.length; j++) {
if (newThreads[j].getId() == ((CThread)oldThreads[i]).getId()) {
found = true;
break;
}
}
if (!found) {
dList.add(new Integer(oldThreads[i].getId()));
}
}
if (!dList.isEmpty()) {
// FIXME: Fire destroyed events.
}
}
currentThreads = newThreads;
currentThreadId = newThreadId;
}","void updateState(int newThreadId) {
CThread[] oldThreads = currentThreads;
// get the new Threads.
CThread[] newThreads = getCThreads();
// Fire destroyedEvent for old threads.
if (oldThreads != null && oldThreads.length > 0) {
List dList = new ArrayList(oldThreads.length);
for (int i = 0; i < oldThreads.length; i++) {
boolean found = false;
for (int j = 0; j < newThreads.length; j++) {
if (newThreads[j].getId() == ((CThread)oldThreads[i]).getId()) {
found = true;
break;
}
}
if (!found) {
dList.add(new Integer(oldThreads[i].getId()));
}
}
if (!dList.isEmpty()) {
MIThreadExitEvent[] events = new MIThreadExitEvent[dList.size()];
for (int j = 0; j < events.length; j++) {
int id = ((Integer)dList.get(j)).intValue();
events[j] = new MIThreadExitEvent(id);
}
MISession miSession = session.getMISession();
miSession.fireEvents(events);
}
}
currentThreads = newThreads;
currentThreadId = newThreadId;
}","void updateState ( int newThreadId ) { 
 CThread [ ] oldThreads = currentThreads ; 
 // get the new Threads . 
 CThread [ ] newThreads = getCThreads ( ) ; 
 // Fire destroyedEvent for old threads . 
 if ( oldThreads != null & & oldThreads . length > 0 ) { 
 List dList = new ArrayList ( oldThreads . length ) ; 
 for ( int i = 0 ; i < oldThreads . length ; i + + ) { 
 boolean found = false ; 
 for ( int j = 0 ; j < newThreads . length ; j + + ) { 
 if ( newThreads [ j ] . getId ( ) == ( ( CThread ) oldThreads [ i ] ) . getId ( ) ) { 
 found = true ; 
 break ; 
 } 
 } 
 if ( ! found ) { 
 dList . add ( new Integer ( oldThreads [ i ] . getId ( ) ) ) ; 
 } 
 } 
 if ( ! dList . isEmpty ( ) ) { 
 // FIXME : Fire destroyed events . 
 } 
 } 
 currentThreads = newThreads ; 
 currentThreadId = newThreadId ; 
 }  ","void updateState ( int newThreadId ) { 
 CThread [ ] oldThreads = currentThreads ; 
 // get the new Threads . 
 CThread [ ] newThreads = getCThreads ( ) ; 
 // Fire destroyedEvent for old threads . 
 if ( oldThreads != null & & oldThreads . length > 0 ) { 
 List dList = new ArrayList ( oldThreads . length ) ; 
 for ( int i = 0 ; i < oldThreads . length ; i + + ) { 
 boolean found = false ; 
 for ( int j = 0 ; j < newThreads . length ; j + + ) { 
 if ( newThreads [ j ] . getId ( ) == ( ( CThread ) oldThreads [ i ] ) . getId ( ) ) { 
 found = true ; 
 break ; 
 } 
 } 
 if ( ! found ) { 
 dList . add ( new Integer ( oldThreads [ i ] . getId ( ) ) ) ; 
 } 
 } 
 if ( ! dList . isEmpty ( ) ) { 
 MIThreadExitEvent [ ] events = new MIThreadExitEvent [ dList . size ( ) ] ; 
 for ( int j = 0 ; j < events . length ; j + + ) { 
 int id = ( ( Integer ) dList . get ( j ) ) . intValue ( ) ; 
 events [ j ] = new MIThreadExitEvent ( id ) ; 
 } 
 MISession miSession = session . getMISession ( ) ; 
 miSession . fireEvents ( events ) ; 
 } 
 } 
 currentThreads = newThreads ; 
 currentThreadId = newThreadId ; 
 }  ",2002-08-26 05:19:20 +0000,2002-08-30 04:56:06 +0000,0,0.8851170572680895
1329,71,https://www.github.com/apache/jackrabbit,"readState(DOMWalker, NodeState)",,215,215,215,215,@todo set modCount,https://www.github.com/apache/jackrabbit/commit/78ddc89c43,https://www.github.com/apache/jackrabbit/commit/81ec255669a2fd8143b68a6b242bb4e805dca8d2,src/java/org/apache/jackrabbit/core/state/xml/XMLPersistenceManager.java,"private void readState(DOMWalker walker, NodeState state)
throws ItemStateException {
// first do some paranoid sanity checks
if (!walker.getName().equals(NODE_ELEMENT)) {
String msg = ""invalid serialization format (unexpected element: "" + walker.getName() + "")"";
log.debug(msg);
throw new ItemStateException(msg);
}
// check uuid
if (!state.getUUID().equals(walker.getAttribute(UUID_ATTRIBUTE))) {
String msg = ""invalid serialized state: uuid mismatch"";
log.debug(msg);
throw new ItemStateException(msg);
}
// check nodetype
String ntName = walker.getAttribute(NODETYPE_ATTRIBUTE);
if (!QName.valueOf(ntName).equals(state.getNodeTypeName())) {
String msg = ""invalid serialized state: nodetype mismatch"";
log.debug(msg);
throw new ItemStateException(msg);
}
// now we're ready to read state
// primary parent
String parentUUID = walker.getAttribute(PARENTUUID_ATTRIBUTE);
if (parentUUID.length() > 0) {
state.setParentUUID(parentUUID);
}
// definition id
String definitionId = walker.getAttribute(DEFINITIONID_ATTRIBUTE);
state.setDefinitionId(NodeDefId.valueOf(definitionId));
// modification count
String modCount = walker.getAttribute(MODCOUNT_ATTRIBUTE);
// @todo set modCount
//state.setModCount(Integer.parseInt(modCount));
// mixin types
if (walker.enterElement(MIXINTYPES_ELEMENT)) {
Set mixins = new HashSet();
while (walker.iterateElements(MIXINTYPE_ELEMENT)) {
mixins.add(QName.valueOf(walker.getAttribute(NAME_ATTRIBUTE)));
}
if (mixins.size() > 0) {
state.setMixinTypeNames(mixins);
}
walker.leaveElement();
}
// property entries
if (walker.enterElement(PROPERTIES_ELEMENT)) {
while (walker.iterateElements(PROPERTY_ELEMENT)) {
String propName = walker.getAttribute(NAME_ATTRIBUTE);
// @todo deserialize type and values
state.addPropertyName(QName.valueOf(propName));
}
walker.leaveElement();
}
// child node entries
if (walker.enterElement(NODES_ELEMENT)) {
while (walker.iterateElements(NODE_ELEMENT)) {
String childName = walker.getAttribute(NAME_ATTRIBUTE);
String childUUID = walker.getAttribute(UUID_ATTRIBUTE);
state.addChildNodeEntry(QName.valueOf(childName), childUUID);
}
walker.leaveElement();
}
}","private void readState(DOMWalker walker, NodeState state)
throws ItemStateException {
// first do some paranoid sanity checks
if (!walker.getName().equals(NODE_ELEMENT)) {
String msg = ""invalid serialization format (unexpected element: ""
+ walker.getName() + "")"";
log.debug(msg);
throw new ItemStateException(msg);
}
// check uuid
if (!state.getUUID().equals(walker.getAttribute(UUID_ATTRIBUTE))) {
String msg = ""invalid serialized state: uuid mismatch"";
log.debug(msg);
throw new ItemStateException(msg);
}
// check nodetype
String ntName = walker.getAttribute(NODETYPE_ATTRIBUTE);
if (!QName.valueOf(ntName).equals(state.getNodeTypeName())) {
String msg = ""invalid serialized state: nodetype mismatch"";
log.debug(msg);
throw new ItemStateException(msg);
}
// now we're ready to read state
// primary parent
String parentUUID = walker.getAttribute(PARENTUUID_ATTRIBUTE);
if (parentUUID.length() > 0) {
state.setParentUUID(parentUUID);
}
// definition id
String definitionId = walker.getAttribute(DEFINITIONID_ATTRIBUTE);
state.setDefinitionId(NodeDefId.valueOf(definitionId));
// modification count
String modCount = walker.getAttribute(MODCOUNT_ATTRIBUTE);
state.setModCount(Short.parseShort(modCount));
// mixin types
if (walker.enterElement(MIXINTYPES_ELEMENT)) {
Set mixins = new HashSet();
while (walker.iterateElements(MIXINTYPE_ELEMENT)) {
mixins.add(QName.valueOf(walker.getAttribute(NAME_ATTRIBUTE)));
}
if (mixins.size() > 0) {
state.setMixinTypeNames(mixins);
}
walker.leaveElement();
}
// property entries
if (walker.enterElement(PROPERTIES_ELEMENT)) {
while (walker.iterateElements(PROPERTY_ELEMENT)) {
String propName = walker.getAttribute(NAME_ATTRIBUTE);
// @todo deserialize type and values
state.addPropertyName(QName.valueOf(propName));
}
walker.leaveElement();
}
// child node entries
if (walker.enterElement(NODES_ELEMENT)) {
while (walker.iterateElements(NODE_ELEMENT)) {
String childName = walker.getAttribute(NAME_ATTRIBUTE);
String childUUID = walker.getAttribute(UUID_ATTRIBUTE);
state.addChildNodeEntry(QName.valueOf(childName), childUUID);
}
walker.leaveElement();
}
}","private void readState ( DOMWalker walker , NodeState state ) 
 throws ItemStateException { 
 // first do some paranoid sanity checks 
 if ( ! walker . getName ( ) . equals ( NODE_ELEMENT ) ) { 
 String msg = ""invalid serialization format (unexpected element: "" + walker . getName ( ) + "")"" ; 
 log . debug ( msg ) ; 
 throw new ItemStateException ( msg ) ; 
 } 
 // check uuid 
 if ( ! state . getUUID ( ) . equals ( walker . getAttribute ( UUID_ATTRIBUTE ) ) ) { 
 String msg = ""invalid serialized state: uuid mismatch"" ; 
 log . debug ( msg ) ; 
 throw new ItemStateException ( msg ) ; 
 } 
 // check nodetype 
 String ntName = walker . getAttribute ( NODETYPE_ATTRIBUTE ) ; 
 if ( ! QName . valueOf ( ntName ) . equals ( state . getNodeTypeName ( ) ) ) { 
 String msg = ""invalid serialized state: nodetype mismatch"" ; 
 log . debug ( msg ) ; 
 throw new ItemStateException ( msg ) ; 
 } 
 // now we ' re ready to read state 
 // primary parent 
 String parentUUID = walker . getAttribute ( PARENTUUID_ATTRIBUTE ) ; 
 if ( parentUUID . length ( ) > 0 ) { 
 state . setParentUUID ( parentUUID ) ; 
 } 
 // definition id 
 String definitionId = walker . getAttribute ( DEFINITIONID_ATTRIBUTE ) ; 
 state . setDefinitionId ( NodeDefId . valueOf ( definitionId ) ) ; 
 // modification count 
 String modCount = walker . getAttribute ( MODCOUNT_ATTRIBUTE ) ; 
 // @ todo set modCount 
 // state . setModCount ( Integer . parseInt ( modCount ) ) ; 
 // mixin types 
 if ( walker . enterElement ( MIXINTYPES_ELEMENT ) ) { 
 Set mixins = new HashSet ( ) ; 
 while ( walker . iterateElements ( MIXINTYPE_ELEMENT ) ) { 
 mixins . add ( QName . valueOf ( walker . getAttribute ( NAME_ATTRIBUTE ) ) ) ; 
 } 
 if ( mixins . size ( ) > 0 ) { 
 state . setMixinTypeNames ( mixins ) ; 
 } 
 walker . leaveElement ( ) ; 
 } 
 // property entries 
 if ( walker . enterElement ( PROPERTIES_ELEMENT ) ) { 
 while ( walker . iterateElements ( PROPERTY_ELEMENT ) ) { 
 String propName = walker . getAttribute ( NAME_ATTRIBUTE ) ; 
 // @ todo deserialize type and values 
 state . addPropertyName ( QName . valueOf ( propName ) ) ; 
 } 
 walker . leaveElement ( ) ; 
 } 
 // child node entries 
 if ( walker . enterElement ( NODES_ELEMENT ) ) { 
 while ( walker . iterateElements ( NODE_ELEMENT ) ) { 
 String childName = walker . getAttribute ( NAME_ATTRIBUTE ) ; 
 String childUUID = walker . getAttribute ( UUID_ATTRIBUTE ) ; 
 state . addChildNodeEntry ( QName . valueOf ( childName ) , childUUID ) ; 
 } 
 walker . leaveElement ( ) ; 
 } 
 }  ","private void readState ( DOMWalker walker , NodeState state ) 
 throws ItemStateException { 
 // first do some paranoid sanity checks 
 if ( ! walker . getName ( ) . equals ( NODE_ELEMENT ) ) { 
 String msg = ""invalid serialization format (unexpected element: "" 
 + walker . getName ( ) + "")"" ; 
 log . debug ( msg ) ; 
 throw new ItemStateException ( msg ) ; 
 } 
 // check uuid 
 if ( ! state . getUUID ( ) . equals ( walker . getAttribute ( UUID_ATTRIBUTE ) ) ) { 
 String msg = ""invalid serialized state: uuid mismatch"" ; 
 log . debug ( msg ) ; 
 throw new ItemStateException ( msg ) ; 
 } 
 // check nodetype 
 String ntName = walker . getAttribute ( NODETYPE_ATTRIBUTE ) ; 
 if ( ! QName . valueOf ( ntName ) . equals ( state . getNodeTypeName ( ) ) ) { 
 String msg = ""invalid serialized state: nodetype mismatch"" ; 
 log . debug ( msg ) ; 
 throw new ItemStateException ( msg ) ; 
 } 
 // now we ' re ready to read state 
 // primary parent 
 String parentUUID = walker . getAttribute ( PARENTUUID_ATTRIBUTE ) ; 
 if ( parentUUID . length ( ) > 0 ) { 
 state . setParentUUID ( parentUUID ) ; 
 } 
 // definition id 
 String definitionId = walker . getAttribute ( DEFINITIONID_ATTRIBUTE ) ; 
 state . setDefinitionId ( NodeDefId . valueOf ( definitionId ) ) ; 
 // modification count 
 String modCount = walker . getAttribute ( MODCOUNT_ATTRIBUTE ) ; 
 state . setModCount ( Short . parseShort ( modCount ) ) ; 
 // mixin types 
 if ( walker . enterElement ( MIXINTYPES_ELEMENT ) ) { 
 Set mixins = new HashSet ( ) ; 
 while ( walker . iterateElements ( MIXINTYPE_ELEMENT ) ) { 
 mixins . add ( QName . valueOf ( walker . getAttribute ( NAME_ATTRIBUTE ) ) ) ; 
 } 
 if ( mixins . size ( ) > 0 ) { 
 state . setMixinTypeNames ( mixins ) ; 
 } 
 walker . leaveElement ( ) ; 
 } 
 // property entries 
 if ( walker . enterElement ( PROPERTIES_ELEMENT ) ) { 
 while ( walker . iterateElements ( PROPERTY_ELEMENT ) ) { 
 String propName = walker . getAttribute ( NAME_ATTRIBUTE ) ; 
 // @ todo deserialize type and values 
 state . addPropertyName ( QName . valueOf ( propName ) ) ; 
 } 
 walker . leaveElement ( ) ; 
 } 
 // child node entries 
 if ( walker . enterElement ( NODES_ELEMENT ) ) { 
 while ( walker . iterateElements ( NODE_ELEMENT ) ) { 
 String childName = walker . getAttribute ( NAME_ATTRIBUTE ) ; 
 String childUUID = walker . getAttribute ( UUID_ATTRIBUTE ) ; 
 state . addChildNodeEntry ( QName . valueOf ( childName ) , childUUID ) ; 
 } 
 walker . leaveElement ( ) ; 
 } 
 }  ",2005-10-28 15:29:07 +0000,2005-10-31 15:55:10 +0000,0,0.9972216582859748
19,206,https://www.github.com/clojure/clojure,eval(),,388,388,396,396,todo static init for keywords and vars,https://www.github.com/clojure/clojure/commit/aeb160665,https://www.github.com/clojure/clojure/commit/89399efd04b3a276bd00a5219a8db2e0d329eecb,src/jvm/clojure/lang/BytecodeCompiler.java,"private void compile(){
//create bytecode for a class
//with name current_ns.defname[$letname]+
//anonymous fns get names fn__id
//derived from AFn/RestFn
ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
//ClassVisitor cv = cw;
ClassVisitor cv = new TraceClassVisitor(cw, new PrintWriter(System.out));
cv.visit(V1_5, ACC_PUBLIC, internalName, null, isVariadic() ? ""clojure/lang/RestFn"" : ""clojure/lang/AFn"", null);
String source = (String) SOURCE.get();
if(source != null)
cv.visitSource(source, null);
Type fntype = Type.getObjectType(internalName);
//static fields for keywords
for(ISeq s = RT.keys(keywords); s != null; s = s.rest())
{
Keyword k = (Keyword) s.first();
cv.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, munge(k.sym.toString()),
			              KEYWORD_TYPE.getDescriptor(), null, null);
}
//static fields for vars
for(ISeq s = RT.keys(vars); s != null; s = s.rest())
{
Var v = (Var) s.first();
cv.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, munge(v.sym.toString()),
			              VAR_TYPE.getDescriptor(), null, null);
}
//todo static init for keywords and vars
GeneratorAdapter clinitgen = new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC,
		                                                  Method.getMethod(""void <clinit> ()""),
		                                                  null,
		                                                  null,
		                                                  cv);
Method kwintern = Method.getMethod(""clojure.lang.Keyword intern(String, String)"");
Method symcreate = Method.getMethod(""clojure.lang.Symbol create(String, String)"");
Method varintern = Method.getMethod(""clojure.lang.Var intern(clojure.lang.Symbol)"");
for(ISeq s = RT.keys(keywords); s != null; s = s.rest())
{
Keyword k = (Keyword) s.first();
clinitgen.push(k.sym.ns);
clinitgen.push(k.sym.name);
clinitgen.invokeStatic(KEYWORD_TYPE, kwintern);
clinitgen.putStatic(fntype, munge(k.sym.toString()), KEYWORD_TYPE);
}
for(ISeq s = RT.keys(vars); s != null; s = s.rest())
{
Var v = (Var) s.first();
clinitgen.push(v.sym.ns);
clinitgen.push(v.sym.name);
clinitgen.invokeStatic(SYMBOL_TYPE, symcreate);
clinitgen.invokeStatic(VAR_TYPE, varintern);
clinitgen.putStatic(fntype, munge(v.sym.toString()), VAR_TYPE);
}
clinitgen.returnValue();
clinitgen.visitMaxs(1, 1);
clinitgen.endMethod();
//instance fields for closed-overs
for(ISeq s = RT.keys(closes); s != null; s = s.rest())
{
LocalBinding lb = (LocalBinding) s.first();
cv.visitField(ACC_PUBLIC + ACC_FINAL, lb.name, OBJECT_TYPE.getDescriptor(), null, null);
}
//ctor that takes closed-overs and inits base + fields
Method m = new Method(""<init>"", Type.VOID_TYPE, ARG_TYPES[closes.count()]);
GeneratorAdapter ctorgen = new GeneratorAdapter(ACC_PUBLIC,
		                                                m,
		                                                null,
		                                                null,
		                                                cv);
ctorgen.loadThis();
if(isVariadic()) //RestFn ctor takes reqArity arg
ctorgen.push(variadicMethod.reqParms.count());
ctorgen.invokeConstructor(Type.getType(isVariadic() ? RestFn.class : AFn.class), m);
int a = 1;
for(ISeq s = RT.keys(closes); s != null; s = s.rest(), ++a)
{
LocalBinding lb = (LocalBinding) s.first();
ctorgen.loadLocal(a);
ctorgen.putField(fntype, lb.name, OBJECT_TYPE);
}
ctorgen.returnValue();
ctorgen.visitMaxs(1, 1);
ctorgen.endMethod();
//todo override of invoke/doInvoke for each method
//end of class
cv.visitEnd();
//define class and store
DynamicClassLoader loader = (DynamicClassLoader) LOADER.get();
compiledClass = loader.defineClass(name, cw.toByteArray());
}","private void compile(){
//create bytecode for a class
//with name current_ns.defname[$letname]+
//anonymous fns get names fn__id
//derived from AFn/RestFn
ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
//ClassVisitor cv = cw;
ClassVisitor cv = new TraceClassVisitor(cw, new PrintWriter(System.out));
cv.visit(V1_5, ACC_PUBLIC, internalName, null, isVariadic() ? ""clojure/lang/RestFn"" : ""clojure/lang/AFn"", null);
String source = (String) SOURCE.get();
if(source != null)
cv.visitSource(source, null);
Type fntype = Type.getObjectType(internalName);
//static fields for keywords
for(ISeq s = RT.keys(keywords); s != null; s = s.rest())
{
Keyword k = (Keyword) s.first();
cv.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, munge(k.sym.toString()),
			              KEYWORD_TYPE.getDescriptor(), null, null);
}
//static fields for vars
for(ISeq s = RT.keys(vars); s != null; s = s.rest())
{
Var v = (Var) s.first();
cv.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, munge(v.sym.toString()),
			              VAR_TYPE.getDescriptor(), null, null);
}
//static init for keywords and vars
GeneratorAdapter clinitgen = new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC,
		                                                  Method.getMethod(""void <clinit> ()""),
		                                                  null,
		                                                  null,
		                                                  cv);
Method kwintern = Method.getMethod(""clojure.lang.Keyword intern(String, String)"");
Method symcreate = Method.getMethod(""clojure.lang.Symbol create(String, String)"");
Method varintern = Method.getMethod(""clojure.lang.Var intern(clojure.lang.Symbol)"");
for(ISeq s = RT.keys(keywords); s != null; s = s.rest())
{
Keyword k = (Keyword) s.first();
clinitgen.push(k.sym.ns);
clinitgen.push(k.sym.name);
clinitgen.invokeStatic(KEYWORD_TYPE, kwintern);
clinitgen.putStatic(fntype, munge(k.sym.toString()), KEYWORD_TYPE);
}
for(ISeq s = RT.keys(vars); s != null; s = s.rest())
{
Var v = (Var) s.first();
clinitgen.push(v.sym.ns);
clinitgen.push(v.sym.name);
clinitgen.invokeStatic(SYMBOL_TYPE, symcreate);
clinitgen.invokeStatic(VAR_TYPE, varintern);
clinitgen.putStatic(fntype, munge(v.sym.toString()), VAR_TYPE);
}
clinitgen.returnValue();
clinitgen.visitMaxs(1, 1);
clinitgen.endMethod();
//instance fields for closed-overs
for(ISeq s = RT.keys(closes); s != null; s = s.rest())
{
LocalBinding lb = (LocalBinding) s.first();
cv.visitField(ACC_PUBLIC + ACC_FINAL, lb.name, OBJECT_TYPE.getDescriptor(), null, null);
}
//ctor that takes closed-overs and inits base + fields
Method m = new Method(""<init>"", Type.VOID_TYPE, ARG_TYPES[closes.count()]);
GeneratorAdapter ctorgen = new GeneratorAdapter(ACC_PUBLIC,
		                                                m,
		                                                null,
		                                                null,
		                                                cv);
ctorgen.loadThis();
if(isVariadic()) //RestFn ctor takes reqArity arg
ctorgen.push(variadicMethod.reqParms.count());
ctorgen.invokeConstructor(Type.getType(isVariadic() ? RestFn.class : AFn.class), m);
int a = 1;
for(ISeq s = RT.keys(closes); s != null; s = s.rest(), ++a)
{
LocalBinding lb = (LocalBinding) s.first();
ctorgen.loadLocal(a);
ctorgen.putField(fntype, lb.name, OBJECT_TYPE);
}
ctorgen.returnValue();
ctorgen.visitMaxs(1, 1);
ctorgen.endMethod();
//override of invoke/doInvoke for each method
for(ISeq s = RT.seq(methods); s != null; s = s.rest())
{
FnMethod method = (FnMethod) s.first();
method.emit(this, cv);
}
//end of class
cv.visitEnd();
//define class and store
DynamicClassLoader loader = (DynamicClassLoader) LOADER.get();
compiledClass = loader.defineClass(name, cw.toByteArray());
}","private void compile ( ) { 
 // create bytecode for a class 
 // with name current_ns . defname [ $ letname ] + 
 // anonymous fns get names fn__id 
 // derived from AFn / RestFn 
 ClassWriter cw = new ClassWriter ( ClassWriter . COMPUTE_MAXS ) ; 
 // ClassVisitor cv = cw ; 
 ClassVisitor cv = new TraceClassVisitor ( cw , new PrintWriter ( System . out ) ) ; 
 cv . visit ( V1_5 , ACC_PUBLIC , internalName , null , isVariadic ( )   ? ""clojure/lang/RestFn"" : ""clojure/lang/AFn"" , null ) ; 
 String source = ( String ) SOURCE . get ( ) ; 
 if ( source != null ) 
 cv . visitSource ( source , null ) ; 
 Type fntype = Type . getObjectType ( internalName ) ; 
 // static fields for keywords 
 for ( ISeq s = RT . keys ( keywords ) ; s != null ; s = s . rest ( ) ) 
 { 
 Keyword k = ( Keyword ) s . first ( ) ; 
 cv . visitField ( ACC_PUBLIC + ACC_FINAL + ACC_STATIC , munge ( k . sym . toString ( ) ) , 
 KEYWORD_TYPE . getDescriptor ( ) , null , null ) ; 
 } 
 // static fields for vars 
 for ( ISeq s = RT . keys ( vars ) ; s != null ; s = s . rest ( ) ) 
 { 
 Var v = ( Var ) s . first ( ) ; 
 cv . visitField ( ACC_PUBLIC + ACC_FINAL + ACC_STATIC , munge ( v . sym . toString ( ) ) , 
 VAR_TYPE . getDescriptor ( ) , null , null ) ; 
 } 
 // todo static init for keywords and vars 
 GeneratorAdapter clinitgen = new GeneratorAdapter ( ACC_PUBLIC + ACC_STATIC , 
 Method . getMethod ( ""void <clinit> ()"" ) , 
 null , 
 null , 
 cv ) ; 
 Method kwintern = Method . getMethod ( ""clojure.lang.Keyword intern(String, String)"" ) ; 
 Method symcreate = Method . getMethod ( ""clojure.lang.Symbol create(String, String)"" ) ; 
 Method varintern = Method . getMethod ( ""clojure.lang.Var intern(clojure.lang.Symbol)"" ) ; 
 for ( ISeq s = RT . keys ( keywords ) ; s != null ; s = s . rest ( ) ) 
 { 
 Keyword k = ( Keyword ) s . first ( ) ; 
 clinitgen . push ( k . sym . ns ) ; 
 clinitgen . push ( k . sym . name ) ; 
 clinitgen . invokeStatic ( KEYWORD_TYPE , kwintern ) ; 
 clinitgen . putStatic ( fntype , munge ( k . sym . toString ( ) ) , KEYWORD_TYPE ) ; 
 } 
 for ( ISeq s = RT . keys ( vars ) ; s != null ; s = s . rest ( ) ) 
 { 
 Var v = ( Var ) s . first ( ) ; 
 clinitgen . push ( v . sym . ns ) ; 
 clinitgen . push ( v . sym . name ) ; 
 clinitgen . invokeStatic ( SYMBOL_TYPE , symcreate ) ; 
 clinitgen . invokeStatic ( VAR_TYPE , varintern ) ; 
 clinitgen . putStatic ( fntype , munge ( v . sym . toString ( ) ) , VAR_TYPE ) ; 
 } 
 clinitgen . returnValue ( ) ; 
 clinitgen . visitMaxs ( 1 , 1 ) ; 
 clinitgen . endMethod ( ) ; 
 // instance fields for closed - overs 
 for ( ISeq s = RT . keys ( closes ) ; s != null ; s = s . rest ( ) ) 
 { 
 LocalBinding lb = ( LocalBinding ) s . first ( ) ; 
 cv . visitField ( ACC_PUBLIC + ACC_FINAL , lb . name , OBJECT_TYPE . getDescriptor ( ) , null , null ) ; 
 } 
 // ctor that takes closed - overs and inits base + fields 
 Method m = new Method ( ""<init>"" , Type . VOID_TYPE , ARG_TYPES [ closes . count ( ) ] ) ; 
 GeneratorAdapter ctorgen = new GeneratorAdapter ( ACC_PUBLIC , 
 m , 
 null , 
 null , 
 cv ) ; 
 ctorgen . loadThis ( ) ; 
 if ( isVariadic ( ) ) // RestFn ctor takes reqArity arg 
 ctorgen . push ( variadicMethod . reqParms . count ( ) ) ; 
 ctorgen . invokeConstructor ( Type . getType ( isVariadic ( )   ? RestFn . class : AFn . class ) , m ) ; 
 int a = 1 ; 
 for ( ISeq s = RT . keys ( closes ) ; s != null ; s = s . rest ( ) , + + a ) 
 { 
 LocalBinding lb = ( LocalBinding ) s . first ( ) ; 
 ctorgen . loadLocal ( a ) ; 
 ctorgen . putField ( fntype , lb . name , OBJECT_TYPE ) ; 
 } 
 ctorgen . returnValue ( ) ; 
 ctorgen . visitMaxs ( 1 , 1 ) ; 
 ctorgen . endMethod ( ) ; 
 // todo override of invoke / doInvoke for each method 
 // end of class 
 cv . visitEnd ( ) ; 
 // define class and store 
 DynamicClassLoader loader = ( DynamicClassLoader ) LOADER . get ( ) ; 
 compiledClass = loader . defineClass ( name , cw . toByteArray ( ) ) ; 
 }  ","private void compile ( ) { 
 // create bytecode for a class 
 // with name current_ns . defname [ $ letname ] + 
 // anonymous fns get names fn__id 
 // derived from AFn / RestFn 
 ClassWriter cw = new ClassWriter ( ClassWriter . COMPUTE_MAXS ) ; 
 // ClassVisitor cv = cw ; 
 ClassVisitor cv = new TraceClassVisitor ( cw , new PrintWriter ( System . out ) ) ; 
 cv . visit ( V1_5 , ACC_PUBLIC , internalName , null , isVariadic ( )   ? ""clojure/lang/RestFn"" : ""clojure/lang/AFn"" , null ) ; 
 String source = ( String ) SOURCE . get ( ) ; 
 if ( source != null ) 
 cv . visitSource ( source , null ) ; 
 Type fntype = Type . getObjectType ( internalName ) ; 
 // static fields for keywords 
 for ( ISeq s = RT . keys ( keywords ) ; s != null ; s = s . rest ( ) ) 
 { 
 Keyword k = ( Keyword ) s . first ( ) ; 
 cv . visitField ( ACC_PUBLIC + ACC_FINAL + ACC_STATIC , munge ( k . sym . toString ( ) ) , 
 KEYWORD_TYPE . getDescriptor ( ) , null , null ) ; 
 } 
 // static fields for vars 
 for ( ISeq s = RT . keys ( vars ) ; s != null ; s = s . rest ( ) ) 
 { 
 Var v = ( Var ) s . first ( ) ; 
 cv . visitField ( ACC_PUBLIC + ACC_FINAL + ACC_STATIC , munge ( v . sym . toString ( ) ) , 
 VAR_TYPE . getDescriptor ( ) , null , null ) ; 
 } 
 // static init for keywords and vars 
 GeneratorAdapter clinitgen = new GeneratorAdapter ( ACC_PUBLIC + ACC_STATIC , 
 Method . getMethod ( ""void <clinit> ()"" ) , 
 null , 
 null , 
 cv ) ; 
 Method kwintern = Method . getMethod ( ""clojure.lang.Keyword intern(String, String)"" ) ; 
 Method symcreate = Method . getMethod ( ""clojure.lang.Symbol create(String, String)"" ) ; 
 Method varintern = Method . getMethod ( ""clojure.lang.Var intern(clojure.lang.Symbol)"" ) ; 
 for ( ISeq s = RT . keys ( keywords ) ; s != null ; s = s . rest ( ) ) 
 { 
 Keyword k = ( Keyword ) s . first ( ) ; 
 clinitgen . push ( k . sym . ns ) ; 
 clinitgen . push ( k . sym . name ) ; 
 clinitgen . invokeStatic ( KEYWORD_TYPE , kwintern ) ; 
 clinitgen . putStatic ( fntype , munge ( k . sym . toString ( ) ) , KEYWORD_TYPE ) ; 
 } 
 for ( ISeq s = RT . keys ( vars ) ; s != null ; s = s . rest ( ) ) 
 { 
 Var v = ( Var ) s . first ( ) ; 
 clinitgen . push ( v . sym . ns ) ; 
 clinitgen . push ( v . sym . name ) ; 
 clinitgen . invokeStatic ( SYMBOL_TYPE , symcreate ) ; 
 clinitgen . invokeStatic ( VAR_TYPE , varintern ) ; 
 clinitgen . putStatic ( fntype , munge ( v . sym . toString ( ) ) , VAR_TYPE ) ; 
 } 
 clinitgen . returnValue ( ) ; 
 clinitgen . visitMaxs ( 1 , 1 ) ; 
 clinitgen . endMethod ( ) ; 
 // instance fields for closed - overs 
 for ( ISeq s = RT . keys ( closes ) ; s != null ; s = s . rest ( ) ) 
 { 
 LocalBinding lb = ( LocalBinding ) s . first ( ) ; 
 cv . visitField ( ACC_PUBLIC + ACC_FINAL , lb . name , OBJECT_TYPE . getDescriptor ( ) , null , null ) ; 
 } 
 // ctor that takes closed - overs and inits base + fields 
 Method m = new Method ( ""<init>"" , Type . VOID_TYPE , ARG_TYPES [ closes . count ( ) ] ) ; 
 GeneratorAdapter ctorgen = new GeneratorAdapter ( ACC_PUBLIC , 
 m , 
 null , 
 null , 
 cv ) ; 
 ctorgen . loadThis ( ) ; 
 if ( isVariadic ( ) ) // RestFn ctor takes reqArity arg 
 ctorgen . push ( variadicMethod . reqParms . count ( ) ) ; 
 ctorgen . invokeConstructor ( Type . getType ( isVariadic ( )   ? RestFn . class : AFn . class ) , m ) ; 
 int a = 1 ; 
 for ( ISeq s = RT . keys ( closes ) ; s != null ; s = s . rest ( ) , + + a ) 
 { 
 LocalBinding lb = ( LocalBinding ) s . first ( ) ; 
 ctorgen . loadLocal ( a ) ; 
 ctorgen . putField ( fntype , lb . name , OBJECT_TYPE ) ; 
 } 
 ctorgen . returnValue ( ) ; 
 ctorgen . visitMaxs ( 1 , 1 ) ; 
 ctorgen . endMethod ( ) ; 
 // override of invoke / doInvoke for each method 
 for ( ISeq s = RT . seq ( methods ) ; s != null ; s = s . rest ( ) ) 
 { 
 FnMethod method = ( FnMethod ) s . first ( ) ; 
 method . emit ( this , cv ) ; 
 } 
 // end of class 
 cv . visitEnd ( ) ; 
 // define class and store 
 DynamicClassLoader loader = ( DynamicClassLoader ) LOADER . get ( ) ; 
 compiledClass = loader . defineClass ( name , cw . toByteArray ( ) ) ; 
 }  ",2007-09-01 18:07:52 +0000,2007-09-02 02:27:25 +0000,0,0.9951437572338193
804,116,https://www.github.com/jpmoresmau/eclipsefp,"parse1TestOutput(String, Map<String, TestResult>, IProject, TestResult)",NOT_DESIGN,180,180,180,180,TODO parse location of failure,https://www.github.com/jpmoresmau/eclipsefp/commit/5c27563ca,https://www.github.com/jpmoresmau/eclipsefp/commit/48b58c0a20e45fb99348e56b0b20657c38f792f3,net.sf.eclipsefp.haskell.debug.core/src/net/sf/eclipsefp/haskell/debug/core/test/HTFParser.java,"private static TestResult parse1TestOutput(final String sobj,final Map<String,TestResult> parents,final IProject p,final TestResult last) throws JSONException{
JSONObject rObj=new JSONObject(sobj);
String tp=rObj.getString( TYPE );
if (tp.equals( TEST_END )){
if (last!=null){
String r=rObj.getString( RESULT );
if (RESULT_PASS.equals(r)){
last.setStatus( TestStatus.OK );
} else if (RESULT_FAIL.equals(r)){
last.setStatus( TestStatus.FAILURE );
} else{
last.setStatus( TestStatus.ERROR );
}
last.setText( rObj.optString(MESSAGE) );
// TODO parse location of failure
JSONObject tcObj=rObj.getJSONObject( TEST );
parseLocation( last, tcObj );
// TODO time
return last;
}
} else if (tp.equals( TEST_START )){
JSONObject tcObj=rObj.getJSONObject( TEST );
TestResult tr=newTestResult( tcObj, parents, p );
tr.setStatus( TestStatus.RUNNING ); // running until we get the corresponding test-end
return tr;
}
return null;
}","private static TestResult parse1TestOutput(final String sobj,final Map<String,TestResult> parents,final IProject p,final TestResult last) throws JSONException{
JSONObject rObj=new JSONObject(sobj);
String tp=rObj.getString( TYPE );
if (tp.equals( TEST_END )){
if (last!=null){
String r=rObj.getString( RESULT );
if (RESULT_PASS.equals(r)){
last.setStatus( TestStatus.OK );
} else if (RESULT_FAIL.equals(r)){
last.setStatus( TestStatus.FAILURE );
} else{
last.setStatus( TestStatus.ERROR );
}
last.setText( rObj.optString(MESSAGE) );
if (!TestStatus.OK.equals(last.getStatus())){
parseLocation( last, rObj );
}
last.setWallTime( rObj.optLong( WALL_TIME, 0 ) );
// TODO time
return last;
}
} else if (tp.equals( TEST_START )){
JSONObject tcObj=rObj.getJSONObject( TEST );
TestResult tr=newTestResult( tcObj, parents, p );
tr.setStatus( TestStatus.RUNNING ); // running until we get the corresponding test-end
return tr;
} else if (tp.equals( TEST_RESULTS )){
TestResult root=parents.get( new JSONArray().toString() );
root.setWallTime( rObj.optLong( WALL_TIME, 0 ) );
}
return null;
}","private static TestResult parse1TestOutput ( final String sobj , final Map < String , TestResult > parents , final IProject p , final TestResult last ) throws JSONException { 
 JSONObject rObj = new JSONObject ( sobj ) ; 
 String tp = rObj . getString ( TYPE ) ; 
 if ( tp . equals ( TEST_END ) ) { 
 if ( last != null ) { 
 String r = rObj . getString ( RESULT ) ; 
 if ( RESULT_PASS . equals ( r ) ) { 
 last . setStatus ( TestStatus . OK ) ; 
 } else if ( RESULT_FAIL . equals ( r ) ) { 
 last . setStatus ( TestStatus . FAILURE ) ; 
 } else { 
 last . setStatus ( TestStatus . ERROR ) ; 
 } 
 last . setText ( rObj . optString ( MESSAGE ) ) ; 
 // TODO parse location of failure 
 JSONObject tcObj = rObj . getJSONObject ( TEST ) ; 
 parseLocation ( last , tcObj ) ; 
 // TODO time 
 return last ; 
 } 
 } else if ( tp . equals ( TEST_START ) ) { 
 JSONObject tcObj = rObj . getJSONObject ( TEST ) ; 
 TestResult tr = newTestResult ( tcObj , parents , p ) ; 
 tr . setStatus ( TestStatus . RUNNING ) ; // running until we get the corresponding test - end 
 return tr ; 
 } 
 return null ; 
 }  ","private static TestResult parse1TestOutput ( final String sobj , final Map < String , TestResult > parents , final IProject p , final TestResult last ) throws JSONException { 
 JSONObject rObj = new JSONObject ( sobj ) ; 
 String tp = rObj . getString ( TYPE ) ; 
 if ( tp . equals ( TEST_END ) ) { 
 if ( last != null ) { 
 String r = rObj . getString ( RESULT ) ; 
 if ( RESULT_PASS . equals ( r ) ) { 
 last . setStatus ( TestStatus . OK ) ; 
 } else if ( RESULT_FAIL . equals ( r ) ) { 
 last . setStatus ( TestStatus . FAILURE ) ; 
 } else { 
 last . setStatus ( TestStatus . ERROR ) ; 
 } 
 last . setText ( rObj . optString ( MESSAGE ) ) ; 
 if ( ! TestStatus . OK . equals ( last . getStatus ( ) ) ) { 
 parseLocation ( last , rObj ) ; 
 } 
 last . setWallTime ( rObj . optLong ( WALL_TIME , 0 ) ) ; 
 // TODO time 
 return last ; 
 } 
 } else if ( tp . equals ( TEST_START ) ) { 
 JSONObject tcObj = rObj . getJSONObject ( TEST ) ; 
 TestResult tr = newTestResult ( tcObj , parents , p ) ; 
 tr . setStatus ( TestStatus . RUNNING ) ; // running until we get the corresponding test - end 
 return tr ; 
 } else if ( tp . equals ( TEST_RESULTS ) ) { 
 TestResult root = parents . get ( new JSONArray ( ) . toString ( ) ) ; 
 root . setWallTime ( rObj . optLong ( WALL_TIME , 0 ) ) ; 
 } 
 return null ; 
 }  ",2012-11-19 22:17:10 +0100,2012-11-20 17:05:50 +0100,0,0.9357384948287444
1600,19,https://www.github.com/prevayler/prevayler,publish(Transaction),NOT_DESIGN,29,29,29,29,TODO Advance the public clock according to executionTime.,https://www.github.com/prevayler/prevayler/commit/fd3aaa7f,https://www.github.com/prevayler/prevayler/commit/edb59683b64677d68467f7d75bff549dba505f04,src/main/org/prevayler/implementation/CentralPublisher.java,"public synchronized void publish(Transaction transaction) {
Date executionTime = _clock.time();
_censor.approve(transaction, executionTime);
_logger.log(transaction, executionTime);
//TODO Advance the public clock according to executionTime.
notifySubscribers(transaction, executionTime);
}","public synchronized void publish(Transaction transaction) {
_pausableClock.pause();
try {
Date executionTime = _pausableClock.time();
_censor.approve(transaction, executionTime);
_logger.log(transaction, executionTime);
notifySubscribers(transaction, executionTime);
} finally {
_pausableClock.resume();
}
}","public synchronized void publish ( Transaction transaction ) { 
 Date executionTime = _clock . time ( ) ; 
 _censor . approve ( transaction , executionTime ) ; 
 _logger . log ( transaction , executionTime ) ; 
 // TODO Advance the public clock according to executionTime . 
 notifySubscribers ( transaction , executionTime ) ; 
 }  ","public synchronized void publish ( Transaction transaction ) { 
 _pausableClock . pause ( ) ; 
 try { 
 Date executionTime = _pausableClock . time ( ) ; 
 _censor . approve ( transaction , executionTime ) ; 
 _logger . log ( transaction , executionTime ) ; 
 notifySubscribers ( transaction , executionTime ) ; 
 } finally { 
 _pausableClock . resume ( ) ; 
 } 
 }  ",2003-07-25 16:51:41 +0000,2003-07-27 01:41:05 +0000,0,0.8232755234870053
652,616,https://www.github.com/querydsl/querydsl,"serializeForQuery(QueryMetadata, boolean)",,209,209,209,209,TODO : this should be injectted,https://www.github.com/querydsl/querydsl/commit/212b3eceb4,https://www.github.com/querydsl/querydsl/commit/1ef91ed0d2cf60dc6d46ada86838d18b39321866,querydsl-sql/src/main/java/com/mysema/query/sql/SQLSerializer.java,"@SuppressWarnings(""unchecked"")
private void serializeForQuery(QueryMetadata metadata, boolean forCountRow) {
List<? extends Expr<?>> select = metadata.getProjection();
List<JoinExpression> joins = metadata.getJoins();
EBoolean where = metadata.getWhere();
List<? extends Expr<?>> groupBy = metadata.getGroupBy();
EBoolean having = metadata.getHaving();
List<OrderSpecifier<?>> orderBy = metadata.getOrderBy();
List<Expr<?>> sqlSelect = new ArrayList<Expr<?>>();
for (Expr<?> selectExpr : select) {
if (selectExpr instanceof EConstructor) {
// transforms constructor arguments into individual select expressions
sqlSelect.addAll(((EConstructor<?>) selectExpr).getArgs());
} else {
sqlSelect.add(selectExpr);
}
}
// select
if (forCountRow) {
append(templates.getSelect());
if (!metadata.isDistinct()){
append(templates.getCountStar());
}else{
append(templates.getDistinctCountStart());
if (sqlSelect.isEmpty()){
List<Expr<?>> columns = getIdentifierColumns(joins);
handle(columns.get(0));
}else{
handle(COMMA, sqlSelect);
}
append(templates.getDistinctCountEnd());
}
} else if (!sqlSelect.isEmpty()) {
if (!metadata.isDistinct()) {
append(templates.getSelect());
} else {
append(templates.getSelectDistinct());
}
handle(COMMA, sqlSelect);
}
// from
serializeSources(joins);
// where
if (where != null) {
append(templates.getWhere()).handle(where);
}
// group by
if (!groupBy.isEmpty()) {
append(templates.getGroupBy()).handle(COMMA, groupBy);
}
// having
if (having != null) {
if (groupBy.isEmpty()) {
throw new IllegalArgumentException(""having, but not groupBy was given"");
}
append(templates.getHaving()).handle(having);
}
// TODO : this should be injectted
beforeOrderBy();
// order by
if (!orderBy.isEmpty() && !forCountRow) {
serializeOrderBy(orderBy);
}
}","@SuppressWarnings(""unchecked"")
private void serializeForQuery(QueryMetadata metadata, boolean forCountRow) {
List<? extends Expr<?>> select = metadata.getProjection();
List<JoinExpression> joins = metadata.getJoins();
EBoolean where = metadata.getWhere();
List<? extends Expr<?>> groupBy = metadata.getGroupBy();
EBoolean having = metadata.getHaving();
List<OrderSpecifier<?>> orderBy = metadata.getOrderBy();
Set<QueryFlag> flags = metadata.getFlags();
List<Expr<?>> sqlSelect = new ArrayList<Expr<?>>();
for (Expr<?> selectExpr : select) {
if (selectExpr instanceof EConstructor) {
// transforms constructor arguments into individual select expressions
sqlSelect.addAll(((EConstructor<?>) selectExpr).getArgs());
} else {
sqlSelect.add(selectExpr);
}
}
// start
serialize(Position.START, flags);
// select
if (forCountRow) {
append(templates.getSelect());
serialize(Position.AFTER_SELECT, flags);
if (!metadata.isDistinct()){
append(templates.getCountStar());
}else{
append(templates.getDistinctCountStart());
if (sqlSelect.isEmpty()){
List<Expr<?>> columns = getIdentifierColumns(joins);
handle(columns.get(0));
}else{
handle(COMMA, sqlSelect);
}
append(templates.getDistinctCountEnd());
}
} else if (!sqlSelect.isEmpty()) {
if (!metadata.isDistinct()) {
append(templates.getSelect());
} else {
append(templates.getSelectDistinct());
}
serialize(Position.AFTER_SELECT, flags);
handle(COMMA, sqlSelect);
}
serialize(Position.AFTER_PROJECTION, flags);
// from
serializeSources(joins);
// where            
serialize(Position.BEFORE_FILTERS, flags);
if (where != null) {
append(templates.getWhere()).handle(where);
serialize(Position.AFTER_FILTERS, flags);
}
// group by
serialize(Position.BEFORE_GROUP_BY, flags);
if (!groupBy.isEmpty()) {
append(templates.getGroupBy()).handle(COMMA, groupBy);
serialize(Position.AFTER_GROUP_BY, flags);
}
// having
serialize(Position.BEFORE_HAVING, flags);
if (having != null) {
if (groupBy.isEmpty()) {
throw new IllegalArgumentException(""having, but not groupBy was given"");
}
append(templates.getHaving()).handle(having);
serialize(Position.AFTER_HAVING, flags);
}
// order by
serialize(Position.BEFORE_ORDER, flags);
if (!orderBy.isEmpty() && !forCountRow) {
append(templates.getOrderBy());
boolean first = true;
for (OrderSpecifier<?> os : orderBy) {
if (!first){
append(COMMA);
}
handle(os.getTarget());
append(os.getOrder() == Order.ASC ? templates.getAsc() : templates.getDesc());
first = false;
}
serialize(Position.AFTER_ORDER, flags);
}
// end
serialize(Position.END, flags);
}","@ SuppressWarnings ( ""unchecked"" ) 
 private void serializeForQuery ( QueryMetadata metadata , boolean forCountRow ) { 
 List < ? extends Expr < ? >> select = metadata . getProjection ( ) ; 
 List < JoinExpression > joins = metadata . getJoins ( ) ; 
 EBoolean where = metadata . getWhere ( ) ; 
 List < ? extends Expr < ? >> groupBy = metadata . getGroupBy ( ) ; 
 EBoolean having = metadata . getHaving ( ) ; 
 List < OrderSpecifier < ? >> orderBy = metadata . getOrderBy ( ) ; 
 List < Expr < ? >> sqlSelect = new ArrayList < Expr < ? >> ( ) ; 
 for ( Expr < ? > selectExpr : select ) { 
 if ( selectExpr instanceof EConstructor ) { 
 // transforms constructor arguments into individual select expressions 
 sqlSelect . addAll ( ( ( EConstructor < ? > ) selectExpr ) . getArgs ( ) ) ; 
 } else { 
 sqlSelect . add ( selectExpr ) ; 
 } 
 } 
 // select 
 if ( forCountRow ) { 
 append ( templates . getSelect ( ) ) ; 
 if ( ! metadata . isDistinct ( ) ) { 
 append ( templates . getCountStar ( ) ) ; 
 } else { 
 append ( templates . getDistinctCountStart ( ) ) ; 
 if ( sqlSelect . isEmpty ( ) ) { 
 List < Expr < ? >> columns = getIdentifierColumns ( joins ) ; 
 handle ( columns . get ( 0 ) ) ; 
 } else { 
 handle ( COMMA , sqlSelect ) ; 
 } 
 append ( templates . getDistinctCountEnd ( ) ) ; 
 } 
 } else if ( ! sqlSelect . isEmpty ( ) ) { 
 if ( ! metadata . isDistinct ( ) ) { 
 append ( templates . getSelect ( ) ) ; 
 } else { 
 append ( templates . getSelectDistinct ( ) ) ; 
 } 
 handle ( COMMA , sqlSelect ) ; 
 } 
 // from 
 serializeSources ( joins ) ; 
 // where 
 if ( where != null ) { 
 append ( templates . getWhere ( ) ) . handle ( where ) ; 
 } 
 // group by 
 if ( ! groupBy . isEmpty ( ) ) { 
 append ( templates . getGroupBy ( ) ) . handle ( COMMA , groupBy ) ; 
 } 
 // having 
 if ( having != null ) { 
 if ( groupBy . isEmpty ( ) ) { 
 throw new IllegalArgumentException ( ""having, but not groupBy was given"" ) ; 
 } 
 append ( templates . getHaving ( ) ) . handle ( having ) ; 
 } 
 // TODO : this should be injectted 
 beforeOrderBy ( ) ; 
 // order by 
 if ( ! orderBy . isEmpty ( ) & &   ! forCountRow ) { 
 serializeOrderBy ( orderBy ) ; 
 } 
 }  ","@ SuppressWarnings ( ""unchecked"" ) 
 private void serializeForQuery ( QueryMetadata metadata , boolean forCountRow ) { 
 List < ? extends Expr < ? >> select = metadata . getProjection ( ) ; 
 List < JoinExpression > joins = metadata . getJoins ( ) ; 
 EBoolean where = metadata . getWhere ( ) ; 
 List < ? extends Expr < ? >> groupBy = metadata . getGroupBy ( ) ; 
 EBoolean having = metadata . getHaving ( ) ; 
 List < OrderSpecifier < ? >> orderBy = metadata . getOrderBy ( ) ; 
 Set < QueryFlag > flags = metadata . getFlags ( ) ; 
 List < Expr < ? >> sqlSelect = new ArrayList < Expr < ? >> ( ) ; 
 for ( Expr < ? > selectExpr : select ) { 
 if ( selectExpr instanceof EConstructor ) { 
 // transforms constructor arguments into individual select expressions 
 sqlSelect . addAll ( ( ( EConstructor < ? > ) selectExpr ) . getArgs ( ) ) ; 
 } else { 
 sqlSelect . add ( selectExpr ) ; 
 } 
 } 
 // start 
 serialize ( Position . START , flags ) ; 
 // select 
 if ( forCountRow ) { 
 append ( templates . getSelect ( ) ) ; 
 serialize ( Position . AFTER_SELECT , flags ) ; 
 if ( ! metadata . isDistinct ( ) ) { 
 append ( templates . getCountStar ( ) ) ; 
 } else { 
 append ( templates . getDistinctCountStart ( ) ) ; 
 if ( sqlSelect . isEmpty ( ) ) { 
 List < Expr < ? >> columns = getIdentifierColumns ( joins ) ; 
 handle ( columns . get ( 0 ) ) ; 
 } else { 
 handle ( COMMA , sqlSelect ) ; 
 } 
 append ( templates . getDistinctCountEnd ( ) ) ; 
 } 
 } else if ( ! sqlSelect . isEmpty ( ) ) { 
 if ( ! metadata . isDistinct ( ) ) { 
 append ( templates . getSelect ( ) ) ; 
 } else { 
 append ( templates . getSelectDistinct ( ) ) ; 
 } 
 serialize ( Position . AFTER_SELECT , flags ) ; 
 handle ( COMMA , sqlSelect ) ; 
 } 
 serialize ( Position . AFTER_PROJECTION , flags ) ; 
 // from 
 serializeSources ( joins ) ; 
 // where 
 serialize ( Position . BEFORE_FILTERS , flags ) ; 
 if ( where != null ) { 
 append ( templates . getWhere ( ) ) . handle ( where ) ; 
 serialize ( Position . AFTER_FILTERS , flags ) ; 
 } 
 // group by 
 serialize ( Position . BEFORE_GROUP_BY , flags ) ; 
 if ( ! groupBy . isEmpty ( ) ) { 
 append ( templates . getGroupBy ( ) ) . handle ( COMMA , groupBy ) ; 
 serialize ( Position . AFTER_GROUP_BY , flags ) ; 
 } 
 // having 
 serialize ( Position . BEFORE_HAVING , flags ) ; 
 if ( having != null ) { 
 if ( groupBy . isEmpty ( ) ) { 
 throw new IllegalArgumentException ( ""having, but not groupBy was given"" ) ; 
 } 
 append ( templates . getHaving ( ) ) . handle ( having ) ; 
 serialize ( Position . AFTER_HAVING , flags ) ; 
 } 
 // order by 
 serialize ( Position . BEFORE_ORDER , flags ) ; 
 if ( ! orderBy . isEmpty ( ) & &   ! forCountRow ) { 
 append ( templates . getOrderBy ( ) ) ; 
 boolean first = true ; 
 for ( OrderSpecifier < ? > os : orderBy ) { 
 if ( ! first ) { 
 append ( COMMA ) ; 
 } 
 handle ( os . getTarget ( ) ) ; 
 append ( os . getOrder ( ) == Order . ASC   ? templates . getAsc ( ) : templates . getDesc ( ) ) ; 
 first = false ; 
 } 
 serialize ( Position . AFTER_ORDER , flags ) ; 
 } 
 // end 
 serialize ( Position . END , flags ) ; 
 }  ",2010-06-21 16:07:45 +0000,2010-07-10 00:32:40 +0000,0,0.7116429382153162
3528,669,https://www.github.com/cyanogenmod/android_packages_apps_nfc,"onReceive(Context, Intent)",NOT_DESIGN,160,160,169,169,TODO only apply routing if uid is current user!,https://www.github.com/cyanogenmod/android_packages_apps_nfc/commit/62372fdec,https://www.github.com/cyanogenmod/android_packages_apps_nfc/commit/89c893312d524f50c47b0d32071f3de8631197f3,src/com/android/nfc/cardemulation/RegisteredServicesCache.java,"@Override
public void onReceive(Context context, Intent intent) {
final int uid = intent.getIntExtra(Intent.EXTRA_UID, -1);
String action = intent.getAction();
if (uid != -1) {
if (DEBUG) Log.d(TAG, ""Intent action: "" + action);
boolean replaced = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false) &&
(Intent.ACTION_PACKAGE_ADDED.equals(action) ||
Intent.ACTION_PACKAGE_REMOVED.equals(action));
if (!replaced) {
// TODO only apply routing if uid is current user!
invalidateCache(UserHandle.getUserId(uid));
} else {
if (DEBUG) Log.d(TAG, ""Ignoring package intent due to package being replaced."");
}
}
}","@Override
public void onReceive(Context context, Intent intent) {
final int uid = intent.getIntExtra(Intent.EXTRA_UID, -1);
String action = intent.getAction();
if (uid != -1) {
if (DEBUG) Log.d(TAG, ""Intent action: "" + action);
boolean replaced = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false) &&
(Intent.ACTION_PACKAGE_ADDED.equals(action) ||
Intent.ACTION_PACKAGE_REMOVED.equals(action));
if (!replaced) {
int currentUser = ActivityManager.getCurrentUser();
if (currentUser == UserHandle.getUserId(uid)) {
invalidateCache(UserHandle.getUserId(uid));
} else {
// Cache will automatically be updated on user switch
}
} else {
if (DEBUG) Log.d(TAG, ""Ignoring package intent due to package being replaced."");
}
}
}","@ Override 
 public void onReceive ( Context context , Intent intent ) { 
 final int uid = intent . getIntExtra ( Intent . EXTRA_UID , - 1 ) ; 
 String action = intent . getAction ( ) ; 
 if ( uid != - 1 ) { 
 if ( DEBUG ) Log . d ( TAG , ""Intent action: "" + action ) ; 
 boolean replaced = intent . getBooleanExtra ( Intent . EXTRA_REPLACING , false ) & & 
 ( Intent . ACTION_PACKAGE_ADDED . equals ( action ) | | 
 Intent . ACTION_PACKAGE_REMOVED . equals ( action ) ) ; 
 if ( ! replaced ) { 
 // TODO only apply routing if uid is current user ! 
 invalidateCache ( UserHandle . getUserId ( uid ) ) ; 
 } else { 
 if ( DEBUG ) Log . d ( TAG , ""Ignoring package intent due to package being replaced."" ) ; 
 } 
 } 
 }  ","@ Override 
 public void onReceive ( Context context , Intent intent ) { 
 final int uid = intent . getIntExtra ( Intent . EXTRA_UID , - 1 ) ; 
 String action = intent . getAction ( ) ; 
 if ( uid != - 1 ) { 
 if ( DEBUG ) Log . d ( TAG , ""Intent action: "" + action ) ; 
 boolean replaced = intent . getBooleanExtra ( Intent . EXTRA_REPLACING , false ) & & 
 ( Intent . ACTION_PACKAGE_ADDED . equals ( action ) | | 
 Intent . ACTION_PACKAGE_REMOVED . equals ( action ) ) ; 
 if ( ! replaced ) { 
 int currentUser = ActivityManager . getCurrentUser ( ) ; 
 if ( currentUser == UserHandle . getUserId ( uid ) ) { 
 invalidateCache ( UserHandle . getUserId ( uid ) ) ; 
 } else { 
 // Cache will automatically be updated on user switch 
 } 
 } else { 
 if ( DEBUG ) Log . d ( TAG , ""Ignoring package intent due to package being replaced."" ) ; 
 } 
 } 
 }  ",2013/8/6 19:25,2013/8/7 21:19,0,0.9448798618662333
2855,100,https://www.github.com/apache/cocoon,genSettings(),,332,332,332,332,FIXME add all,https://www.github.com/apache/cocoon/commit/be700e8c210,https://www.github.com/apache/cocoon/commit/0d74941fd03eaa4a0c60333e94434a541f675826,src/java/org/apache/cocoon/generation/StatusGenerator.java,"private void genSettings() throws SAXException {
final Settings s = Core.getSettings(this.context);
this.startGroup(""settings"");
// FIXME add all
this.addValue(Settings.KEY_CONFIGURATION, s.getConfiguration());
this.addValue(Settings.KEY_CONFIGURATION_RELOAD_DELAY, String.valueOf(s.getConfigurationReloadDelay()));
this.endGroup();
}","private void genSettings() throws SAXException {
final Settings s = Core.getSettings(this.context);
this.startGroup(""Settings"");
this.addValue(Settings.KEY_CONFIGURATION, s.getConfiguration());
this.addValue(Settings.KEY_CONFIGURATION_RELOAD_DELAY, s.getConfigurationReloadDelay());
this.addValue(Settings.KEY_ALLOW_RELOAD, s.isAllowReload());
this.addValue(Settings.KEY_INIT_CLASSLOADER, s.isInitClassloader());
this.addValue(Settings.KEY_EXTRA_CLASSPATHS, s.getExtraClasspaths());
this.addValue(Settings.KEY_LOAD_CLASSES, s.getLoadClasses());
this.addValue(Settings.KEY_FORCE_PROPERTIES, s.getForceProperties());
this.addValue(Settings.KEY_LOGGING_CONFIGURATION, s.getLoggingConfiguration());
this.addValue(Settings.KEY_LOGGING_ACCESS_LOGGER, s.getAccessLogger());
this.addValue(Settings.KEY_LOGGING_BOOTSTRAP_LOGLEVEL, s.getBootstrapLogLevel());
this.addValue(Settings.KEY_LOGGING_COCOON_LOGGER, s.getCocoonLogger());
this.addValue(Settings.KEY_LOGGING_LOG4J_CONFIGURATION, s.getLog4jConfiguration());
this.addValue(Settings.KEY_LOGGING_MANAGER_CLASS, s.getLoggerClassName());
this.addValue(Settings.KEY_LOGGING_OVERRIDE_LOGLEVEL, s.getOverrideLogLevel());
this.addValue(Settings.KEY_MANAGE_EXCEPTIONS, s.isManageExceptions());
this.addValue(Settings.KEY_PARENT_SERVICE_MANAGER, s.getParentServiceManagerClassName());
this.addValue(Settings.KEY_UPLOADS_DIRECTORY, s.getUploadDirectory());
this.addValue(Settings.KEY_UPLOADS_AUTOSAVE, s.isAutosaveUploads());
this.addValue(Settings.KEY_UPLOADS_ENABLE, s.isEnableUploads());
this.addValue(Settings.KEY_UPLOADS_MAXSIZE, s.getMaxUploadSize());
this.addValue(Settings.KEY_UPLOADS_OVERWRITE, s.isAllowOverwrite());
this.addValue(Settings.KEY_CACHE_DIRECTORY, s.getCacheDirectory());
this.addValue(Settings.KEY_WORK_DIRECTORY, s.getWorkDirectory());
this.addValue(Settings.KEY_FORM_ENCODING, s.getFormEncoding());
this.addValue(Settings.KEY_SHOWTIME, s.isShowTime());
this.addValue(Settings.KEY_HIDE_SHOWTIME, s.isHideShowTime());
}","private void genSettings ( ) throws SAXException { 
 final Settings s = Core . getSettings ( this . context ) ; 
 this . startGroup ( ""settings"" ) ; 
 // FIXME add all 
 this . addValue ( Settings . KEY_CONFIGURATION , s . getConfiguration ( ) ) ; 
 this . addValue ( Settings . KEY_CONFIGURATION_RELOAD_DELAY , String . valueOf ( s . getConfigurationReloadDelay ( ) ) ) ; 
 this . endGroup ( ) ; 
 }  ","private void genSettings ( ) throws SAXException { 
 final Settings s = Core . getSettings ( this . context ) ; 
 this . startGroup ( ""Settings"" ) ; 
 this . addValue ( Settings . KEY_CONFIGURATION , s . getConfiguration ( ) ) ; 
 this . addValue ( Settings . KEY_CONFIGURATION_RELOAD_DELAY , s . getConfigurationReloadDelay ( ) ) ; 
 this . addValue ( Settings . KEY_ALLOW_RELOAD , s . isAllowReload ( ) ) ; 
 this . addValue ( Settings . KEY_INIT_CLASSLOADER , s . isInitClassloader ( ) ) ; 
 this . addValue ( Settings . KEY_EXTRA_CLASSPATHS , s . getExtraClasspaths ( ) ) ; 
 this . addValue ( Settings . KEY_LOAD_CLASSES , s . getLoadClasses ( ) ) ; 
 this . addValue ( Settings . KEY_FORCE_PROPERTIES , s . getForceProperties ( ) ) ; 
 this . addValue ( Settings . KEY_LOGGING_CONFIGURATION , s . getLoggingConfiguration ( ) ) ; 
 this . addValue ( Settings . KEY_LOGGING_ACCESS_LOGGER , s . getAccessLogger ( ) ) ; 
 this . addValue ( Settings . KEY_LOGGING_BOOTSTRAP_LOGLEVEL , s . getBootstrapLogLevel ( ) ) ; 
 this . addValue ( Settings . KEY_LOGGING_COCOON_LOGGER , s . getCocoonLogger ( ) ) ; 
 this . addValue ( Settings . KEY_LOGGING_LOG4J_CONFIGURATION , s . getLog4jConfiguration ( ) ) ; 
 this . addValue ( Settings . KEY_LOGGING_MANAGER_CLASS , s . getLoggerClassName ( ) ) ; 
 this . addValue ( Settings . KEY_LOGGING_OVERRIDE_LOGLEVEL , s . getOverrideLogLevel ( ) ) ; 
 this . addValue ( Settings . KEY_MANAGE_EXCEPTIONS , s . isManageExceptions ( ) ) ; 
 this . addValue ( Settings . KEY_PARENT_SERVICE_MANAGER , s . getParentServiceManagerClassName ( ) ) ; 
 this . addValue ( Settings . KEY_UPLOADS_DIRECTORY , s . getUploadDirectory ( ) ) ; 
 this . addValue ( Settings . KEY_UPLOADS_AUTOSAVE , s . isAutosaveUploads ( ) ) ; 
 this . addValue ( Settings . KEY_UPLOADS_ENABLE , s . isEnableUploads ( ) ) ; 
 this . addValue ( Settings . KEY_UPLOADS_MAXSIZE , s . getMaxUploadSize ( ) ) ; 
 this . addValue ( Settings . KEY_UPLOADS_OVERWRITE , s . isAllowOverwrite ( ) ) ; 
 this . addValue ( Settings . KEY_CACHE_DIRECTORY , s . getCacheDirectory ( ) ) ; 
 this . addValue ( Settings . KEY_WORK_DIRECTORY , s . getWorkDirectory ( ) ) ; 
 this . addValue ( Settings . KEY_FORM_ENCODING , s . getFormEncoding ( ) ) ; 
 this . addValue ( Settings . KEY_SHOWTIME , s . isShowTime ( ) ) ; 
 this . addValue ( Settings . KEY_HIDE_SHOWTIME , s . isHideShowTime ( ) ) ; 
 }  ",2005-02-11 15:20:52 +0000,2005-02-13 13:50:07 +0000,0,0.7478401630504626
1087,640,https://www.github.com/apache/giraph,"sendMessage(I, M)",NOT_DESIGN,225,225,233,233,TODO: implement getPartition,https://www.github.com/apache/giraph/commit/c2e211bc6,https://www.github.com/apache/giraph/commit/4f92d5e097ae75da60b7e96695fb92438d4c0717,src/main/java/com/yahoo/hadoop_bsp/RPCCommunications.java,"public void sendMessage(I destVertex, M msg) {
LOG.info(""Send bytes ("" + msg.toString() + "") to "" + destVertex);
// TODO: implement getPartition
//Partition<I> destPartition = service.getPartition(destVertex);
Partition<I> destPartition = new Partition<I>(localHostname,
                       Integer.parseInt(getName().split("":"")[1]), null);
InetSocketAddress addr = new InetSocketAddress(
    		                                 destPartition.getHostname(),
    		                                 destPartition.getPort());
HashMap<I, ArrayList<M>> msgMap = outMessages.get(addr);
if (msgMap == null) { // should never happen after constructor
msgMap = new HashMap<I, ArrayList<M>>();
outMessages.put(addr, msgMap);
}
ArrayList<M> msgList = msgMap.get(destVertex);
if (msgList == null) {
msgList = new ArrayList<M>();
msgMap.put(destVertex, msgList);
}
synchronized(msgList) {
msgList.add(msg);
LOG.info(""added msg, size="" + msgList.size());
}
synchronized (waitingOn) {
waitingOn.notify();
}
}","public void sendMessage(I destVertex, M msg) {
LOG.info(""Send bytes ("" + msg.toString() + "") to "" + destVertex);
Partition<I> destPartition = service.getPartition(destVertex);
InetSocketAddress addr = new InetSocketAddress(
			destPartition.getHostname(),
			destPartition.getPort());
HashMap<I, ArrayList<M>> msgMap = outMessages.get(addr);
if (msgMap == null) { // should never happen after constructor
msgMap = new HashMap<I, ArrayList<M>>();
outMessages.put(addr, msgMap);
}
ArrayList<M> msgList = msgMap.get(destVertex);
if (msgList == null) {
msgList = new ArrayList<M>();
msgMap.put(destVertex, msgList);
}
synchronized(msgList) {
msgList.add(msg);
LOG.info(""added msg, size="" + msgList.size());
}
synchronized (waitingOn) {
waitingOn.notify();
}
}","public void sendMessage ( I destVertex , M msg ) { 
 LOG . info ( ""Send bytes ("" + msg . toString ( ) + "") to "" + destVertex ) ; 
 // TODO : implement getPartition 
 // Partition < I > destPartition = service . getPartition ( destVertex ) ; 
 Partition < I > destPartition = new Partition < I > ( localHostname , 
 Integer . parseInt ( getName ( ) . split ( "":"" ) [ 1 ] ) , null ) ; 
 InetSocketAddress addr = new InetSocketAddress ( 
 destPartition . getHostname ( ) , 
 destPartition . getPort ( ) ) ; 
 HashMap < I , ArrayList < M >> msgMap = outMessages . get ( addr ) ; 
 if ( msgMap == null ) { // should never happen after constructor 
 msgMap = new HashMap < I , ArrayList < M >> ( ) ; 
 outMessages . put ( addr , msgMap ) ; 
 } 
 ArrayList < M > msgList = msgMap . get ( destVertex ) ; 
 if ( msgList == null ) { 
 msgList = new ArrayList < M > ( ) ; 
 msgMap . put ( destVertex , msgList ) ; 
 } 
 synchronized ( msgList ) { 
 msgList . add ( msg ) ; 
 LOG . info ( ""added msg, size="" + msgList . size ( ) ) ; 
 } 
 synchronized ( waitingOn ) { 
 waitingOn . notify ( ) ; 
 } 
 }  ","public void sendMessage ( I destVertex , M msg ) { 
 LOG . info ( ""Send bytes ("" + msg . toString ( ) + "") to "" + destVertex ) ; 
 Partition < I > destPartition = service . getPartition ( destVertex ) ; 
 InetSocketAddress addr = new InetSocketAddress ( 
 destPartition . getHostname ( ) , 
 destPartition . getPort ( ) ) ; 
 HashMap < I , ArrayList < M >> msgMap = outMessages . get ( addr ) ; 
 if ( msgMap == null ) { // should never happen after constructor 
 msgMap = new HashMap < I , ArrayList < M >> ( ) ; 
 outMessages . put ( addr , msgMap ) ; 
 } 
 ArrayList < M > msgList = msgMap . get ( destVertex ) ; 
 if ( msgList == null ) { 
 msgList = new ArrayList < M > ( ) ; 
 msgMap . put ( destVertex , msgList ) ; 
 } 
 synchronized ( msgList ) { 
 msgList . add ( msg ) ; 
 LOG . info ( ""added msg, size="" + msgList . size ( ) ) ; 
 } 
 synchronized ( waitingOn ) { 
 waitingOn . notify ( ) ; 
 } 
 }  ",2010-11-18 02:19:29 +0000,2010-11-23 18:24:37 +0000,0,0.9753119668681973
486,222,https://www.github.com/lmco/eurekastreams,execute(ActivityDTO),DESIGN,113,113,131,131,"TODO: climb up the tree, adding activity to each org",https://www.github.com/lmco/eurekastreams/commit/43b3de0663,https://www.github.com/lmco/eurekastreams/commit/31df4b116a32caf2fc0eb3f2c56055a7f178ec00,server/src/main/java/org/eurekastreams/server/persistence/mappers/stream/PostCachedActivity.java,"public void execute(final ActivityDTO activity)
{
// Gets the followers and add to their followed stream if the
// activity is posted to a Person's stream.
if (activity.getDestinationStream().getType() == EntityType.PERSON)
{
List<String> param = new ArrayList<String>();
param.add(activity.getDestinationStream().getUniqueIdentifier());
long personId = bulkPeopleByAccountIdMapper.execute(param).get(0).getEntityId();
List<Long> followers = personFollowersMapper.execute(personId);
for (Long follower : followers)
{
getCache().addToTopOfList(CacheKeys.ACTIVITIES_BY_FOLLOWING + follower, activity.getId());
}
}
// add to everyone list
getCache().addToTopOfList(CacheKeys.EVERYONE_ACTIVITY_IDS, activity.getId());
// TODO: climb up the tree, adding activity to each org
}","public void execute(final ActivityDTO activity)
{
// Gets the followers and add to their followed stream if the
// activity is posted to a Person's stream.
if (activity.getDestinationStream().getType() == EntityType.PERSON)
{
List<String> param = new ArrayList<String>();
param.add(activity.getDestinationStream().getUniqueIdentifier());
long personId = bulkPeopleByAccountIdMapper.execute(param).get(0).getEntityId();
List<Long> followers = personFollowersMapper.execute(personId);
for (Long follower : followers)
{
getCache().addToTopOfList(CacheKeys.ACTIVITIES_BY_FOLLOWING + follower, activity.getId());
}
}
// add to everyone list
log.trace(""Adding activity id "" + activity.getId() + "" into everyone activity list."");
getCache().addToTopOfList(CacheKeys.EVERYONE_ACTIVITY_IDS, activity.getId());
// climb up the tree, adding activity to each org
for (String orgShortName : getAllParentOrgShortNames(activity))
{
log.trace(""Adding activity id "" + activity.getId() + "" to organization cache list "" + orgShortName);
getCache().addToTopOfList(CacheKeys.ACTIVITY_IDS_FOR_ORG_BY_SHORTNAME_RECURSIVE + orgShortName,
                    activity.getId());
}
}","public void execute ( final ActivityDTO activity ) 
 { 
 // Gets the followers and add to their followed stream if the 
 // activity is posted to a Person ' s stream . 
 if ( activity . getDestinationStream ( ) . getType ( ) == EntityType . PERSON ) 
 { 
 List < String > param = new ArrayList < String > ( ) ; 
 param . add ( activity . getDestinationStream ( ) . getUniqueIdentifier ( ) ) ; 
 long personId = bulkPeopleByAccountIdMapper . execute ( param ) . get ( 0 ) . getEntityId ( ) ; 
 List < Long > followers = personFollowersMapper . execute ( personId ) ; 
 for ( Long follower : followers ) 
 { 
 getCache ( ) . addToTopOfList ( CacheKeys . ACTIVITIES_BY_FOLLOWING + follower , activity . getId ( ) ) ; 
 } 
 } 
 // add to everyone list 
 getCache ( ) . addToTopOfList ( CacheKeys . EVERYONE_ACTIVITY_IDS , activity . getId ( ) ) ; 
 // TODO : climb up the tree , adding activity to each org 
 }  ","public void execute ( final ActivityDTO activity ) 
 { 
 // Gets the followers and add to their followed stream if the 
 // activity is posted to a Person ' s stream . 
 if ( activity . getDestinationStream ( ) . getType ( ) == EntityType . PERSON ) 
 { 
 List < String > param = new ArrayList < String > ( ) ; 
 param . add ( activity . getDestinationStream ( ) . getUniqueIdentifier ( ) ) ; 
 long personId = bulkPeopleByAccountIdMapper . execute ( param ) . get ( 0 ) . getEntityId ( ) ; 
 List < Long > followers = personFollowersMapper . execute ( personId ) ; 
 for ( Long follower : followers ) 
 { 
 getCache ( ) . addToTopOfList ( CacheKeys . ACTIVITIES_BY_FOLLOWING + follower , activity . getId ( ) ) ; 
 } 
 } 
 // add to everyone list 
 log . trace ( ""Adding activity id "" + activity . getId ( ) + "" into everyone activity list."" ) ; 
 getCache ( ) . addToTopOfList ( CacheKeys . EVERYONE_ACTIVITY_IDS , activity . getId ( ) ) ; 
 // climb up the tree , adding activity to each org 
 for ( String orgShortName : getAllParentOrgShortNames ( activity ) ) 
 { 
 log . trace ( ""Adding activity id "" + activity . getId ( ) + "" to organization cache list "" + orgShortName ) ; 
 getCache ( ) . addToTopOfList ( CacheKeys . ACTIVITY_IDS_FOR_ORG_BY_SHORTNAME_RECURSIVE + orgShortName , 
 activity . getId ( ) ) ; 
 } 
 }  ",2010/9/21 16:59,2010/9/27 14:11,0,0.9172958535320767
210,26,https://www.github.com/aosp-mirror/platform_packages_apps_email,"setAccountMailboxInfo(Context, long, long)",,501,501,501,501,TODO Would be nicer to show message count for combined mailboxes too..,https://www.github.com/aosp-mirror/platform_packages_apps_email/commit/4689cb7100,https://www.github.com/aosp-mirror/platform_packages_apps_email/commit/4b39d7ccff82f54f6ac53075de70ac8ded9f4ca1,src/com/android/email/activity/AccountSelectorAdapter.java,"private void setAccountMailboxInfo(Context context, long accountId, long mailboxId) {
mAccountId = accountId;
mMailboxId = mailboxId;
// Get account info
if (accountId == Account.ACCOUNT_ID_COMBINED_VIEW) {
// We need to treat ACCOUNT_ID_COMBINED_VIEW specially...
mAccountExists = true;
mAccountDisplayName = getCombinedViewDisplayName(context);
mMailboxDisplayName = FolderProperties.getInstance(context)
.getCombinedMailboxName(mMailboxId);
// TODO Would be nicer to show message count for combined mailboxes too..
mMailboxMessageCount = 0;
return;
}
mAccountDisplayName = Utility.getFirstRowString(context,
                    ContentUris.withAppendedId(Account.CONTENT_URI, accountId),
                    ACCOUNT_INFO_PROJECTION, null, null, null, 0, null);
if (mAccountDisplayName == null) {
// Account gone!
mAccountExists = false;
return;
}
mAccountExists = true;
// If mailbox not specified, done.
if (mMailboxId == Mailbox.NO_MAILBOX) {
return;
}
// Get mailbox info
final ContentResolver r = context.getContentResolver();
final Cursor mailboxCursor = r.query(
                    ContentUris.withAppendedId(Mailbox.CONTENT_URI, mailboxId),
                    MAILBOX_INFO_PROJECTION, null, null, null);
try {
if (mailboxCursor.moveToFirst()) {
final FolderProperties fp = FolderProperties.getInstance(context);
mMailboxDisplayName = fp.getDisplayName(mailboxCursor);
mMailboxMessageCount = fp.getMessageCount(mailboxCursor);
}
} finally {
mailboxCursor.close();
}
}","private void setAccountMailboxInfo(Context context, long accountId, long mailboxId) {
mAccountId = accountId;
mMailboxId = mailboxId;
// Get account info
if (accountId == Account.ACCOUNT_ID_COMBINED_VIEW) {
// We need to treat ACCOUNT_ID_COMBINED_VIEW specially...
mAccountExists = true;
mAccountDisplayName = getCombinedViewDisplayName(context);
setCombinedMailboxInfo(context, mailboxId);
return;
}
mAccountDisplayName = Utility.getFirstRowString(context,
                    ContentUris.withAppendedId(Account.CONTENT_URI, accountId),
                    ACCOUNT_INFO_PROJECTION, null, null, null, 0, null);
if (mAccountDisplayName == null) {
// Account gone!
mAccountExists = false;
return;
}
mAccountExists = true;
// If mailbox not specified, done.
if (mMailboxId == Mailbox.NO_MAILBOX) {
return;
}
// Combined mailbox?
// Unfortunately this can happen even when account != ACCOUNT_ID_COMBINED_VIEW,
// when you open ""starred"" on 2-pane on non-combined view.
if (mMailboxId < 0) {
setCombinedMailboxInfo(context, mailboxId);
return;
}
// Get mailbox info
final ContentResolver r = context.getContentResolver();
final Cursor mailboxCursor = r.query(
                    ContentUris.withAppendedId(Mailbox.CONTENT_URI, mailboxId),
                    MAILBOX_INFO_PROJECTION, null, null, null);
try {
if (mailboxCursor.moveToFirst()) {
final FolderProperties fp = FolderProperties.getInstance(context);
mMailboxDisplayName = fp.getDisplayName(mailboxCursor);
mMailboxMessageCount = fp.getMessageCount(mailboxCursor);
}
} finally {
mailboxCursor.close();
}
}","private void setAccountMailboxInfo ( Context context , long accountId , long mailboxId ) { 
 mAccountId = accountId ; 
 mMailboxId = mailboxId ; 
 // Get account info 
 if ( accountId == Account . ACCOUNT_ID_COMBINED_VIEW ) { 
 // We need to treat ACCOUNT_ID_COMBINED_VIEW specially ... 
 mAccountExists = true ; 
 mAccountDisplayName = getCombinedViewDisplayName ( context ) ; 
 mMailboxDisplayName = FolderProperties . getInstance ( context ) 
 . getCombinedMailboxName ( mMailboxId ) ; 
 // TODO Would be nicer to show message count for combined mailboxes too . . 
 mMailboxMessageCount = 0 ; 
 return ; 
 } 
 mAccountDisplayName = Utility . getFirstRowString ( context , 
 ContentUris . withAppendedId ( Account . CONTENT_URI , accountId ) , 
 ACCOUNT_INFO_PROJECTION , null , null , null , 0 , null ) ; 
 if ( mAccountDisplayName == null ) { 
 // Account gone ! 
 mAccountExists = false ; 
 return ; 
 } 
 mAccountExists = true ; 
 // If mailbox not specified , done . 
 if ( mMailboxId == Mailbox . NO_MAILBOX ) { 
 return ; 
 } 
 // Get mailbox info 
 final ContentResolver r = context . getContentResolver ( ) ; 
 final Cursor mailboxCursor = r . query ( 
 ContentUris . withAppendedId ( Mailbox . CONTENT_URI , mailboxId ) , 
 MAILBOX_INFO_PROJECTION , null , null , null ) ; 
 try { 
 if ( mailboxCursor . moveToFirst ( ) ) { 
 final FolderProperties fp = FolderProperties . getInstance ( context ) ; 
 mMailboxDisplayName = fp . getDisplayName ( mailboxCursor ) ; 
 mMailboxMessageCount = fp . getMessageCount ( mailboxCursor ) ; 
 } 
 } finally { 
 mailboxCursor . close ( ) ; 
 } 
 }  ","private void setAccountMailboxInfo ( Context context , long accountId , long mailboxId ) { 
 mAccountId = accountId ; 
 mMailboxId = mailboxId ; 
 // Get account info 
 if ( accountId == Account . ACCOUNT_ID_COMBINED_VIEW ) { 
 // We need to treat ACCOUNT_ID_COMBINED_VIEW specially ... 
 mAccountExists = true ; 
 mAccountDisplayName = getCombinedViewDisplayName ( context ) ; 
 setCombinedMailboxInfo ( context , mailboxId ) ; 
 return ; 
 } 
 mAccountDisplayName = Utility . getFirstRowString ( context , 
 ContentUris . withAppendedId ( Account . CONTENT_URI , accountId ) , 
 ACCOUNT_INFO_PROJECTION , null , null , null , 0 , null ) ; 
 if ( mAccountDisplayName == null ) { 
 // Account gone ! 
 mAccountExists = false ; 
 return ; 
 } 
 mAccountExists = true ; 
 // If mailbox not specified , done . 
 if ( mMailboxId == Mailbox . NO_MAILBOX ) { 
 return ; 
 } 
 // Combined mailbox ? 
 // Unfortunately this can happen even when account != ACCOUNT_ID_COMBINED_VIEW , 
 // when you open ""starred"" on 2 - pane on non - combined view . 
 if ( mMailboxId < 0 ) { 
 setCombinedMailboxInfo ( context , mailboxId ) ; 
 return ; 
 } 
 // Get mailbox info 
 final ContentResolver r = context . getContentResolver ( ) ; 
 final Cursor mailboxCursor = r . query ( 
 ContentUris . withAppendedId ( Mailbox . CONTENT_URI , mailboxId ) , 
 MAILBOX_INFO_PROJECTION , null , null , null ) ; 
 try { 
 if ( mailboxCursor . moveToFirst ( ) ) { 
 final FolderProperties fp = FolderProperties . getInstance ( context ) ; 
 mMailboxDisplayName = fp . getDisplayName ( mailboxCursor ) ; 
 mMailboxMessageCount = fp . getMessageCount ( mailboxCursor ) ; 
 } 
 } finally { 
 mailboxCursor . close ( ) ; 
 } 
 }  ",2011/6/27 13:19,2011/6/29 16:30,0,0.9244198127177155
1921,358,https://www.github.com/jenkinsci/jobconfighistory-plugin,testGetDiffLines(),,147,147,147,147,TODO review the generated test code and remove the default call to fail.,https://www.github.com/jenkinsci/jobconfighistory-plugin/commit/32ea2a4f,https://www.github.com/jenkinsci/jobconfighistory-plugin/commit/54828258cf144312bb5361f5abdb391c463e5518,src/test/java/hudson/plugins/jobConfigHistory/JobConfigHistoryBaseActionTest.java,"@Test
@Ignore
public void testGetDiffLines() throws Exception {
System.out.println(""getDiffLines"");
List<String> diffLines = null;
JobConfigHistoryBaseAction sut = new JobConfigHistoryBaseActionImpl();
List<JobConfigHistoryBaseAction.SideBySideView.Line> expResult = null;
List<JobConfigHistoryBaseAction.SideBySideView.Line> result = sut.getDiffLines(diffLines);
assertEquals(expResult, result);
// TODO review the generated test code and remove the default call to fail.
fail(""The test case is a prototype."");
}","@Test
public void testGetDiffLines() throws Exception {
final String resourceName = ""diff.txt"";
final List<String> lines = readResourceLines(resourceName);
JobConfigHistoryBaseAction sut = new JobConfigHistoryBaseActionImpl();
List<JobConfigHistoryBaseAction.SideBySideView.Line> result = sut.getDiffLines(lines);
assertEquals(24, result.size());
}","@ Test 
 @ Ignore 
 public void testGetDiffLines ( ) throws Exception { 
 System . out . println ( ""getDiffLines"" ) ; 
 List < String > diffLines = null ; 
 JobConfigHistoryBaseAction sut = new JobConfigHistoryBaseActionImpl ( ) ; 
 List < JobConfigHistoryBaseAction . SideBySideView . Line > expResult = null ; 
 List < JobConfigHistoryBaseAction . SideBySideView . Line > result = sut . getDiffLines ( diffLines ) ; 
 assertEquals ( expResult , result ) ; 
 // TODO review the generated test code and remove the default call to fail . 
 fail ( ""The test case is a prototype."" ) ; 
 }  ","@ Test 
 public void testGetDiffLines ( ) throws Exception { 
 final String resourceName = ""diff.txt"" ; 
 final List < String > lines = readResourceLines ( resourceName ) ; 
 JobConfigHistoryBaseAction sut = new JobConfigHistoryBaseActionImpl ( ) ; 
 List < JobConfigHistoryBaseAction . SideBySideView . Line > result = sut . getDiffLines ( lines ) ; 
 assertEquals ( 24 , result . size ( ) ) ; 
 }  ",2013-08-27 22:10:05 +0200,2013-08-28 21:48:50 +0200,0,0.5282423965196736
2840,244,https://www.github.com/apache/hama,launchTask(),DESIGN,430,430,430,430,TODO: report the task status,https://www.github.com/apache/hama/commit/64d15f211,https://www.github.com/apache/hama/commit/a4a9503d0f73165bd10fc3c7f96ebfc3b0ab98c9,src/java/org/apache/hama/bsp/GroomServer.java,"public void launchTask() {
// until job is completed, don't accept new task
acceptNewTasks = false;
try {
// TODO: need to move this code to TaskRunner
task.getJobFile();
conf.addResource(task.getJobFile());
BSPJob defaultJobConf = new BSPJob((HamaConfiguration) conf);
Path localJobFile =
          defaultJobConf.getLocalPath(SUBDIR+""/""+task.getTaskID()+""/""+""job.xml"");
Path localJarFile =
          defaultJobConf.getLocalPath(SUBDIR+""/""+task.getTaskID()+""/""+""job.jar"");
LOG.debug(""localJobFile: ""+ localJobFile);
systemFS.copyToLocalFile(new Path(task.getJobFile()), localJobFile);
systemFS.copyToLocalFile(new Path(task.getJobFile().replace("".xml"", "".jar"")), localJarFile);
HamaConfiguration conf = new HamaConfiguration();
conf.addResource(localJobFile);
BSPJob jobConf = new BSPJob(conf, task.getJobID());
jobConf.setJar(localJarFile.toString());
BSP bsp = (BSP) ReflectionUtils.newInstance(jobConf.getBspClass(), conf);
bsp.setPeer(bspPeer);
bsp.start();
} catch (IOException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
// TODO: report the task status
}","public void launchTask() {
taskStatus.setRunState(TaskStatus.State.RUNNING);
try {
// TODO: need to move this code to TaskRunner
task.getJobFile();
conf.addResource(task.getJobFile());
BSPJob defaultJobConf = new BSPJob((HamaConfiguration) conf);
Path localJobFile =
          defaultJobConf.getLocalPath(SUBDIR+""/""+task.getTaskID()+""/""+""job.xml"");
Path localJarFile =
          defaultJobConf.getLocalPath(SUBDIR+""/""+task.getTaskID()+""/""+""job.jar"");
systemFS.copyToLocalFile(new Path(task.getJobFile()), localJobFile);
systemFS.copyToLocalFile(new Path(task.getJobFile().replace("".xml"", "".jar"")), localJarFile);
HamaConfiguration conf = new HamaConfiguration();
conf.addResource(localJobFile);
BSPJob jobConf = new BSPJob(conf, task.getJobID().toString());
jobConf.setJar(localJarFile.toString());
BSP bsp = (BSP) ReflectionUtils.newInstance(jobConf.getBspClass(), conf);
bsp.setPeer(bspPeer);
bsp.start();
} catch (IOException e) {
// TODO Auto-generated catch block
e.printStackTrace();
} finally {
while (true) {
try {
Thread.sleep(1000);
} catch (InterruptedException e) {
e.printStackTrace();
}
// If local/outgoing queues are empty, task is done.
if(bspPeer.localQueue.size() == 0 && bspPeer.outgoingQueues.size() == 0) {
taskStatus.setRunState(TaskStatus.State.SUCCEEDED);
acceptNewTasks = true;
break;
}
}
}
}","public void launchTask ( ) { 
 // until job is completed , don ' t accept new task 
 acceptNewTasks = false ; 
 try { 
 // TODO : need to move this code to TaskRunner 
 task . getJobFile ( ) ; 
 conf . addResource ( task . getJobFile ( ) ) ; 
 BSPJob defaultJobConf = new BSPJob ( ( HamaConfiguration ) conf ) ; 
 Path localJobFile = 
 defaultJobConf . getLocalPath ( SUBDIR + ""/"" + task . getTaskID ( ) + ""/"" + ""job.xml"" ) ; 
 Path localJarFile = 
 defaultJobConf . getLocalPath ( SUBDIR + ""/"" + task . getTaskID ( ) + ""/"" + ""job.jar"" ) ; 
 LOG . debug ( ""localJobFile: "" + localJobFile ) ; 
 systemFS . copyToLocalFile ( new Path ( task . getJobFile ( ) ) , localJobFile ) ; 
 systemFS . copyToLocalFile ( new Path ( task . getJobFile ( ) . replace ( "".xml"" , "".jar"" ) ) , localJarFile ) ; 
 HamaConfiguration conf = new HamaConfiguration ( ) ; 
 conf . addResource ( localJobFile ) ; 
 BSPJob jobConf = new BSPJob ( conf , task . getJobID ( ) ) ; 
 jobConf . setJar ( localJarFile . toString ( ) ) ; 
 BSP bsp = ( BSP ) ReflectionUtils . newInstance ( jobConf . getBspClass ( ) , conf ) ; 
 bsp . setPeer ( bspPeer ) ; 
 bsp . start ( ) ; 
 } catch ( IOException e ) { 
 // TODO Auto - generated catch block 
 e . printStackTrace ( ) ; 
 } 
 // TODO : report the task status 
 }  ","public void launchTask ( ) { 
 taskStatus . setRunState ( TaskStatus . State . RUNNING ) ; 
 try { 
 // TODO : need to move this code to TaskRunner 
 task . getJobFile ( ) ; 
 conf . addResource ( task . getJobFile ( ) ) ; 
 BSPJob defaultJobConf = new BSPJob ( ( HamaConfiguration ) conf ) ; 
 Path localJobFile = 
 defaultJobConf . getLocalPath ( SUBDIR + ""/"" + task . getTaskID ( ) + ""/"" + ""job.xml"" ) ; 
 Path localJarFile = 
 defaultJobConf . getLocalPath ( SUBDIR + ""/"" + task . getTaskID ( ) + ""/"" + ""job.jar"" ) ; 
 systemFS . copyToLocalFile ( new Path ( task . getJobFile ( ) ) , localJobFile ) ; 
 systemFS . copyToLocalFile ( new Path ( task . getJobFile ( ) . replace ( "".xml"" , "".jar"" ) ) , localJarFile ) ; 
 HamaConfiguration conf = new HamaConfiguration ( ) ; 
 conf . addResource ( localJobFile ) ; 
 BSPJob jobConf = new BSPJob ( conf , task . getJobID ( ) . toString ( ) ) ; 
 jobConf . setJar ( localJarFile . toString ( ) ) ; 
 BSP bsp = ( BSP ) ReflectionUtils . newInstance ( jobConf . getBspClass ( ) , conf ) ; 
 bsp . setPeer ( bspPeer ) ; 
 bsp . start ( ) ; 
 } catch ( IOException e ) { 
 // TODO Auto - generated catch block 
 e . printStackTrace ( ) ; 
 } finally { 
 while ( true ) { 
 try { 
 Thread . sleep ( 1000 ) ; 
 } catch ( InterruptedException e ) { 
 e . printStackTrace ( ) ; 
 } 
 // If local / outgoing queues are empty , task is done . 
 if ( bspPeer . localQueue . size ( ) == 0 & & bspPeer . outgoingQueues . size ( ) == 0 ) { 
 taskStatus . setRunState ( TaskStatus . State . SUCCEEDED ) ; 
 acceptNewTasks = true ; 
 break ; 
 } 
 } 
 } 
 }  ",2010-09-06 05:59:11 +0000,2010-10-04 09:11:04 +0000,0,0.9040795049389679
2570,90,https://www.github.com/apache/directory-studio,clickOkButton(),NOT_DESIGN,29,29,29,29,TODO: handle native dialogs,https://www.github.com/apache/directory-studio/commit/397392ad68,https://www.github.com/apache/directory-studio/commit/3c0adb62bb5c99d96dcd85fa157dca069fa07f89,tests/test.integration.ui/src/main/java/org/apache/directory/studio/test/integration/ui/bots/ConnectionFromServerDialogBot.java,"public void clickOkButton()
{
// TODO: handle native dialogs
//super.clickButton( ""OK"" );
super.bot.activeShell().pressShortcut( Keystrokes.SPACE );
}","public void clickOkButton()
{
bot.shell( TITLE ).bot().button( ""OK"" ).click();
}","public void clickOkButton ( ) 
 { 
 // TODO : handle native dialogs 
 // super . clickButton ( ""OK"" ) ; 
 super . bot . activeShell ( ) . pressShortcut ( Keystrokes . SPACE ) ; 
 }  ","public void clickOkButton ( ) 
 { 
 bot . shell ( TITLE ) . bot ( ) . button ( ""OK"" ) . click ( ) ; 
 }  ",2015-03-29 21:40:02 +0000,2015-05-23 22:51:40 +0000,0,0.32196135393764547
2148,167,https://www.github.com/bcdev/beam,createOuputSettingsPanel(),,243,243,243,243,"todo - not working well yet (mp, 21102009)",https://www.github.com/bcdev/beam/commit/0b46e6f4c6,https://www.github.com/bcdev/beam/commit/b9c788188e527304da1cc62ce6e08e05893f7404,beam-gpf-common/src/main/java/org/esa/beam/gpf/common/reproject/ui/ReprojectionForm.java,"private JPanel createOuputSettingsPanel() {
// todo - not working well yet (mp, 21102009)
final JButton outputParamBtn = new JButton(""Output Parameter"");
outputParamBtn.addActionListener(new ActionListener() {
            @Override
public void actionPerformed(ActionEvent e) {
try {
if (sourceProduct == null) {
appContext.handleError(""Please select a product to project.\n"", new NullPointerException());
return;
}
final CoordinateReferenceSystem crs = getTargetCrs();
if (crs == null) {
appContext.handleError(""Please specify a target CRS first.\n"", new NullPointerException());
return;
}
final OutputSizeFormModel formModel = new OutputSizeFormModel(sourceProduct, crs);
final OutputSizeForm form = new OutputSizeForm(formModel);
final ModalDialog modalDialog = new ModalDialog(appContext.getApplicationWindow(),
                                                                    ""Output Parameters"",
                                                                    ModalDialog.ID_OK_CANCEL, null);
modalDialog.setContent(form);
if (modalDialog.show() == ModalDialog.ID_OK) {
outputParameterContainer = formModel.getValueContainer();
}
} catch (Exception fe) {
appContext.handleError(""Could not create target CRS.\n"" +
fe.getMessage(), fe);
}
}
        });
final JPanel resamplePanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 3, 3));
resamplePanel.add(new JLabel(""Resampling Method:""));
resampleComboBox = new JComboBox(RESAMPLING_IDENTIFIER);
resampleComboBox.setPrototypeDisplayValue(RESAMPLING_IDENTIFIER[0]);
resamplePanel.add(resampleComboBox);
includeTPcheck = new JCheckBox(""Include Tie-Point Grids"", true);
final TableLayout tableLayout = new TableLayout(3);
tableLayout.setTableAnchor(TableLayout.Anchor.WEST);
tableLayout.setTableFill(TableLayout.Fill.HORIZONTAL);
tableLayout.setTablePadding(8, 4);
tableLayout.setTableWeightX(1.0);
final JPanel outputSettingsPanel = new JPanel(tableLayout);
outputSettingsPanel.setBorder(BorderFactory.createTitledBorder(""Output Settings""));
outputSettingsPanel.add(outputParamBtn);
outputSettingsPanel.add(resamplePanel);
outputSettingsPanel.add(includeTPcheck);
return outputSettingsPanel;
}","private JPanel createOuputSettingsPanel() {
final JButton outputParamBtn = new JButton(""Output Parameter"");
outputParamBtn.addActionListener(new ActionListener() {
            @Override
public void actionPerformed(ActionEvent e) {
try {
if (sourceProduct == null) {
appContext.handleError(""Please select a product to project.\n"", new IllegalStateException());
return;
}
final CoordinateReferenceSystem crs = getTargetCrs();
if (crs == null) {
appContext.handleError(""Please specify a target CRS first.\n"", new IllegalStateException());
return;
}
final OutputSizeFormModel formModel = new OutputSizeFormModel(sourceProduct, crs);
final OutputSizeForm form = new OutputSizeForm(formModel);
final ModalDialog modalDialog = new ModalDialog(appContext.getApplicationWindow(),
                                                                    ""Output Parameters"",
                                                                    ModalDialog.ID_OK_CANCEL, null);
modalDialog.setContent(form);
if (modalDialog.show() == ModalDialog.ID_OK) {
outputParameterContainer = formModel.getValueContainer();
}
} catch (Exception fe) {
appContext.handleError(""Could not create target CRS.\n"" +
fe.getMessage(), fe);
}
}
        });
final JPanel resamplePanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 3, 3));
resamplePanel.add(new JLabel(""Resampling Method:""));
resampleComboBox = new JComboBox(RESAMPLING_IDENTIFIER);
resampleComboBox.setPrototypeDisplayValue(RESAMPLING_IDENTIFIER[0]);
resamplePanel.add(resampleComboBox);
includeTPcheck = new JCheckBox(""Include Tie-Point Grids"", true);
final TableLayout tableLayout = new TableLayout(3);
tableLayout.setTableAnchor(TableLayout.Anchor.WEST);
tableLayout.setTableFill(TableLayout.Fill.HORIZONTAL);
tableLayout.setTablePadding(8, 4);
tableLayout.setTableWeightX(1.0);
final JPanel outputSettingsPanel = new JPanel(tableLayout);
outputSettingsPanel.setBorder(BorderFactory.createTitledBorder(""Output Settings""));
outputSettingsPanel.add(outputParamBtn);
outputSettingsPanel.add(resamplePanel);
outputSettingsPanel.add(includeTPcheck);
return outputSettingsPanel;
}","private JPanel createOuputSettingsPanel ( ) { 
 // todo - not working well yet ( mp , 21102009 ) 
 final JButton outputParamBtn = new JButton ( ""Output Parameter"" ) ; 
 outputParamBtn . addActionListener ( new ActionListener ( ) { 
 @ Override 
 public void actionPerformed ( ActionEvent e ) { 
 try { 
 if ( sourceProduct == null ) { 
 appContext . handleError ( ""Please select a product to project.\n"" , new NullPointerException ( ) ) ; 
 return ; 
 } 
 final CoordinateReferenceSystem crs = getTargetCrs ( ) ; 
 if ( crs == null ) { 
 appContext . handleError ( ""Please specify a target CRS first.\n"" , new NullPointerException ( ) ) ; 
 return ; 
 } 
 final OutputSizeFormModel formModel = new OutputSizeFormModel ( sourceProduct , crs ) ; 
 final OutputSizeForm form = new OutputSizeForm ( formModel ) ; 
 final ModalDialog modalDialog = new ModalDialog ( appContext . getApplicationWindow ( ) , 
 ""Output Parameters"" , 
 ModalDialog . ID_OK_CANCEL , null ) ; 
 modalDialog . setContent ( form ) ; 
 if ( modalDialog . show ( ) == ModalDialog . ID_OK ) { 
 outputParameterContainer = formModel . getValueContainer ( ) ; 
 } 
 } catch ( Exception fe ) { 
 appContext . handleError ( ""Could not create target CRS.\n"" + 
 fe . getMessage ( ) , fe ) ; 
 } 
 } 
 } ) ; 
 final JPanel resamplePanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT , 3 , 3 ) ) ; 
 resamplePanel . add ( new JLabel ( ""Resampling Method:"" ) ) ; 
 resampleComboBox = new JComboBox ( RESAMPLING_IDENTIFIER ) ; 
 resampleComboBox . setPrototypeDisplayValue ( RESAMPLING_IDENTIFIER [ 0 ] ) ; 
 resamplePanel . add ( resampleComboBox ) ; 
 includeTPcheck = new JCheckBox ( ""Include Tie-Point Grids"" , true ) ; 
 final TableLayout tableLayout = new TableLayout ( 3 ) ; 
 tableLayout . setTableAnchor ( TableLayout . Anchor . WEST ) ; 
 tableLayout . setTableFill ( TableLayout . Fill . HORIZONTAL ) ; 
 tableLayout . setTablePadding ( 8 , 4 ) ; 
 tableLayout . setTableWeightX ( 1.0 ) ; 
 final JPanel outputSettingsPanel = new JPanel ( tableLayout ) ; 
 outputSettingsPanel . setBorder ( BorderFactory . createTitledBorder ( ""Output Settings"" ) ) ; 
 outputSettingsPanel . add ( outputParamBtn ) ; 
 outputSettingsPanel . add ( resamplePanel ) ; 
 outputSettingsPanel . add ( includeTPcheck ) ; 
 return outputSettingsPanel ; 
 }  ","private JPanel createOuputSettingsPanel ( ) { 
 final JButton outputParamBtn = new JButton ( ""Output Parameter"" ) ; 
 outputParamBtn . addActionListener ( new ActionListener ( ) { 
 @ Override 
 public void actionPerformed ( ActionEvent e ) { 
 try { 
 if ( sourceProduct == null ) { 
 appContext . handleError ( ""Please select a product to project.\n"" , new IllegalStateException ( ) ) ; 
 return ; 
 } 
 final CoordinateReferenceSystem crs = getTargetCrs ( ) ; 
 if ( crs == null ) { 
 appContext . handleError ( ""Please specify a target CRS first.\n"" , new IllegalStateException ( ) ) ; 
 return ; 
 } 
 final OutputSizeFormModel formModel = new OutputSizeFormModel ( sourceProduct , crs ) ; 
 final OutputSizeForm form = new OutputSizeForm ( formModel ) ; 
 final ModalDialog modalDialog = new ModalDialog ( appContext . getApplicationWindow ( ) , 
 ""Output Parameters"" , 
 ModalDialog . ID_OK_CANCEL , null ) ; 
 modalDialog . setContent ( form ) ; 
 if ( modalDialog . show ( ) == ModalDialog . ID_OK ) { 
 outputParameterContainer = formModel . getValueContainer ( ) ; 
 } 
 } catch ( Exception fe ) { 
 appContext . handleError ( ""Could not create target CRS.\n"" + 
 fe . getMessage ( ) , fe ) ; 
 } 
 } 
 } ) ; 
 final JPanel resamplePanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT , 3 , 3 ) ) ; 
 resamplePanel . add ( new JLabel ( ""Resampling Method:"" ) ) ; 
 resampleComboBox = new JComboBox ( RESAMPLING_IDENTIFIER ) ; 
 resampleComboBox . setPrototypeDisplayValue ( RESAMPLING_IDENTIFIER [ 0 ] ) ; 
 resamplePanel . add ( resampleComboBox ) ; 
 includeTPcheck = new JCheckBox ( ""Include Tie-Point Grids"" , true ) ; 
 final TableLayout tableLayout = new TableLayout ( 3 ) ; 
 tableLayout . setTableAnchor ( TableLayout . Anchor . WEST ) ; 
 tableLayout . setTableFill ( TableLayout . Fill . HORIZONTAL ) ; 
 tableLayout . setTablePadding ( 8 , 4 ) ; 
 tableLayout . setTableWeightX ( 1.0 ) ; 
 final JPanel outputSettingsPanel = new JPanel ( tableLayout ) ; 
 outputSettingsPanel . setBorder ( BorderFactory . createTitledBorder ( ""Output Settings"" ) ) ; 
 outputSettingsPanel . add ( outputParamBtn ) ; 
 outputSettingsPanel . add ( resamplePanel ) ; 
 outputSettingsPanel . add ( includeTPcheck ) ; 
 return outputSettingsPanel ; 
 }  ",2009-10-21 15:19:06 +0000,2009-10-23 08:17:34 +0000,0,0.9843834859301803
2195,456,https://www.github.com/jakewharton/actionbarsherlock,onCreateOptionsMenu(Menu),NOT_DESIGN,257,257,264,266,TODO honor actionBarWidgetTheme attribute,https://www.github.com/jakewharton/actionbarsherlock/commit/aaf9586a9,https://www.github.com/jakewharton/actionbarsherlock/commit/05daffa84fecbc1787d5868ee3db4eb05432c411,library/src/com/actionbarsherlock/ActionBarSherlock.java,"public void dispatchInvalidateOptionsMenu() {
if (DEBUG) Log.d(TAG, ""[dispatchInvalidateOptionsMenu]"");
if (mMenu == null) {
//TODO honor actionBarWidgetTheme attribute
mMenu = new MenuBuilder(mActivity);
mMenu.setCallback(mMenuBuilderCallback);
}
mMenu.stopDispatchingItemsChanged();
mMenu.clear();
if (!dispatchCreateOptionsMenu()) {
if (mActionBar != null) {
mActionBar.setMenu(null, mMenuPresenterCallback);
}
return;
}
if (!dispatchPrepareOptionsMenu()) {
if (mActionBar != null) {
mActionBar.setMenu(null, mMenuPresenterCallback);
}
mMenu.startDispatchingItemsChanged();
return;
}
//TODO figure out KeyEvent? See PhoneWindow#preparePanel
KeyCharacterMap kmap = KeyCharacterMap.load(KeyCharacterMap.VIRTUAL_KEYBOARD);
mMenu.setQwertyMode(kmap.getKeyboardType() != KeyCharacterMap.NUMERIC);
mMenu.startDispatchingItemsChanged();
mActionBar.setMenu(mMenu, mMenuPresenterCallback);
}","public void dispatchInvalidateOptionsMenu() {
if (DEBUG) Log.d(TAG, ""[dispatchInvalidateOptionsMenu]"");
if (mMenu == null) {
Context context = mActivity;
if (mActionBar != null) {
TypedValue outValue = new TypedValue();
mActivity.getTheme().resolveAttribute(R.attr.actionBarWidgetTheme, outValue, true);
if (outValue.resourceId != 0) {
//We are unable to test if this is the same as our current theme
//so we just wrap it and hope that if the attribute was specified
//then the user is intentionally specifying an alternate theme.
context = new ContextThemeWrapper(context, outValue.resourceId);
}
}
mMenu = new MenuBuilder(context);
mMenu.setCallback(mMenuBuilderCallback);
}
mMenu.stopDispatchingItemsChanged();
mMenu.clear();
if (!dispatchCreateOptionsMenu()) {
if (mActionBar != null) {
mActionBar.setMenu(null, mMenuPresenterCallback);
}
return;
}
if (!dispatchPrepareOptionsMenu()) {
if (mActionBar != null) {
mActionBar.setMenu(null, mMenuPresenterCallback);
}
mMenu.startDispatchingItemsChanged();
return;
}
//TODO figure out KeyEvent? See PhoneWindow#preparePanel
KeyCharacterMap kmap = KeyCharacterMap.load(KeyCharacterMap.VIRTUAL_KEYBOARD);
mMenu.setQwertyMode(kmap.getKeyboardType() != KeyCharacterMap.NUMERIC);
mMenu.startDispatchingItemsChanged();
mActionBar.setMenu(mMenu, mMenuPresenterCallback);
}","public void dispatchInvalidateOptionsMenu ( ) { 
 if ( DEBUG ) Log . d ( TAG , ""[dispatchInvalidateOptionsMenu]"" ) ; 
 if ( mMenu == null ) { 
 // TODO honor actionBarWidgetTheme attribute 
 mMenu = new MenuBuilder ( mActivity ) ; 
 mMenu . setCallback ( mMenuBuilderCallback ) ; 
 } 
 mMenu . stopDispatchingItemsChanged ( ) ; 
 mMenu . clear ( ) ; 
 if ( ! dispatchCreateOptionsMenu ( ) ) { 
 if ( mActionBar != null ) { 
 mActionBar . setMenu ( null , mMenuPresenterCallback ) ; 
 } 
 return ; 
 } 
 if ( ! dispatchPrepareOptionsMenu ( ) ) { 
 if ( mActionBar != null ) { 
 mActionBar . setMenu ( null , mMenuPresenterCallback ) ; 
 } 
 mMenu . startDispatchingItemsChanged ( ) ; 
 return ; 
 } 
 // TODO figure out KeyEvent ? See PhoneWindow #preparePanel 
 KeyCharacterMap kmap = KeyCharacterMap . load ( KeyCharacterMap . VIRTUAL_KEYBOARD ) ; 
 mMenu . setQwertyMode ( kmap . getKeyboardType ( ) != KeyCharacterMap . NUMERIC ) ; 
 mMenu . startDispatchingItemsChanged ( ) ; 
 mActionBar . setMenu ( mMenu , mMenuPresenterCallback ) ; 
 }  ","public void dispatchInvalidateOptionsMenu ( ) { 
 if ( DEBUG ) Log . d ( TAG , ""[dispatchInvalidateOptionsMenu]"" ) ; 
 if ( mMenu == null ) { 
 Context context = mActivity ; 
 if ( mActionBar != null ) { 
 TypedValue outValue = new TypedValue ( ) ; 
 mActivity . getTheme ( ) . resolveAttribute ( R . attr . actionBarWidgetTheme , outValue , true ) ; 
 if ( outValue . resourceId != 0 ) { 
 // We are unable to test if this is the same as our current theme 
 // so we just wrap it and hope that if the attribute was specified 
 // then the user is intentionally specifying an alternate theme . 
 context = new ContextThemeWrapper ( context , outValue . resourceId ) ; 
 } 
 } 
 mMenu = new MenuBuilder ( context ) ; 
 mMenu . setCallback ( mMenuBuilderCallback ) ; 
 } 
 mMenu . stopDispatchingItemsChanged ( ) ; 
 mMenu . clear ( ) ; 
 if ( ! dispatchCreateOptionsMenu ( ) ) { 
 if ( mActionBar != null ) { 
 mActionBar . setMenu ( null , mMenuPresenterCallback ) ; 
 } 
 return ; 
 } 
 if ( ! dispatchPrepareOptionsMenu ( ) ) { 
 if ( mActionBar != null ) { 
 mActionBar . setMenu ( null , mMenuPresenterCallback ) ; 
 } 
 mMenu . startDispatchingItemsChanged ( ) ; 
 return ; 
 } 
 // TODO figure out KeyEvent ? See PhoneWindow #preparePanel 
 KeyCharacterMap kmap = KeyCharacterMap . load ( KeyCharacterMap . VIRTUAL_KEYBOARD ) ; 
 mMenu . setQwertyMode ( kmap . getKeyboardType ( ) != KeyCharacterMap . NUMERIC ) ; 
 mMenu . startDispatchingItemsChanged ( ) ; 
 mActionBar . setMenu ( mMenu , mMenuPresenterCallback ) ; 
 }  ",2011/11/23 1:10,2011/11/29 8:55,0,0.8560023179921401
2942,431,https://www.github.com/kiegroup/optaplanner,readTimeWindowedDepotAndCustomers(),,249,249,249,249,TODO lineTokens 4-6,https://www.github.com/kiegroup/optaplanner/commit/3edc2184645,https://www.github.com/kiegroup/optaplanner/commit/b884d5507b37566be348ef3b184dcfde10af2904,optaplanner-examples/src/main/java/org/optaplanner/examples/vehiclerouting/persistence/VehicleRoutingSolutionImporter.java,"private void readTimeWindowedDepotAndCustomers() throws IOException {
String line = bufferedReader.readLine();
int locationListSizeEstimation = 25;
List<VrpLocation> locationList = new ArrayList<VrpLocation>(locationListSizeEstimation);
depotList = new ArrayList<VrpDepot>(1);
List<VrpCustomer> customerList = new ArrayList<VrpCustomer>(locationListSizeEstimation);
boolean first = true;
while (line != null && !line.trim().isEmpty()) {
String[] lineTokens = splitBySpacesOrTabs(line.trim(), 7);
long id = Long.parseLong(lineTokens[0]);
VrpLocation location = new VrpLocation();
location.setId(id);
location.setLatitude(Double.parseDouble(lineTokens[1]));
location.setLongitude(Double.parseDouble(lineTokens[2]));
locationList.add(location);
if (first) {
VrpDepot depot = new VrpDepot();
depot.setId(id);
depot.setLocation(location);
int demand = Integer.parseInt(lineTokens[3]);
if (demand != 0) {
throw new IllegalArgumentException(""The depot with id ("" + id
+ "") has a demand ("" + demand + "")."");
}
depotList.add(depot);
// TODO lineTokens 4-6
first = false;
} else {
VrpCustomer customer = new VrpCustomer();
customer.setId(id);
customer.setLocation(location);
int demand = Integer.parseInt(lineTokens[3]);
customer.setDemand(demand);
// Notice that we leave the PlanningVariable properties on null
// Do not add a customer that has no demand
if (demand != 0) {
customerList.add(customer);
}
// TODO lineTokens 4-6
}
line = bufferedReader.readLine();
}
schedule.setLocationList(locationList);
schedule.setDepotList(depotList);
schedule.setCustomerList(customerList);
}","private void readTimeWindowedDepotAndCustomers() throws IOException {
String line = bufferedReader.readLine();
int locationListSizeEstimation = 25;
List<VrpLocation> locationList = new ArrayList<VrpLocation>(locationListSizeEstimation);
depotList = new ArrayList<VrpDepot>(1);
List<VrpCustomer> customerList = new ArrayList<VrpCustomer>(locationListSizeEstimation);
boolean first = true;
while (line != null && !line.trim().isEmpty()) {
String[] lineTokens = splitBySpacesOrTabs(line.trim(), 7);
long id = Long.parseLong(lineTokens[0]);
VrpLocation location = new VrpLocation();
location.setId(id);
location.setLatitude(Double.parseDouble(lineTokens[1]));
location.setLongitude(Double.parseDouble(lineTokens[2]));
locationList.add(location);
if (first) {
VrpDepot depot = new VrpDepot();
depot.setId(id);
depot.setLocation(location);
int demand = Integer.parseInt(lineTokens[3]);
if (demand != 0) {
throw new IllegalArgumentException(""The depot with id ("" + id
+ "") has a demand ("" + demand + "")."");
}
// TODO lineTokens 4-5
int serviceTime = Integer.parseInt(lineTokens[6]);
if (serviceTime != 0) {
throw new IllegalArgumentException(""The depot with id ("" + id
+ "") has a serviceTime ("" + serviceTime + "")."");
}
depotList.add(depot);
first = false;
} else {
VrpTimeWindowedCustomer customer = new VrpTimeWindowedCustomer();
customer.setId(id);
customer.setLocation(location);
int demand = Integer.parseInt(lineTokens[3]);
customer.setDemand(demand);
// Notice that we leave the PlanningVariable properties on null
customer.setReadyTime(Integer.parseInt(lineTokens[4]));
customer.setDueTime(Integer.parseInt(lineTokens[5]));
customer.setServiceTime(Integer.parseInt(lineTokens[6]));
// Do not add a customer that has no demand
if (demand != 0) {
customerList.add(customer);
}
}
line = bufferedReader.readLine();
}
schedule.setLocationList(locationList);
schedule.setDepotList(depotList);
schedule.setCustomerList(customerList);
}","private void readTimeWindowedDepotAndCustomers ( ) throws IOException { 
 String line = bufferedReader . readLine ( ) ; 
 int locationListSizeEstimation = 25 ; 
 List < VrpLocation > locationList = new ArrayList < VrpLocation > ( locationListSizeEstimation ) ; 
 depotList = new ArrayList < VrpDepot > ( 1 ) ; 
 List < VrpCustomer > customerList = new ArrayList < VrpCustomer > ( locationListSizeEstimation ) ; 
 boolean first = true ; 
 while ( line != null & &   ! line . trim ( ) . isEmpty ( ) ) { 
 String [ ] lineTokens = splitBySpacesOrTabs ( line . trim ( ) , 7 ) ; 
 long id = Long . parseLong ( lineTokens [ 0 ] ) ; 
 VrpLocation location = new VrpLocation ( ) ; 
 location . setId ( id ) ; 
 location . setLatitude ( Double . parseDouble ( lineTokens [ 1 ] ) ) ; 
 location . setLongitude ( Double . parseDouble ( lineTokens [ 2 ] ) ) ; 
 locationList . add ( location ) ; 
 if ( first ) { 
 VrpDepot depot = new VrpDepot ( ) ; 
 depot . setId ( id ) ; 
 depot . setLocation ( location ) ; 
 int demand = Integer . parseInt ( lineTokens [ 3 ] ) ; 
 if ( demand != 0 ) { 
 throw new IllegalArgumentException ( ""The depot with id ("" + id 
 + "") has a demand ("" + demand + "")."" ) ; 
 } 
 depotList . add ( depot ) ; 
 // TODO lineTokens 4 - 6 
 first = false ; 
 } else { 
 VrpCustomer customer = new VrpCustomer ( ) ; 
 customer . setId ( id ) ; 
 customer . setLocation ( location ) ; 
 int demand = Integer . parseInt ( lineTokens [ 3 ] ) ; 
 customer . setDemand ( demand ) ; 
 // Notice that we leave the PlanningVariable properties on null 
 // Do not add a customer that has no demand 
 if ( demand != 0 ) { 
 customerList . add ( customer ) ; 
 } 
 // TODO lineTokens 4 - 6 
 } 
 line = bufferedReader . readLine ( ) ; 
 } 
 schedule . setLocationList ( locationList ) ; 
 schedule . setDepotList ( depotList ) ; 
 schedule . setCustomerList ( customerList ) ; 
 }  ","private void readTimeWindowedDepotAndCustomers ( ) throws IOException { 
 String line = bufferedReader . readLine ( ) ; 
 int locationListSizeEstimation = 25 ; 
 List < VrpLocation > locationList = new ArrayList < VrpLocation > ( locationListSizeEstimation ) ; 
 depotList = new ArrayList < VrpDepot > ( 1 ) ; 
 List < VrpCustomer > customerList = new ArrayList < VrpCustomer > ( locationListSizeEstimation ) ; 
 boolean first = true ; 
 while ( line != null & &   ! line . trim ( ) . isEmpty ( ) ) { 
 String [ ] lineTokens = splitBySpacesOrTabs ( line . trim ( ) , 7 ) ; 
 long id = Long . parseLong ( lineTokens [ 0 ] ) ; 
 VrpLocation location = new VrpLocation ( ) ; 
 location . setId ( id ) ; 
 location . setLatitude ( Double . parseDouble ( lineTokens [ 1 ] ) ) ; 
 location . setLongitude ( Double . parseDouble ( lineTokens [ 2 ] ) ) ; 
 locationList . add ( location ) ; 
 if ( first ) { 
 VrpDepot depot = new VrpDepot ( ) ; 
 depot . setId ( id ) ; 
 depot . setLocation ( location ) ; 
 int demand = Integer . parseInt ( lineTokens [ 3 ] ) ; 
 if ( demand != 0 ) { 
 throw new IllegalArgumentException ( ""The depot with id ("" + id 
 + "") has a demand ("" + demand + "")."" ) ; 
 } 
 // TODO lineTokens 4 - 5 
 int serviceTime = Integer . parseInt ( lineTokens [ 6 ] ) ; 
 if ( serviceTime != 0 ) { 
 throw new IllegalArgumentException ( ""The depot with id ("" + id 
 + "") has a serviceTime ("" + serviceTime + "")."" ) ; 
 } 
 depotList . add ( depot ) ; 
 first = false ; 
 } else { 
 VrpTimeWindowedCustomer customer = new VrpTimeWindowedCustomer ( ) ; 
 customer . setId ( id ) ; 
 customer . setLocation ( location ) ; 
 int demand = Integer . parseInt ( lineTokens [ 3 ] ) ; 
 customer . setDemand ( demand ) ; 
 // Notice that we leave the PlanningVariable properties on null 
 customer . setReadyTime ( Integer . parseInt ( lineTokens [ 4 ] ) ) ; 
 customer . setDueTime ( Integer . parseInt ( lineTokens [ 5 ] ) ) ; 
 customer . setServiceTime ( Integer . parseInt ( lineTokens [ 6 ] ) ) ; 
 // Do not add a customer that has no demand 
 if ( demand != 0 ) { 
 customerList . add ( customer ) ; 
 } 
 } 
 line = bufferedReader . readLine ( ) ; 
 } 
 schedule . setLocationList ( locationList ) ; 
 schedule . setDepotList ( depotList ) ; 
 schedule . setCustomerList ( customerList ) ; 
 }  ",2013-05-24 15:03:09 +0200,2013-05-24 20:52:54 +0200,0,0.945773676608895
167,72,https://www.github.com/apache/maven-plugins,execute(ReleaseConfiguration),,52,52,52,52,TODO [!]: fix logging,https://www.github.com/apache/maven-plugins/commit/758af4d0a8,https://www.github.com/apache/maven-plugins/commit/d5c32346773fdffbb7d1fb61552050c9d9bfa5f5,maven-release-plugin/src/main/java/org/apache/maven/plugins/release/phase/RunGoalsPhase.java,"public void execute( ReleaseConfiguration releaseConfiguration )
throws ReleaseExecutionException
{
try
        {
if ( !StringUtils.isEmpty( goals ) )
{
// TODO [!]: fix logging
getLogger().info( ""Executing goals '"" + goals + ""'..."" );
mavenExecutor.executeGoals( releaseConfiguration.getWorkingDirectory(), goals,
                                            releaseConfiguration.isInteractive() );
}
}
catch ( MavenExecutorException e )
{
throw new ReleaseExecutionException( e.getMessage(), e );
}
}","public void execute( ReleaseConfiguration releaseConfiguration )
throws ReleaseExecutionException
{
try
        {
String goals = releaseConfiguration.getPreparationGoals();
if ( !StringUtils.isEmpty( goals ) )
{
getLogger().info( ""Executing preparation goals '"" + goals + ""'..."" );
mavenExecutor.executeGoals( releaseConfiguration.getWorkingDirectory(), goals,
                                            releaseConfiguration.isInteractive() );
}
}
catch ( MavenExecutorException e )
{
throw new ReleaseExecutionException( e.getMessage(), e );
}
}","public void execute ( ReleaseConfiguration releaseConfiguration ) 
 throws ReleaseExecutionException 
 { 
 try 
 { 
 if (   ! StringUtils . isEmpty ( goals ) ) 
 { 
 // TODO [ ! ] : fix logging 
 getLogger ( ) . info ( ""Executing goals '"" + goals + ""'..."" ) ; 
 mavenExecutor . executeGoals ( releaseConfiguration . getWorkingDirectory ( ) , goals , 
 releaseConfiguration . isInteractive ( ) ) ; 
 } 
 } 
 catch ( MavenExecutorException e ) 
 { 
 throw new ReleaseExecutionException ( e . getMessage ( ) , e ) ; 
 } 
 }  ","public void execute ( ReleaseConfiguration releaseConfiguration ) 
 throws ReleaseExecutionException 
 { 
 try 
 { 
 String goals = releaseConfiguration . getPreparationGoals ( ) ; 
 if (   ! StringUtils . isEmpty ( goals ) ) 
 { 
 getLogger ( ) . info ( ""Executing preparation goals '"" + goals + ""'..."" ) ; 
 mavenExecutor . executeGoals ( releaseConfiguration . getWorkingDirectory ( ) , goals , 
 releaseConfiguration . isInteractive ( ) ) ; 
 } 
 } 
 catch ( MavenExecutorException e ) 
 { 
 throw new ReleaseExecutionException ( e . getMessage ( ) , e ) ; 
 } 
 }  ",2006-05-02 15:01:27 +0000,2006-05-02 21:33:36 +0000,0,0.9550654202997577
3019,7,https://www.github.com/unclebob/fitnesse,"makeResponse(FitNesseContext, Request)",NOT_DESIGN,59,59,59,59,TODO: find authenticated user,https://www.github.com/unclebob/fitnesse/commit/853b89cfac,https://www.github.com/unclebob/fitnesse/commit/13ea6a4ef8911fec4070f8d53be0778d5a5f98a8,src/fitnesse/responders/files/UploadResponder.java,"public Response makeResponse(FitNesseContext context, Request request) throws IOException {
rootPath = context.getRootPagePath();
SimpleResponse response = new SimpleResponse();
String resource = URLDecoder.decode(request.getResource(), ""UTF-8"");
final UploadedFile uploadedFile = (UploadedFile) request.getInput(""file"");
if (uploadedFile.isUsable()) {
final File file = makeFileToCreate(uploadedFile, resource);
context.versionsController.makeVersion(new FileVersion() {

        @Override
public File getFile() {
return file;
}
@Override
public InputStream getContent() throws IOException {
return new BufferedInputStream(new FileInputStream(uploadedFile.getFile()) {
            @Override
public void close() throws IOException {
super.close();
uploadedFile.getFile().delete();
}
          });
}
@Override
public String getAuthor() {
// TODO: find authenticated user
return null;
}
@Override
public Date getLastModificationTime() {
return new Date();
}

      });
}
response.redirect(""/"" + request.getResource());
return response;
}","public Response makeResponse(FitNesseContext context, Request request) throws IOException {
rootPath = context.getRootPagePath();
SimpleResponse response = new SimpleResponse();
String resource = URLDecoder.decode(request.getResource(), ""UTF-8"");
final UploadedFile uploadedFile = (UploadedFile) request.getInput(""file"");
final String user = request.getAuthorizationUsername();
if (uploadedFile.isUsable()) {
final File file = makeFileToCreate(uploadedFile, resource);
context.versionsController.makeVersion(new FileVersion() {

        @Override
public File getFile() {
return file;
}
@Override
public InputStream getContent() throws IOException {
return new BufferedInputStream(new FileInputStream(uploadedFile.getFile()) {
            @Override
public void close() throws IOException {
super.close();
uploadedFile.getFile().delete();
}
          });
}
@Override
public String getAuthor() {
return user != null ? user : """";
}
@Override
public Date getLastModificationTime() {
return new Date();
}

      });
}
response.redirect(""/"" + request.getResource());
return response;
}","public Response makeResponse ( FitNesseContext context , Request request ) throws IOException { 
 rootPath = context . getRootPagePath ( ) ; 
 SimpleResponse response = new SimpleResponse ( ) ; 
 String resource = URLDecoder . decode ( request . getResource ( ) , ""UTF-8"" ) ; 
 final UploadedFile uploadedFile = ( UploadedFile ) request . getInput ( ""file"" ) ; 
 if ( uploadedFile . isUsable ( ) ) { 
 final File file = makeFileToCreate ( uploadedFile , resource ) ; 
 context . versionsController . makeVersion ( new FileVersion ( ) { 
 
 @ Override 
 public File getFile ( ) { 
 return file ; 
 } 
 @ Override 
 public InputStream getContent ( ) throws IOException { 
 return new BufferedInputStream ( new FileInputStream ( uploadedFile . getFile ( ) ) { 
 @ Override 
 public void close ( ) throws IOException { 
 super . close ( ) ; 
 uploadedFile . getFile ( ) . delete ( ) ; 
 } 
 } ) ; 
 } 
 @ Override 
 public String getAuthor ( ) { 
 // TODO : find authenticated user 
 return null ; 
 } 
 @ Override 
 public Date getLastModificationTime ( ) { 
 return new Date ( ) ; 
 } 
 
 } ) ; 
 } 
 response . redirect ( ""/"" + request . getResource ( ) ) ; 
 return response ; 
 }  ","public Response makeResponse ( FitNesseContext context , Request request ) throws IOException { 
 rootPath = context . getRootPagePath ( ) ; 
 SimpleResponse response = new SimpleResponse ( ) ; 
 String resource = URLDecoder . decode ( request . getResource ( ) , ""UTF-8"" ) ; 
 final UploadedFile uploadedFile = ( UploadedFile ) request . getInput ( ""file"" ) ; 
 final String user = request . getAuthorizationUsername ( ) ; 
 if ( uploadedFile . isUsable ( ) ) { 
 final File file = makeFileToCreate ( uploadedFile , resource ) ; 
 context . versionsController . makeVersion ( new FileVersion ( ) { 
 
 @ Override 
 public File getFile ( ) { 
 return file ; 
 } 
 @ Override 
 public InputStream getContent ( ) throws IOException { 
 return new BufferedInputStream ( new FileInputStream ( uploadedFile . getFile ( ) ) { 
 @ Override 
 public void close ( ) throws IOException { 
 super . close ( ) ; 
 uploadedFile . getFile ( ) . delete ( ) ; 
 } 
 } ) ; 
 } 
 @ Override 
 public String getAuthor ( ) { 
 return user != null   ? user : """" ; 
 } 
 @ Override 
 public Date getLastModificationTime ( ) { 
 return new Date ( ) ; 
 } 
 
 } ) ; 
 } 
 response . redirect ( ""/"" + request . getResource ( ) ) ; 
 return response ; 
 }  ",2013-10-24 16:42:12 +0200,2013-10-24 20:11:40 +0200,0,0.9815008906943168
3773,11,https://www.github.com/nodebox/nodebox,"nodeChanged(Network, Node)",DESIGN,221,221,221,221,TODO: Should set position in other networks.,https://www.github.com/nodebox/nodebox/commit/7d111e44f,https://www.github.com/nodebox/nodebox/commit/06f84a0a08af603f9236ed15b96ee2af3a237cfe,src/net/nodebox/client/NetworkView.java,"public void nodeChanged(Network source, Node node) {
NodeView nv = getNodeView(node);
// TODO: Should set position in other networks.
// nv.setOffset(node.getX(), node.getY());
nv.repaint();
}","public void nodeChanged(Network source, Node node) {
NodeView nv = getNodeView(node);
if (!nv.getOffset().equals(node.getPosition().getPoint2D())) {
nv.setOffset(node.getX(), node.getY());
}
}","public void nodeChanged ( Network source , Node node ) { 
 NodeView nv = getNodeView ( node ) ; 
 // TODO : Should set position in other networks . 
 // nv . setOffset ( node . getX ( ) , node . getY ( ) ) ; 
 nv . repaint ( ) ; 
 }  ","public void nodeChanged ( Network source , Node node ) { 
 NodeView nv = getNodeView ( node ) ; 
 if ( ! nv . getOffset ( ) . equals ( node . getPosition ( ) . getPoint2D ( ) ) ) { 
 nv . setOffset ( node . getX ( ) , node . getY ( ) ) ; 
 } 
 }  ",2008-12-10 23:16:23 +0000,2008-12-11 10:21:33 +0000,0,0.8718725741722229
435,805,https://www.github.com/spacecowboy/notepad,onAttach(Activity),,528,528,510,511,"TODO if this is created from xml, we should load the first note we can find or display a new note.",https://www.github.com/spacecowboy/notepad/commit/14addec24,https://www.github.com/spacecowboy/notepad/commit/1d7f403f6467b503c1dc1b8cd7ab993e46a7b70f,src/com/nononsenseapps/notepad/NotesEditorFragment.java,"@Override
public void onActivityCreated(Bundle saves) {
super.onActivityCreated(saves);
// if Time to Die, do absolutely nothing since this fragment will go bye
// bye
if (timeToDie) {
Log.d(""NotesEditorFragment"",
					""onActivityCreated, but it is time to die so doing nothing..."");
} else {
// TODO if this is created from xml, we should load the first note we can find or display a new note.
// find first note through: SELECT * FROM Table_Name LIMIT 1;
// Use the same select statement the list is using
openNote(saves);
showTheNote();
}
}","@Override
public void onActivityCreated(Bundle saves) {
super.onActivityCreated(saves);
// if Time to Die, do absolutely nothing since this fragment will go bye
// bye
if (timeToDie) {
Log.d(""NotesEditorFragment"",
					""onActivityCreated, but it is time to die so doing nothing..."");
} else {
// TODO if this is created from xml, we should load the first note
// we can find or display a new note.
// find first note through: SELECT * FROM Table_Name LIMIT 1;
// Use the same select statement the list is using
openNote(saves);
}
}","@ Override 
 public void onActivityCreated ( Bundle saves ) { 
 super . onActivityCreated ( saves ) ; 
 // if Time to Die , do absolutely nothing since this fragment will go bye 
 // bye 
 if ( timeToDie ) { 
 Log . d ( ""NotesEditorFragment"" , 
 ""onActivityCreated, but it is time to die so doing nothing..."" ) ; 
 } else { 
 // TODO if this is created from xml , we should load the first note we can find or display a new note . 
 // find first note through : SELECT * FROM Table_Name LIMIT 1 ; 
 // Use the same select statement the list is using 
 openNote ( saves ) ; 
 showTheNote ( ) ; 
 } 
 }  ","@ Override 
 public void onActivityCreated ( Bundle saves ) { 
 super . onActivityCreated ( saves ) ; 
 // if Time to Die , do absolutely nothing since this fragment will go bye 
 // bye 
 if ( timeToDie ) { 
 Log . d ( ""NotesEditorFragment"" , 
 ""onActivityCreated, but it is time to die so doing nothing..."" ) ; 
 } else { 
 // TODO if this is created from xml , we should load the first note 
 // we can find or display a new note . 
 // find first note through : SELECT * FROM Table_Name LIMIT 1 ; 
 // Use the same select statement the list is using 
 openNote ( saves ) ; 
 } 
 }  ",2012-02-04 01:22:31 +0100,2012-02-04 02:36:45 +0100,0,0.9926182481751759
