uuid,p_id,project,method,satd_type,start_line_before,end_line_before,start_line_after,end_line_after,comment,commit_before,commit_after,file_path,function_before,function_after,function_before_tokenized,function_after_tokenized,commit_before_time,commit_after_time,survive_time,similarity
3640,208,https://www.github.com/abarisain/dmix,"connectionStateChanged(boolean, boolean)",NOT_DESIGN,833,833,833,833,TODO : Probably do something here,https://www.github.com/abarisain/dmix/commit/a091478c2,https://www.github.com/abarisain/dmix/commit/57a9b87fc704375da73d1a9336f5a7eb4916dd2c,MPDroid/src/com/namelessdev/mpdroid/NotificationService.java,"@Override
public void connectionStateChanged(boolean connected, boolean connectionLost) {
//TODO : Probably do something here
}","@Override
public void connectionStateChanged(boolean connected, boolean connectionLost) {
if (connected) {
stateChanged(getStatus(), null);
}
}","@ Override 
 public void connectionStateChanged ( boolean connected , boolean connectionLost ) { 
 // TODO : Probably do something here 
 }  ","@ Override 
 public void connectionStateChanged ( boolean connected , boolean connectionLost ) { 
 if ( connected ) { 
 stateChanged ( getStatus ( ) , null ) ; 
 } 
 }  ",2014-01-24 12:50:57 +0100,2014/4/20 19:51,5,0.6455944849185844
3474,725,https://www.github.com/internetarchive/heritrix3,writeRecord(WARCRecordInfo),DESIGN,263,263,263,263,TODO: should this be in the finally block?,https://www.github.com/internetarchive/heritrix3/commit/ef9d2e8c0,https://www.github.com/internetarchive/heritrix3/commit/a04e76f00fa30739075e1031c566a0a87d104822,commons/src/main/java/org/archive/io/warc/WARCWriter.java,"public void writeRecord(WARCRecordInfo recordInfo)
throws IOException {
if (recordInfo.getContentLength() == 0 &&
(recordInfo.getExtraHeaders() == null || recordInfo.getExtraHeaders().size() <= 0)) {
throw new IllegalArgumentException(""Cannot write record "" +
""of content-length zero and base headers only."");
}
String header;
try {
header = createRecordHeader(recordInfo);
} catch (IllegalArgumentException e) {
logger.log(Level.SEVERE,""could not write record type: "" + recordInfo.getType()
+ ""for URL: "" + recordInfo.getUrl(), e);
return;
}
long contentBytes = 0;
long totalBytes = 0;
long startPosition;
try {
startPosition = getPosition();
preWriteRecordTasks();
// TODO: Revisit encoding of header.
byte[] bytes = header.getBytes(WARC_HEADER_ENCODING);
write(bytes);
totalBytes += bytes.length;
if (recordInfo.getContentStream() != null && recordInfo.getContentLength() > 0) {
// Write out the header/body separator.
write(CRLF_BYTES); // TODO: should this be written even for zero-length?
totalBytes += CRLF_BYTES.length;
contentBytes += copyFrom(recordInfo.getContentStream(),
                        recordInfo.getContentLength(),
                        recordInfo.getEnforceLength());
totalBytes += contentBytes;
}
// Write out the two blank lines at end of all records.
write(CRLF_BYTES);
write(CRLF_BYTES);
totalBytes += 2 * CRLF_BYTES.length;
} finally {
postWriteRecordTasks();
}
// TODO: should this be in the finally block?
tally(recordInfo.getType(), contentBytes, totalBytes, getPosition() - startPosition);
}","public void writeRecord(WARCRecordInfo recordInfo)
throws IOException {
if (recordInfo.getContentLength() == 0 &&
(recordInfo.getExtraHeaders() == null || recordInfo.getExtraHeaders().size() <= 0)) {
throw new IllegalArgumentException(""Cannot write record "" +
""of content-length zero and base headers only."");
}
String header;
try {
header = createRecordHeader(recordInfo);
} catch (IllegalArgumentException e) {
logger.log(Level.SEVERE,""could not write record type: "" + recordInfo.getType()
+ ""for URL: "" + recordInfo.getUrl(), e);
return;
}
long contentBytes = 0;
long totalBytes = 0;
long startPosition;
try {
startPosition = getPosition();
preWriteRecordTasks();
// TODO: Revisit encoding of header.
byte[] bytes = header.getBytes(WARC_HEADER_ENCODING);
write(bytes);
totalBytes += bytes.length;
if (recordInfo.getContentStream() != null && recordInfo.getContentLength() > 0) {
// Write out the header/body separator.
write(CRLF_BYTES); // TODO: should this be written even for zero-length?
totalBytes += CRLF_BYTES.length;
contentBytes += copyFrom(recordInfo.getContentStream(),
                        recordInfo.getContentLength(),
                        recordInfo.getEnforceLength());
totalBytes += contentBytes;
}
// Write out the two blank lines at end of all records.
write(CRLF_BYTES);
write(CRLF_BYTES);
totalBytes += 2 * CRLF_BYTES.length;
tally(recordInfo.getType(), contentBytes, totalBytes, getPosition() - startPosition);
recordInfo.setWARCFilename(getFilenameWithoutOccupiedSuffix());
recordInfo.setWARCFileOffset(startPosition);
tmpRecordLog.add(recordInfo);
} finally {
postWriteRecordTasks();
}
}","public void writeRecord ( WARCRecordInfo recordInfo ) 
 throws IOException { 
 if ( recordInfo . getContentLength ( ) == 0 & & 
 ( recordInfo . getExtraHeaders ( ) == null | | recordInfo . getExtraHeaders ( ) . size ( ) <= 0 ) ) { 
 throw new IllegalArgumentException ( ""Cannot write record "" + 
 ""of content-length zero and base headers only."" ) ; 
 } 
 String header ; 
 try { 
 header = createRecordHeader ( recordInfo ) ; 
 } catch ( IllegalArgumentException e ) { 
 logger . log ( Level . SEVERE , ""could not write record type: "" + recordInfo . getType ( ) 
 + ""for URL: "" + recordInfo . getUrl ( ) , e ) ; 
 return ; 
 } 
 long contentBytes = 0 ; 
 long totalBytes = 0 ; 
 long startPosition ; 
 try { 
 startPosition = getPosition ( ) ; 
 preWriteRecordTasks ( ) ; 
 // TODO : Revisit encoding of header . 
 byte [ ] bytes = header . getBytes ( WARC_HEADER_ENCODING ) ; 
 write ( bytes ) ; 
 totalBytes += bytes . length ; 
 if ( recordInfo . getContentStream ( ) != null & & recordInfo . getContentLength ( ) > 0 ) { 
 // Write out the header / body separator . 
 write ( CRLF_BYTES ) ; // TODO : should this be written even for zero - length ? 
 totalBytes += CRLF_BYTES . length ; 
 contentBytes += copyFrom ( recordInfo . getContentStream ( ) , 
 recordInfo . getContentLength ( ) , 
 recordInfo . getEnforceLength ( ) ) ; 
 totalBytes += contentBytes ; 
 } 
 // Write out the two blank lines at end of all records . 
 write ( CRLF_BYTES ) ; 
 write ( CRLF_BYTES ) ; 
 totalBytes += 2 * CRLF_BYTES . length ; 
 } finally { 
 postWriteRecordTasks ( ) ; 
 } 
 // TODO : should this be in the finally block ? 
 tally ( recordInfo . getType ( ) , contentBytes , totalBytes , getPosition ( ) - startPosition ) ; 
 }  ","public void writeRecord ( WARCRecordInfo recordInfo ) 
 throws IOException { 
 if ( recordInfo . getContentLength ( ) == 0 & & 
 ( recordInfo . getExtraHeaders ( ) == null | | recordInfo . getExtraHeaders ( ) . size ( ) <= 0 ) ) { 
 throw new IllegalArgumentException ( ""Cannot write record "" + 
 ""of content-length zero and base headers only."" ) ; 
 } 
 String header ; 
 try { 
 header = createRecordHeader ( recordInfo ) ; 
 } catch ( IllegalArgumentException e ) { 
 logger . log ( Level . SEVERE , ""could not write record type: "" + recordInfo . getType ( ) 
 + ""for URL: "" + recordInfo . getUrl ( ) , e ) ; 
 return ; 
 } 
 long contentBytes = 0 ; 
 long totalBytes = 0 ; 
 long startPosition ; 
 try { 
 startPosition = getPosition ( ) ; 
 preWriteRecordTasks ( ) ; 
 // TODO : Revisit encoding of header . 
 byte [ ] bytes = header . getBytes ( WARC_HEADER_ENCODING ) ; 
 write ( bytes ) ; 
 totalBytes += bytes . length ; 
 if ( recordInfo . getContentStream ( ) != null & & recordInfo . getContentLength ( ) > 0 ) { 
 // Write out the header / body separator . 
 write ( CRLF_BYTES ) ; // TODO : should this be written even for zero - length ? 
 totalBytes += CRLF_BYTES . length ; 
 contentBytes += copyFrom ( recordInfo . getContentStream ( ) , 
 recordInfo . getContentLength ( ) , 
 recordInfo . getEnforceLength ( ) ) ; 
 totalBytes += contentBytes ; 
 } 
 // Write out the two blank lines at end of all records . 
 write ( CRLF_BYTES ) ; 
 write ( CRLF_BYTES ) ; 
 totalBytes += 2 * CRLF_BYTES . length ; 
 tally ( recordInfo . getType ( ) , contentBytes , totalBytes , getPosition ( ) - startPosition ) ; 
 recordInfo . setWARCFilename ( getFilenameWithoutOccupiedSuffix ( ) ) ; 
 recordInfo . setWARCFileOffset ( startPosition ) ; 
 tmpRecordLog . add ( recordInfo ) ; 
 } finally { 
 postWriteRecordTasks ( ) ; 
 } 
 }  ",2011-01-12 00:54:01 +0000,2012/9/11 10:10,1,0.9864192972058343
334,184,https://www.github.com/basho/riak-java-client,byDefaultSiblingsThrowUnresolvedExceptionOnStore(),DESIGN,162,162,162,162,TODO clean up your mess (teardown),https://www.github.com/basho/riak-java-client/commit/3619eb6e8,https://www.github.com/basho/riak-java-client/commit/54d06756c5e5c9f9b81b46485f6db39dcb78a102,src/test/java/com/basho/riak/client/itest/ITestBucket.java,"@Ignore(""non-deterministic"")
@Test public void byDefaultSiblingsThrowUnresolvedExceptionOnStore() throws Exception {
final String bucketName = UUID.randomUUID().toString();
final Bucket b = client.createBucket(bucketName).allowSiblings(true).execute();
b.store(""k"", ""v"").execute();
final int numThreads = 2;
final Collection<Callable<Boolean>> storers = new ArrayList<Callable<Boolean>>(numThreads);
final ExecutorService es = Executors.newFixedThreadPool(numThreads);
for (int i = 0; i < numThreads; i++) {
final IRiakClient c = getClient();
c.generateAndSetClientId();
final Bucket bucket = c.fetchBucket(bucketName).execute();
storers.add(new Callable<Boolean>() {
                public Boolean call() throws RiakException {
try {
for (int i = 0; i < 5; i++) {
bucket.store(""k"", Thread.currentThread().getName() + ""v"" + i).execute();
Thread.sleep(50);
}
} catch (InterruptedException e) {
Thread.currentThread().interrupt();
}
return true;
}
            });
}
Collection<Future<Boolean>> results = es.invokeAll(storers);
for (Future<Boolean> f : results) {
try {
f.get();
fail(""Expected siblings"");
} catch (ExecutionException e) {
assertEquals(UnresolvedConflictException.class, e.getCause().getClass());
}
}
// TODO clean up your mess (teardown)
}","@Ignore(""non-deterministic"")
@Test public void byDefaultSiblingsThrowUnresolvedExceptionOnStore() throws Exception {
final Bucket b = client.createBucket(bucketName).allowSiblings(true).execute();
b.store(""k"", ""v"").execute();
final int numThreads = 2;
final Collection<Callable<Boolean>> storers = new ArrayList<Callable<Boolean>>(numThreads);
final ExecutorService es = Executors.newFixedThreadPool(numThreads);
for (int i = 0; i < numThreads; i++) {
final IRiakClient c = getClient();
c.generateAndSetClientId();
final Bucket bucket = c.fetchBucket(bucketName).execute();
storers.add(new Callable<Boolean>() {
                public Boolean call() throws RiakException {
try {
for (int i = 0; i < 5; i++) {
bucket.store(""k"", Thread.currentThread().getName() + ""v"" + i).execute();
Thread.sleep(50);
}
} catch (InterruptedException e) {
Thread.currentThread().interrupt();
}
return true;
}
            });
}
Collection<Future<Boolean>> results = es.invokeAll(storers);
for (Future<Boolean> f : results) {
try {
f.get();
fail(""Expected siblings"");
} catch (ExecutionException e) {
assertEquals(UnresolvedConflictException.class, e.getCause().getClass());
}
}
client.updateBucket(b).allowSiblings(false).execute();
}","@ Ignore ( ""non-deterministic"" ) 
 @ Test public void byDefaultSiblingsThrowUnresolvedExceptionOnStore ( ) throws Exception { 
 final String bucketName = UUID . randomUUID ( ) . toString ( ) ; 
 final Bucket b = client . createBucket ( bucketName ) . allowSiblings ( true ) . execute ( ) ; 
 b . store ( ""k"" , ""v"" ) . execute ( ) ; 
 final int numThreads = 2 ; 
 final Collection < Callable < Boolean >> storers = new ArrayList < Callable < Boolean >> ( numThreads ) ; 
 final ExecutorService es = Executors . newFixedThreadPool ( numThreads ) ; 
 for ( int i = 0 ; i < numThreads ; i + + ) { 
 final IRiakClient c = getClient ( ) ; 
 c . generateAndSetClientId ( ) ; 
 final Bucket bucket = c . fetchBucket ( bucketName ) . execute ( ) ; 
 storers . add ( new Callable < Boolean > ( ) { 
 public Boolean call ( ) throws RiakException { 
 try { 
 for ( int i = 0 ; i < 5 ; i + + ) { 
 bucket . store ( ""k"" , Thread . currentThread ( ) . getName ( ) + ""v"" + i ) . execute ( ) ; 
 Thread . sleep ( 50 ) ; 
 } 
 } catch ( InterruptedException e ) { 
 Thread . currentThread ( ) . interrupt ( ) ; 
 } 
 return true ; 
 } 
 } ) ; 
 } 
 Collection < Future < Boolean >> results = es . invokeAll ( storers ) ; 
 for ( Future < Boolean > f : results ) { 
 try { 
 f . get ( ) ; 
 fail ( ""Expected siblings"" ) ; 
 } catch ( ExecutionException e ) { 
 assertEquals ( UnresolvedConflictException . class , e . getCause ( ) . getClass ( ) ) ; 
 } 
 } 
 // TODO clean up your mess ( teardown ) 
 }  ","@ Ignore ( ""non-deterministic"" ) 
 @ Test public void byDefaultSiblingsThrowUnresolvedExceptionOnStore ( ) throws Exception { 
 final Bucket b = client . createBucket ( bucketName ) . allowSiblings ( true ) . execute ( ) ; 
 b . store ( ""k"" , ""v"" ) . execute ( ) ; 
 final int numThreads = 2 ; 
 final Collection < Callable < Boolean >> storers = new ArrayList < Callable < Boolean >> ( numThreads ) ; 
 final ExecutorService es = Executors . newFixedThreadPool ( numThreads ) ; 
 for ( int i = 0 ; i < numThreads ; i + + ) { 
 final IRiakClient c = getClient ( ) ; 
 c . generateAndSetClientId ( ) ; 
 final Bucket bucket = c . fetchBucket ( bucketName ) . execute ( ) ; 
 storers . add ( new Callable < Boolean > ( ) { 
 public Boolean call ( ) throws RiakException { 
 try { 
 for ( int i = 0 ; i < 5 ; i + + ) { 
 bucket . store ( ""k"" , Thread . currentThread ( ) . getName ( ) + ""v"" + i ) . execute ( ) ; 
 Thread . sleep ( 50 ) ; 
 } 
 } catch ( InterruptedException e ) { 
 Thread . currentThread ( ) . interrupt ( ) ; 
 } 
 return true ; 
 } 
 } ) ; 
 } 
 Collection < Future < Boolean >> results = es . invokeAll ( storers ) ; 
 for ( Future < Boolean > f : results ) { 
 try { 
 f . get ( ) ; 
 fail ( ""Expected siblings"" ) ; 
 } catch ( ExecutionException e ) { 
 assertEquals ( UnresolvedConflictException . class , e . getCause ( ) . getClass ( ) ) ; 
 } 
 } 
 client . updateBucket ( b ) . allowSiblings ( false ) . execute ( ) ; 
 }  ",2011-04-14 17:27:40 +0100,2012-02-10 09:34:39 +0000,5,0.9572472966983421
101,185,https://www.github.com/liato/android-bankdroid,generateLegacyProviderReferences(),,42,42,42,42,TODO log if provider could not be mapped.,https://www.github.com/liato/android-bankdroid/commit/d36af84b,https://www.github.com/liato/android-bankdroid/commit/94072b6173bdcbe1f96146cf1587cdc359ea3139,bankdroid-legacy/src/main/java/com/liato/bankdroid/banking/LegacyBankHelper.java,"private static void generateLegacyProviderReferences() {
Map<Integer, String> references = new HashMap<>();
Map<String, Integer> legacyIds = new HashMap<>();
Field[] fields = IBankTypes.class.getFields();
for(int i = 0 ; i < fields.length; i++) {
Field field = fields[i];
try {
String reference = field.getName().toLowerCase().replaceAll(""_"", ""-"");
Integer legacyId = field.getInt(new IBankTypes() {
                });
references.put(legacyId, reference);
legacyIds.put(reference, legacyId);
} catch(IllegalAccessException e) {
//TODO log if provider could not be mapped.
}
}
legacyProviderReferences = legacyIds;
providerReferences = references;
}","private static void generateLegacyProviderReferences() {
Map<Integer, String> references = new HashMap<>();
Map<String, Integer> legacyIds = new HashMap<>();
Field[] fields = IBankTypes.class.getFields();
for(int i = 0 ; i < fields.length; i++) {
Field field = fields[i];
try {
String reference = field.getName().toLowerCase().replaceAll(""_"", ""-"");
Integer legacyId = field.getInt(new IBankTypes() {
                });
references.put(legacyId, reference);
legacyIds.put(reference, legacyId);
} catch(IllegalAccessException e) {
Timber.e(e, ""Provider could not be mapped"");
}
}
legacyProviderReferences = legacyIds;
providerReferences = references;
}","private static void generateLegacyProviderReferences ( ) { 
 Map < Integer , String > references = new HashMap < > ( ) ; 
 Map < String , Integer > legacyIds = new HashMap < > ( ) ; 
 Field [ ] fields = IBankTypes . class . getFields ( ) ; 
 for ( int i = 0 ; i < fields . length ; i + + ) { 
 Field field = fields [ i ] ; 
 try { 
 String reference = field . getName ( ) . toLowerCase ( ) . replaceAll ( ""_"" , ""-"" ) ; 
 Integer legacyId = field . getInt ( new IBankTypes ( ) { 
 } ) ; 
 references . put ( legacyId , reference ) ; 
 legacyIds . put ( reference , legacyId ) ; 
 } catch ( IllegalAccessException e ) { 
 // TODO log if provider could not be mapped . 
 } 
 } 
 legacyProviderReferences = legacyIds ; 
 providerReferences = references ; 
 }  ","private static void generateLegacyProviderReferences ( ) { 
 Map < Integer , String > references = new HashMap < > ( ) ; 
 Map < String , Integer > legacyIds = new HashMap < > ( ) ; 
 Field [ ] fields = IBankTypes . class . getFields ( ) ; 
 for ( int i = 0 ; i < fields . length ; i + + ) { 
 Field field = fields [ i ] ; 
 try { 
 String reference = field . getName ( ) . toLowerCase ( ) . replaceAll ( ""_"" , ""-"" ) ; 
 Integer legacyId = field . getInt ( new IBankTypes ( ) { 
 } ) ; 
 references . put ( legacyId , reference ) ; 
 legacyIds . put ( reference , legacyId ) ; 
 } catch ( IllegalAccessException e ) { 
 Timber . e ( e , ""Provider could not be mapped"" ) ; 
 } 
 } 
 legacyProviderReferences = legacyIds ; 
 providerReferences = references ; 
 }  ",2015-08-28 14:39:36 +0200,2016-10-27 08:36:11 +0200,12,0.991066106644242
2822,193,https://www.github.com/graylog2/graylog2-server,onStart(Application),,92,92,92,92,"TODO DI this is wrong, can we use the factory already here?",https://www.github.com/graylog2/graylog2-server/commit/bcbc9a50788,https://www.github.com/graylog2/graylog2-server/commit/9883bbff4ec4396b6f7ff6d51880f9af5a89978b,app/Global.java,"@Override
public void onStart(Application app) {
final String appSecret = app.configuration().getString(""application.secret"");
if (appSecret == null || appSecret.isEmpty()) {
log.error(""Please configure application.secret in your conf/graylog2-web-interface.conf"");
throw new IllegalStateException(""No application.secret configured."");
}
if (appSecret.length() < 16) {
log.error(""Please configure application.secret in your conf/graylog2-web-interface.conf to be longer than 16 characters. Suggested is using pwgen -s 96 or similar"");
throw new IllegalStateException(""application.secret is too short, use at least 16 characters! Suggested is to use pwgen -s 96 or similar"");
}
final String graylog2ServerUris = app.configuration().getString(""graylog2-server.uris"", """");
if (graylog2ServerUris.isEmpty()) {
log.error(""graylog2-server.uris is not set!"");
throw new IllegalStateException(""graylog2-server.uris is empty"");
}
final String[] uris = graylog2ServerUris.split("","");
if (uris.length == 0) {
log.error(""graylog2-server.uris is empty!"");
throw new IllegalStateException(""graylog2-server.uris is empty"");
}
final Node[] initialNodes = new Node[uris.length];
int i = 0;
for (String uri : uris) {
final NodeSummaryResponse r = new NodeSummaryResponse();
r.transportAddress = uri;
initialNodes[i++] = new Node(r); // TODO DI this is wrong, can we use the factory already here?
}
List<Module> modules = Lists.newArrayList();
modules.add(new AbstractModule() {
            @Override
protected void configure() {
bind(Node[].class).annotatedWith(Names.named(""Initial Nodes"")).toInstance(initialNodes);
}
        });
modules.add(new ModelFactoryModule());
injector = Guice.createInjector(modules);
// start the services that need starting
final ApiClient api = injector.getInstance(ApiClient.class);
api.start();
injector.getInstance(ServerNodesRefreshService.class).start();
// TODO replace with custom AuthenticatedAction filter
RedirectAuthenticator.userService = injector.getInstance(UserService.class);
// temporarily disabled for preview to prevent confusion.
//        LocalAdminUserRealm localAdminRealm = new LocalAdminUserRealm(""local-accounts"");
//        localAdminRealm.setCredentialsMatcher(new HashedCredentialsMatcher(""SHA2""));
//        setupLocalUser(api, localAdminRealm, app);
Realm serverRestInterfaceRealm = injector.getInstance(ServerRestInterfaceRealm.class);
final DefaultSecurityManager securityManager =
                new DefaultSecurityManager(
                        Lists.newArrayList(serverRestInterfaceRealm)
                );
final Authenticator authenticator = securityManager.getAuthenticator();
if (authenticator instanceof ModularRealmAuthenticator) {
ModularRealmAuthenticator a = (ModularRealmAuthenticator) authenticator;
a.setAuthenticationStrategy(new RethrowingFirstSuccessfulStrategy());
a.setAuthenticationListeners(
                    Lists.<AuthenticationListener>newArrayList(new PlayAuthenticationListener())
            );
}
SecurityUtils.setSecurityManager(securityManager);
}","@Override
public void onStart(Application app) {
final String appSecret = app.configuration().getString(""application.secret"");
if (appSecret == null || appSecret.isEmpty()) {
log.error(""Please configure application.secret in your conf/graylog2-web-interface.conf"");
throw new IllegalStateException(""No application.secret configured."");
}
if (appSecret.length() < 16) {
log.error(""Please configure application.secret in your conf/graylog2-web-interface.conf to be longer than 16 characters. Suggested is using pwgen -s 96 or similar"");
throw new IllegalStateException(""application.secret is too short, use at least 16 characters! Suggested is to use pwgen -s 96 or similar"");
}
final String graylog2ServerUris = app.configuration().getString(""graylog2-server.uris"", """");
if (graylog2ServerUris.isEmpty()) {
log.error(""graylog2-server.uris is not set!"");
throw new IllegalStateException(""graylog2-server.uris is empty"");
}
final String[] uris = graylog2ServerUris.split("","");
if (uris.length == 0) {
log.error(""graylog2-server.uris is empty!"");
throw new IllegalStateException(""graylog2-server.uris is empty"");
}
final URI[] initialNodes = new URI[uris.length];
int i = 0;
for (String uri : uris) {
initialNodes[i++] = URI.create(uri);
}
List<Module> modules = Lists.newArrayList();
modules.add(new AbstractModule() {
            @Override
protected void configure() {
bind(URI[].class).annotatedWith(Names.named(""Initial Nodes"")).toInstance(initialNodes);
}
        });
modules.add(new ModelFactoryModule());
injector = Guice.createInjector(modules);
// start the services that need starting
final ApiClient api = injector.getInstance(ApiClient.class);
api.start();
injector.getInstance(ServerNodesRefreshService.class).start();
// TODO replace with custom AuthenticatedAction filter
RedirectAuthenticator.userService = injector.getInstance(UserService.class);
// temporarily disabled for preview to prevent confusion.
//        LocalAdminUserRealm localAdminRealm = new LocalAdminUserRealm(""local-accounts"");
//        localAdminRealm.setCredentialsMatcher(new HashedCredentialsMatcher(""SHA2""));
//        setupLocalUser(api, localAdminRealm, app);
Realm serverRestInterfaceRealm = injector.getInstance(ServerRestInterfaceRealm.class);
final DefaultSecurityManager securityManager =
                new DefaultSecurityManager(
                        Lists.newArrayList(serverRestInterfaceRealm)
                );
final Authenticator authenticator = securityManager.getAuthenticator();
if (authenticator instanceof ModularRealmAuthenticator) {
ModularRealmAuthenticator a = (ModularRealmAuthenticator) authenticator;
a.setAuthenticationStrategy(new RethrowingFirstSuccessfulStrategy());
a.setAuthenticationListeners(
                    Lists.<AuthenticationListener>newArrayList(new PlayAuthenticationListener())
            );
}
SecurityUtils.setSecurityManager(securityManager);
}","@ Override 
 public void onStart ( Application app ) { 
 final String appSecret = app . configuration ( ) . getString ( ""application.secret"" ) ; 
 if ( appSecret == null | | appSecret . isEmpty ( ) ) { 
 log . error ( ""Please configure application.secret in your conf/graylog2-web-interface.conf"" ) ; 
 throw new IllegalStateException ( ""No application.secret configured."" ) ; 
 } 
 if ( appSecret . length ( ) < 16 ) { 
 log . error ( ""Please configure application.secret in your conf/graylog2-web-interface.conf to be longer than 16 characters. Suggested is using pwgen -s 96 or similar"" ) ; 
 throw new IllegalStateException ( ""application.secret is too short, use at least 16 characters! Suggested is to use pwgen -s 96 or similar"" ) ; 
 } 
 final String graylog2ServerUris = app . configuration ( ) . getString ( ""graylog2-server.uris"" , """" ) ; 
 if ( graylog2ServerUris . isEmpty ( ) ) { 
 log . error ( ""graylog2-server.uris is not set!"" ) ; 
 throw new IllegalStateException ( ""graylog2-server.uris is empty"" ) ; 
 } 
 final String [ ] uris = graylog2ServerUris . split ( "","" ) ; 
 if ( uris . length == 0 ) { 
 log . error ( ""graylog2-server.uris is empty!"" ) ; 
 throw new IllegalStateException ( ""graylog2-server.uris is empty"" ) ; 
 } 
 final Node [ ] initialNodes = new Node [ uris . length ] ; 
 int i = 0 ; 
 for ( String uri : uris ) { 
 final NodeSummaryResponse r = new NodeSummaryResponse ( ) ; 
 r . transportAddress = uri ; 
 initialNodes [ i + + ] = new Node ( r ) ; // TODO DI this is wrong , can we use the factory already here ? 
 } 
 List < Module > modules = Lists . newArrayList ( ) ; 
 modules . add ( new AbstractModule ( ) { 
 @ Override 
 protected void configure ( ) { 
 bind ( Node [ ] . class ) . annotatedWith ( Names . named ( ""Initial Nodes"" ) ) . toInstance ( initialNodes ) ; 
 } 
 } ) ; 
 modules . add ( new ModelFactoryModule ( ) ) ; 
 injector = Guice . createInjector ( modules ) ; 
 // start the services that need starting 
 final ApiClient api = injector . getInstance ( ApiClient . class ) ; 
 api . start ( ) ; 
 injector . getInstance ( ServerNodesRefreshService . class ) . start ( ) ; 
 // TODO replace with custom AuthenticatedAction filter 
 RedirectAuthenticator . userService = injector . getInstance ( UserService . class ) ; 
 // temporarily disabled for preview to prevent confusion . 
 // LocalAdminUserRealm localAdminRealm = new LocalAdminUserRealm ( ""local-accounts"" ) ; 
 // localAdminRealm . setCredentialsMatcher ( new HashedCredentialsMatcher ( ""SHA2"" ) ) ; 
 // setupLocalUser ( api , localAdminRealm , app ) ; 
 Realm serverRestInterfaceRealm = injector . getInstance ( ServerRestInterfaceRealm . class ) ; 
 final DefaultSecurityManager securityManager = 
 new DefaultSecurityManager ( 
 Lists . newArrayList ( serverRestInterfaceRealm ) 
 ) ; 
 final Authenticator authenticator = securityManager . getAuthenticator ( ) ; 
 if ( authenticator instanceof ModularRealmAuthenticator ) { 
 ModularRealmAuthenticator a = ( ModularRealmAuthenticator ) authenticator ; 
 a . setAuthenticationStrategy ( new RethrowingFirstSuccessfulStrategy ( ) ) ; 
 a . setAuthenticationListeners ( 
 Lists . < AuthenticationListener > newArrayList ( new PlayAuthenticationListener ( ) ) 
 ) ; 
 } 
 SecurityUtils . setSecurityManager ( securityManager ) ; 
 }  ","@ Override 
 public void onStart ( Application app ) { 
 final String appSecret = app . configuration ( ) . getString ( ""application.secret"" ) ; 
 if ( appSecret == null | | appSecret . isEmpty ( ) ) { 
 log . error ( ""Please configure application.secret in your conf/graylog2-web-interface.conf"" ) ; 
 throw new IllegalStateException ( ""No application.secret configured."" ) ; 
 } 
 if ( appSecret . length ( ) < 16 ) { 
 log . error ( ""Please configure application.secret in your conf/graylog2-web-interface.conf to be longer than 16 characters. Suggested is using pwgen -s 96 or similar"" ) ; 
 throw new IllegalStateException ( ""application.secret is too short, use at least 16 characters! Suggested is to use pwgen -s 96 or similar"" ) ; 
 } 
 final String graylog2ServerUris = app . configuration ( ) . getString ( ""graylog2-server.uris"" , """" ) ; 
 if ( graylog2ServerUris . isEmpty ( ) ) { 
 log . error ( ""graylog2-server.uris is not set!"" ) ; 
 throw new IllegalStateException ( ""graylog2-server.uris is empty"" ) ; 
 } 
 final String [ ] uris = graylog2ServerUris . split ( "","" ) ; 
 if ( uris . length == 0 ) { 
 log . error ( ""graylog2-server.uris is empty!"" ) ; 
 throw new IllegalStateException ( ""graylog2-server.uris is empty"" ) ; 
 } 
 final URI [ ] initialNodes = new URI [ uris . length ] ; 
 int i = 0 ; 
 for ( String uri : uris ) { 
 initialNodes [ i + + ] = URI . create ( uri ) ; 
 } 
 List < Module > modules = Lists . newArrayList ( ) ; 
 modules . add ( new AbstractModule ( ) { 
 @ Override 
 protected void configure ( ) { 
 bind ( URI [ ] . class ) . annotatedWith ( Names . named ( ""Initial Nodes"" ) ) . toInstance ( initialNodes ) ; 
 } 
 } ) ; 
 modules . add ( new ModelFactoryModule ( ) ) ; 
 injector = Guice . createInjector ( modules ) ; 
 // start the services that need starting 
 final ApiClient api = injector . getInstance ( ApiClient . class ) ; 
 api . start ( ) ; 
 injector . getInstance ( ServerNodesRefreshService . class ) . start ( ) ; 
 // TODO replace with custom AuthenticatedAction filter 
 RedirectAuthenticator . userService = injector . getInstance ( UserService . class ) ; 
 // temporarily disabled for preview to prevent confusion . 
 // LocalAdminUserRealm localAdminRealm = new LocalAdminUserRealm ( ""local-accounts"" ) ; 
 // localAdminRealm . setCredentialsMatcher ( new HashedCredentialsMatcher ( ""SHA2"" ) ) ; 
 // setupLocalUser ( api , localAdminRealm , app ) ; 
 Realm serverRestInterfaceRealm = injector . getInstance ( ServerRestInterfaceRealm . class ) ; 
 final DefaultSecurityManager securityManager = 
 new DefaultSecurityManager ( 
 Lists . newArrayList ( serverRestInterfaceRealm ) 
 ) ; 
 final Authenticator authenticator = securityManager . getAuthenticator ( ) ; 
 if ( authenticator instanceof ModularRealmAuthenticator ) { 
 ModularRealmAuthenticator a = ( ModularRealmAuthenticator ) authenticator ; 
 a . setAuthenticationStrategy ( new RethrowingFirstSuccessfulStrategy ( ) ) ; 
 a . setAuthenticationListeners ( 
 Lists . < AuthenticationListener > newArrayList ( new PlayAuthenticationListener ( ) ) 
 ) ; 
 } 
 SecurityUtils . setSecurityManager ( securityManager ) ; 
 }  ",2013-09-30 13:14:07 +0200,2013-10-22 16:39:20 +0200,5,0.9772298824284854
2210,307,https://www.github.com/spring-projects/spring-amqp,"doSend(Channel, String, String, Message)",NOT_DESIGN,335,335,335,335,TODO parameterize out default encoding,https://www.github.com/spring-projects/spring-amqp/commit/4bddd15e1,https://www.github.com/spring-projects/spring-amqp/commit/b9d2f6de606ecad10a55fc427f16163df446b90c,spring-rabbit/src/main/java/org/springframework/amqp/rabbit/core/RabbitTemplate.java,"private void doSend(Channel channel, String exchange, String routingKey, Message message) throws Exception {
if (logger.isDebugEnabled()) {
logger.debug(""Publishing message on exchange ["" + exchange + ""], routingKey = ["" + routingKey + ""]"");
}
if (exchange == null) {
// try to send to configured exchange
exchange = this.exchange;
}
if (routingKey == null) {
// try to send to configured routing key
routingKey = this.routingKey;
}
// TODO parameterize out default encoding
channel.basicPublish(exchange, routingKey, false, false, RabbitUtils.extractBasicProperties(message, ""UTF-8""),
				message.getBody());
// Check commit - avoid commit call within a JTA transaction.
if (isChannelLocallyTransacted(channel)) {
// Transacted channel created by this template -> commit.
RabbitUtils.commitIfNecessary(channel);
}
}","private void doSend(Channel channel, String exchange, String routingKey, Message message) throws Exception {
if (logger.isDebugEnabled()) {
logger.debug(""Publishing message on exchange ["" + exchange + ""], routingKey = ["" + routingKey + ""]"");
}
if (exchange == null) {
// try to send to configured exchange
exchange = this.exchange;
}
if (routingKey == null) {
// try to send to configured routing key
routingKey = this.routingKey;
}
channel.basicPublish(exchange, routingKey, false, false, RabbitUtils.extractBasicProperties(message, encoding),
				message.getBody());
// Check commit - avoid commit call within a JTA transaction.
if (isChannelLocallyTransacted(channel)) {
// Transacted channel created by this template -> commit.
RabbitUtils.commitIfNecessary(channel);
}
}","private void doSend ( Channel channel , String exchange , String routingKey , Message message ) throws Exception { 
 if ( logger . isDebugEnabled ( ) ) { 
 logger . debug ( ""Publishing message on exchange ["" + exchange + ""], routingKey = ["" + routingKey + ""]"" ) ; 
 } 
 if ( exchange == null ) { 
 // try to send to configured exchange 
 exchange = this . exchange ; 
 } 
 if ( routingKey == null ) { 
 // try to send to configured routing key 
 routingKey = this . routingKey ; 
 } 
 // TODO parameterize out default encoding 
 channel . basicPublish ( exchange , routingKey , false , false , RabbitUtils . extractBasicProperties ( message , ""UTF-8"" ) , 
 message . getBody ( ) ) ; 
 // Check commit - avoid commit call within a JTA transaction . 
 if ( isChannelLocallyTransacted ( channel ) ) { 
 // Transacted channel created by this template -> commit . 
 RabbitUtils . commitIfNecessary ( channel ) ; 
 } 
 }  ","private void doSend ( Channel channel , String exchange , String routingKey , Message message ) throws Exception { 
 if ( logger . isDebugEnabled ( ) ) { 
 logger . debug ( ""Publishing message on exchange ["" + exchange + ""], routingKey = ["" + routingKey + ""]"" ) ; 
 } 
 if ( exchange == null ) { 
 // try to send to configured exchange 
 exchange = this . exchange ; 
 } 
 if ( routingKey == null ) { 
 // try to send to configured routing key 
 routingKey = this . routingKey ; 
 } 
 channel . basicPublish ( exchange , routingKey , false , false , RabbitUtils . extractBasicProperties ( message , encoding ) , 
 message . getBody ( ) ) ; 
 // Check commit - avoid commit call within a JTA transaction . 
 if ( isChannelLocallyTransacted ( channel ) ) { 
 // Transacted channel created by this template -> commit . 
 RabbitUtils . commitIfNecessary ( channel ) ; 
 } 
 }  ",2010-11-10 21:42:11 +0000,2011-03-23 18:09:06 +0000,1,0.9908009054574909
753,525,https://www.github.com/apache/karaf-cellar,pull(Group),DESIGN,142,142,142,142,TODO uninstall local features repositories not on the cluster ?,https://www.github.com/apache/karaf-cellar/commit/8a6d55fc3,https://www.github.com/apache/karaf-cellar/commit/cce70103bb3a53ed7b72317f63ed4d0eb66b9772,features/src/main/java/org/apache/karaf/cellar/features/FeaturesSynchronizer.java,"@Override
public void pull(Group group) {
if (group != null) {
String groupName = group.getName();
LOGGER.debug(""CELLAR FEATURE: pulling features repositories and features from cluster group {}"", groupName);
ClassLoader originalClassLoader = Thread.currentThread().getContextClassLoader();
try {
Thread.currentThread().setContextClassLoader(getClass().getClassLoader());
Map<String, String> clusterRepositories = clusterManager.getMap(Constants.REPOSITORIES_MAP + Configurations.SEPARATOR + groupName);
Map<String, FeatureState> clusterFeatures = clusterManager.getMap(Constants.FEATURES_MAP + Configurations.SEPARATOR + groupName);
if (clusterRepositories != null && !clusterRepositories.isEmpty()) {
// get the features repositories from the cluster to update locally
for (String url : clusterRepositories.keySet()) {
try {
if (!isRepositoryRegisteredLocally(url)) {
LOGGER.debug(""CELLAR FEATURE: adding repository {}"", url);
featuresService.addRepository(new URI(url));
} // TODO uninstall local features repositories not on the cluster ?
} catch (MalformedURLException e) {
LOGGER.error(""CELLAR FEATURE: failed to add repository URL {} (malformed)"", url, e);
} catch (Exception e) {
LOGGER.error(""CELLAR FEATURE: failed to add repository URL {}"", url, e);
}
}
// cleanup the local features repositories not present on the cluster
try {
for (Repository repository : featuresService.listRepositories()) {
URI uri = repository.getURI();
if (!clusterRepositories.containsKey(uri.toString())) {
featuresService.removeRepository(uri);
}
}
} catch (Exception e) {
LOGGER.warn(""Can't get local features repositories"", e);
}
}
if (clusterFeatures != null && !clusterFeatures.isEmpty()) {
// get the features from the cluster group and update locally
for (FeatureState state : clusterFeatures.values()) {
String name = state.getName();
// check if feature is blocked
if (isAllowed(group, Constants.CATEGORY, name, EventType.INBOUND)) {
Boolean clusterInstalled = state.getInstalled();
Boolean locallyInstalled = isFeatureInstalledLocally(state.getName(), state.getVersion());
// prevent NPE
if (clusterInstalled == null) {
clusterInstalled = false;
}
if (locallyInstalled == null) {
locallyInstalled = false;
}
// if feature has to be installed locally
if (clusterInstalled && !locallyInstalled) {
try {
LOGGER.debug(""CELLAR FEATURE: installing feature {}/{}"", state.getName(), state.getVersion());
featuresService.installFeature(state.getName(), state.getVersion());
} catch (Exception e) {
LOGGER.error(""CELLAR FEATURE: failed to install feature {}/{} "", new Object[]{state.getName(), state.getVersion()}, e);
}
} // TODO uninstall local features not on the cluster ?
} else LOGGER.trace(""CELLAR FEATURE: feature {} is marked BLOCKED INBOUND for cluster group {}"", name, groupName);
}
}
} finally {
Thread.currentThread().setContextClassLoader(originalClassLoader);
}
}
}","@Override
public void pull(Group group) {
if (group != null) {
String groupName = group.getName();
LOGGER.debug(""CELLAR FEATURE: pulling features repositories and features from cluster group {}"", groupName);
ClassLoader originalClassLoader = Thread.currentThread().getContextClassLoader();
try {
Thread.currentThread().setContextClassLoader(getClass().getClassLoader());
Map<String, String> clusterRepositories = clusterManager.getMap(Constants.REPOSITORIES_MAP + Configurations.SEPARATOR + groupName);
Map<String, FeatureState> clusterFeatures = clusterManager.getMap(Constants.FEATURES_MAP + Configurations.SEPARATOR + groupName);
if (clusterRepositories != null && !clusterRepositories.isEmpty()) {
// get the features repositories from the cluster to update locally
for (String url : clusterRepositories.keySet()) {
try {
if (!isRepositoryRegisteredLocally(url)) {
LOGGER.debug(""CELLAR FEATURE: adding repository {}"", url);
featuresService.addRepository(new URI(url));
}
} catch (MalformedURLException e) {
LOGGER.error(""CELLAR FEATURE: failed to add repository URL {} (malformed)"", url, e);
} catch (Exception e) {
LOGGER.error(""CELLAR FEATURE: failed to add repository URL {}"", url, e);
}
}
// cleanup the local features repositories not present on the cluster if the node is not the first one in the cluster group
if (clusterManager.listNodesByGroup(group).size() > 1) {
try {
for (Repository repository : featuresService.listRepositories()) {
URI uri = repository.getURI();
boolean found = false;
for (String clusterRepository : clusterRepositories.keySet()) {
if (clusterRepository.equals(uri.toString())) {
found = true;
break;
}
}
if (!found) {
LOGGER.debug(""CELLAR FEATURE: removing repository {}"", uri);
featuresService.removeRepository(uri);
}
}
} catch (Exception e) {
LOGGER.warn(""Can't get local features repositories"", e);
}
}
}
if (clusterFeatures != null && !clusterFeatures.isEmpty()) {
// get the features from the cluster group and update locally
for (FeatureState state : clusterFeatures.values()) {
String name = state.getName();
// check if feature is blocked
if (isAllowed(group, Constants.CATEGORY, name, EventType.INBOUND)) {
Boolean clusterInstalled = state.getInstalled();
Boolean locallyInstalled = isFeatureInstalledLocally(state.getName(), state.getVersion());
// prevent NPE
if (clusterInstalled == null) {
clusterInstalled = false;
}
if (locallyInstalled == null) {
locallyInstalled = false;
}
// if feature has to be installed locally
if (clusterInstalled && !locallyInstalled) {
try {
LOGGER.debug(""CELLAR FEATURE: installing feature {}/{}"", state.getName(), state.getVersion());
featuresService.installFeature(state.getName(), state.getVersion());
} catch (Exception e) {
LOGGER.error(""CELLAR FEATURE: failed to install feature {}/{} "", new Object[]{state.getName(), state.getVersion()}, e);
}
}
// if feature has to be uninstalled locally (and node is not the first one in the cluster group)
if (clusterManager.listNodesByGroup(group).size() > 1 && !clusterInstalled && locallyInstalled) {
try {
LOGGER.debug(""CELLAR FEATURE: uninstalling feature {}/{}"", state.getName(), state.getVersion());
featuresService.uninstallFeature(state.getName(), state.getVersion());
} catch (Exception e) {
LOGGER.error(""CELLAR FEATURE: failed to uninstall feature {}/{}"", new Object[]{state.getName(), state.getVersion()}, e);
}
}
} else LOGGER.trace(""CELLAR FEATURE: feature {} is marked BLOCKED INBOUND for cluster group {}"", name, groupName);
}
}
} finally {
Thread.currentThread().setContextClassLoader(originalClassLoader);
}
}
}","@ Override 
 public void pull ( Group group ) { 
 if ( group != null ) { 
 String groupName = group . getName ( ) ; 
 LOGGER . debug ( ""CELLAR FEATURE: pulling features repositories and features from cluster group {}"" , groupName ) ; 
 ClassLoader originalClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; 
 try { 
 Thread . currentThread ( ) . setContextClassLoader ( getClass ( ) . getClassLoader ( ) ) ; 
 Map < String , String > clusterRepositories = clusterManager . getMap ( Constants . REPOSITORIES_MAP + Configurations . SEPARATOR + groupName ) ; 
 Map < String , FeatureState > clusterFeatures = clusterManager . getMap ( Constants . FEATURES_MAP + Configurations . SEPARATOR + groupName ) ; 
 if ( clusterRepositories != null & &   ! clusterRepositories . isEmpty ( ) ) { 
 // get the features repositories from the cluster to update locally 
 for ( String url : clusterRepositories . keySet ( ) ) { 
 try { 
 if ( ! isRepositoryRegisteredLocally ( url ) ) { 
 LOGGER . debug ( ""CELLAR FEATURE: adding repository {}"" , url ) ; 
 featuresService . addRepository ( new URI ( url ) ) ; 
 } // TODO uninstall local features repositories not on the cluster   ? 
 } catch ( MalformedURLException e ) { 
 LOGGER . error ( ""CELLAR FEATURE: failed to add repository URL {} (malformed)"" , url , e ) ; 
 } catch ( Exception e ) { 
 LOGGER . error ( ""CELLAR FEATURE: failed to add repository URL {}"" , url , e ) ; 
 } 
 } 
 // cleanup the local features repositories not present on the cluster 
 try { 
 for ( Repository repository : featuresService . listRepositories ( ) ) { 
 URI uri = repository . getURI ( ) ; 
 if ( ! clusterRepositories . containsKey ( uri . toString ( ) ) ) { 
 featuresService . removeRepository ( uri ) ; 
 } 
 } 
 } catch ( Exception e ) { 
 LOGGER . warn ( ""Can't get local features repositories"" , e ) ; 
 } 
 } 
 if ( clusterFeatures != null & &   ! clusterFeatures . isEmpty ( ) ) { 
 // get the features from the cluster group and update locally 
 for ( FeatureState state : clusterFeatures . values ( ) ) { 
 String name = state . getName ( ) ; 
 // check if feature is blocked 
 if ( isAllowed ( group , Constants . CATEGORY , name , EventType . INBOUND ) ) { 
 Boolean clusterInstalled = state . getInstalled ( ) ; 
 Boolean locallyInstalled = isFeatureInstalledLocally ( state . getName ( ) , state . getVersion ( ) ) ; 
 // prevent NPE 
 if ( clusterInstalled == null ) { 
 clusterInstalled = false ; 
 } 
 if ( locallyInstalled == null ) { 
 locallyInstalled = false ; 
 } 
 // if feature has to be installed locally 
 if ( clusterInstalled & &   ! locallyInstalled ) { 
 try { 
 LOGGER . debug ( ""CELLAR FEATURE: installing feature {}/{}"" , state . getName ( ) , state . getVersion ( ) ) ; 
 featuresService . installFeature ( state . getName ( ) , state . getVersion ( ) ) ; 
 } catch ( Exception e ) { 
 LOGGER . error ( ""CELLAR FEATURE: failed to install feature {}/{} "" , new Object [ ] { state . getName ( ) , state . getVersion ( ) } , e ) ; 
 } 
 } // TODO uninstall local features not on the cluster   ? 
 } else LOGGER . trace ( ""CELLAR FEATURE: feature {} is marked BLOCKED INBOUND for cluster group {}"" , name , groupName ) ; 
 } 
 } 
 } finally { 
 Thread . currentThread ( ) . setContextClassLoader ( originalClassLoader ) ; 
 } 
 } 
 }  ","@ Override 
 public void pull ( Group group ) { 
 if ( group != null ) { 
 String groupName = group . getName ( ) ; 
 LOGGER . debug ( ""CELLAR FEATURE: pulling features repositories and features from cluster group {}"" , groupName ) ; 
 ClassLoader originalClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; 
 try { 
 Thread . currentThread ( ) . setContextClassLoader ( getClass ( ) . getClassLoader ( ) ) ; 
 Map < String , String > clusterRepositories = clusterManager . getMap ( Constants . REPOSITORIES_MAP + Configurations . SEPARATOR + groupName ) ; 
 Map < String , FeatureState > clusterFeatures = clusterManager . getMap ( Constants . FEATURES_MAP + Configurations . SEPARATOR + groupName ) ; 
 if ( clusterRepositories != null & &   ! clusterRepositories . isEmpty ( ) ) { 
 // get the features repositories from the cluster to update locally 
 for ( String url : clusterRepositories . keySet ( ) ) { 
 try { 
 if ( ! isRepositoryRegisteredLocally ( url ) ) { 
 LOGGER . debug ( ""CELLAR FEATURE: adding repository {}"" , url ) ; 
 featuresService . addRepository ( new URI ( url ) ) ; 
 } 
 } catch ( MalformedURLException e ) { 
 LOGGER . error ( ""CELLAR FEATURE: failed to add repository URL {} (malformed)"" , url , e ) ; 
 } catch ( Exception e ) { 
 LOGGER . error ( ""CELLAR FEATURE: failed to add repository URL {}"" , url , e ) ; 
 } 
 } 
 // cleanup the local features repositories not present on the cluster if the node is not the first one in the cluster group 
 if ( clusterManager . listNodesByGroup ( group ) . size ( ) > 1 ) { 
 try { 
 for ( Repository repository : featuresService . listRepositories ( ) ) { 
 URI uri = repository . getURI ( ) ; 
 boolean found = false ; 
 for ( String clusterRepository : clusterRepositories . keySet ( ) ) { 
 if ( clusterRepository . equals ( uri . toString ( ) ) ) { 
 found = true ; 
 break ; 
 } 
 } 
 if ( ! found ) { 
 LOGGER . debug ( ""CELLAR FEATURE: removing repository {}"" , uri ) ; 
 featuresService . removeRepository ( uri ) ; 
 } 
 } 
 } catch ( Exception e ) { 
 LOGGER . warn ( ""Can't get local features repositories"" , e ) ; 
 } 
 } 
 } 
 if ( clusterFeatures != null & &   ! clusterFeatures . isEmpty ( ) ) { 
 // get the features from the cluster group and update locally 
 for ( FeatureState state : clusterFeatures . values ( ) ) { 
 String name = state . getName ( ) ; 
 // check if feature is blocked 
 if ( isAllowed ( group , Constants . CATEGORY , name , EventType . INBOUND ) ) { 
 Boolean clusterInstalled = state . getInstalled ( ) ; 
 Boolean locallyInstalled = isFeatureInstalledLocally ( state . getName ( ) , state . getVersion ( ) ) ; 
 // prevent NPE 
 if ( clusterInstalled == null ) { 
 clusterInstalled = false ; 
 } 
 if ( locallyInstalled == null ) { 
 locallyInstalled = false ; 
 } 
 // if feature has to be installed locally 
 if ( clusterInstalled & &   ! locallyInstalled ) { 
 try { 
 LOGGER . debug ( ""CELLAR FEATURE: installing feature {}/{}"" , state . getName ( ) , state . getVersion ( ) ) ; 
 featuresService . installFeature ( state . getName ( ) , state . getVersion ( ) ) ; 
 } catch ( Exception e ) { 
 LOGGER . error ( ""CELLAR FEATURE: failed to install feature {}/{} "" , new Object [ ] { state . getName ( ) , state . getVersion ( ) } , e ) ; 
 } 
 } 
 // if feature has to be uninstalled locally ( and node is not the first one in the cluster group ) 
 if ( clusterManager . listNodesByGroup ( group ) . size ( ) > 1 & &   ! clusterInstalled & & locallyInstalled ) { 
 try { 
 LOGGER . debug ( ""CELLAR FEATURE: uninstalling feature {}/{}"" , state . getName ( ) , state . getVersion ( ) ) ; 
 featuresService . uninstallFeature ( state . getName ( ) , state . getVersion ( ) ) ; 
 } catch ( Exception e ) { 
 LOGGER . error ( ""CELLAR FEATURE: failed to uninstall feature {}/{}"" , new Object [ ] { state . getName ( ) , state . getVersion ( ) } , e ) ; 
 } 
 } 
 } else LOGGER . trace ( ""CELLAR FEATURE: feature {} is marked BLOCKED INBOUND for cluster group {}"" , name , groupName ) ; 
 } 
 } 
 } finally { 
 Thread . currentThread ( ) . setContextClassLoader ( originalClassLoader ) ; 
 } 
 } 
 }  ",2015-09-13 07:52:52 +0200,2017-05-10 15:24:39 +0200,4,0.9592106640565747
3810,431,https://www.github.com/kiegroup/optaplanner,createContentPane(),,77,77,77,77,TODO TSP needs to be rewritten,https://www.github.com/kiegroup/optaplanner/commit/cdfba480854,https://www.github.com/kiegroup/optaplanner/commit/96f887c08ea855ae15bfb0e075b156d22f4cbf27,drools-planner-examples/src/main/java/org/drools/planner/examples/app/DroolsPlannerExamplesApp.java,"private Container createContentPane() {
JPanel contentPane = new JPanel(new GridLayout(0, 1));
contentPane.add(new JLabel(""Which example do you want to see?""));
contentPane.add(new JButton(new AbstractAction(""N queens"") {
            public void actionPerformed(ActionEvent e) {
new NQueensApp().init(false);
}
        }));
contentPane.add(new JButton(new AbstractAction(""Cloud balancing"") {
            public void actionPerformed(ActionEvent e) {
new CloudBalancingApp().init(false);
}
        }));
contentPane.add(new JButton(new AbstractAction(""Machine reassignment (ROADEF 2012)"") {
            public void actionPerformed(ActionEvent e) {
new MachineReassignmentApp().init(false);
}
        }));
contentPane.add(new JButton(new AbstractAction(""Miss Manners 2009"") {
            public void actionPerformed(ActionEvent e) {
new Manners2009App().init(false);
}
        }));
// TODO TSP needs to be rewritten
//        contentPane.add(new JButton(new AbstractAction(""Traveling salesman problem (TSP)"") {
//            public void actionPerformed(ActionEvent e) {
//                new TspApp().init(false);
//            }
//        }));
contentPane.add(new JButton(new AbstractAction(""Traveling tournament problem (TTP)"") {
            public void actionPerformed(ActionEvent e) {
new SmartTravelingTournamentApp().init(false);
}
        }));
// TODO TrainDesign is still in working progress
//        contentPane.add(new JButton(new AbstractAction(""Train design (RAS2011)"") {
//            public void actionPerformed(ActionEvent e) {
//                new TrainDesignApp().init(false);
//            }
//        }));
contentPane.add(new JButton(new AbstractAction(""Curriculum course timetabling (ITC2007 track3)"") {
            public void actionPerformed(ActionEvent e) {
new CurriculumCourseApp().init(false);
}
        }));
contentPane.add(new JButton(new AbstractAction(""Examination timetabling (ITC2007 track1)"") {
            public void actionPerformed(ActionEvent e) {
new ExaminationApp().init(false);
}
        }));
contentPane.add(new JButton(new AbstractAction(""Patient admission scheduling (hospital bed planning)"") {
            public void actionPerformed(ActionEvent e) {
new PatientAdmissionScheduleApp().init(false);
}
        }));
contentPane.add(new JButton(new AbstractAction(""Nurse rostering (INRC2010)"") {
            public void actionPerformed(ActionEvent e) {
new NurseRosteringApp().init(false);
}
        }));
return contentPane;
}","private Container createContentPane() {
JPanel contentPane = new JPanel(new GridLayout(0, 1));
contentPane.add(new JLabel(""Which example do you want to see?""));
contentPane.add(new JButton(new AbstractAction(""N queens"") {
            public void actionPerformed(ActionEvent e) {
new NQueensApp().init(false);
}
        }));
contentPane.add(new JButton(new AbstractAction(""Cloud balancing"") {
            public void actionPerformed(ActionEvent e) {
new CloudBalancingApp().init(false);
}
        }));
contentPane.add(new JButton(new AbstractAction(""Machine reassignment (ROADEF 2012)"") {
            public void actionPerformed(ActionEvent e) {
new MachineReassignmentApp().init(false);
}
        }));
contentPane.add(new JButton(new AbstractAction(""Miss Manners 2009"") {
            public void actionPerformed(ActionEvent e) {
new Manners2009App().init(false);
}
        }));
contentPane.add(new JButton(new AbstractAction(""Traveling salesman problem (TSP)"") {
            public void actionPerformed(ActionEvent e) {
new TspApp().init(false);
}
        }));
contentPane.add(new JButton(new AbstractAction(""Traveling tournament problem (TTP)"") {
            public void actionPerformed(ActionEvent e) {
new SmartTravelingTournamentApp().init(false);
}
        }));
// TODO TrainDesign is still in working progress
//        contentPane.add(new JButton(new AbstractAction(""Train design (RAS2011)"") {
//            public void actionPerformed(ActionEvent e) {
//                new TrainDesignApp().init(false);
//            }
//        }));
contentPane.add(new JButton(new AbstractAction(""Curriculum course timetabling (ITC2007 track3)"") {
            public void actionPerformed(ActionEvent e) {
new CurriculumCourseApp().init(false);
}
        }));
contentPane.add(new JButton(new AbstractAction(""Examination timetabling (ITC2007 track1)"") {
            public void actionPerformed(ActionEvent e) {
new ExaminationApp().init(false);
}
        }));
contentPane.add(new JButton(new AbstractAction(""Patient admission scheduling (hospital bed planning)"") {
            public void actionPerformed(ActionEvent e) {
new PatientAdmissionScheduleApp().init(false);
}
        }));
contentPane.add(new JButton(new AbstractAction(""Nurse rostering (INRC2010)"") {
            public void actionPerformed(ActionEvent e) {
new NurseRosteringApp().init(false);
}
        }));
return contentPane;
}","private Container createContentPane ( ) { 
 JPanel contentPane = new JPanel ( new GridLayout ( 0 , 1 ) ) ; 
 contentPane . add ( new JLabel ( ""Which example do you want to see?"" ) ) ; 
 contentPane . add ( new JButton ( new AbstractAction ( ""N queens"" ) { 
 public void actionPerformed ( ActionEvent e ) { 
 new NQueensApp ( ) . init ( false ) ; 
 } 
 } ) ) ; 
 contentPane . add ( new JButton ( new AbstractAction ( ""Cloud balancing"" ) { 
 public void actionPerformed ( ActionEvent e ) { 
 new CloudBalancingApp ( ) . init ( false ) ; 
 } 
 } ) ) ; 
 contentPane . add ( new JButton ( new AbstractAction ( ""Machine reassignment (ROADEF 2012)"" ) { 
 public void actionPerformed ( ActionEvent e ) { 
 new MachineReassignmentApp ( ) . init ( false ) ; 
 } 
 } ) ) ; 
 contentPane . add ( new JButton ( new AbstractAction ( ""Miss Manners 2009"" ) { 
 public void actionPerformed ( ActionEvent e ) { 
 new Manners2009App ( ) . init ( false ) ; 
 } 
 } ) ) ; 
 // TODO TSP needs to be rewritten 
 // contentPane . add ( new JButton ( new AbstractAction ( ""Traveling salesman problem (TSP)"" ) { 
 // public void actionPerformed ( ActionEvent e ) { 
 // new TspApp ( ) . init ( false ) ; 
 // } 
 // } ) ) ; 
 contentPane . add ( new JButton ( new AbstractAction ( ""Traveling tournament problem (TTP)"" ) { 
 public void actionPerformed ( ActionEvent e ) { 
 new SmartTravelingTournamentApp ( ) . init ( false ) ; 
 } 
 } ) ) ; 
 // TODO TrainDesign is still in working progress 
 // contentPane . add ( new JButton ( new AbstractAction ( ""Train design (RAS2011)"" ) { 
 // public void actionPerformed ( ActionEvent e ) { 
 // new TrainDesignApp ( ) . init ( false ) ; 
 // } 
 // } ) ) ; 
 contentPane . add ( new JButton ( new AbstractAction ( ""Curriculum course timetabling (ITC2007 track3)"" ) { 
 public void actionPerformed ( ActionEvent e ) { 
 new CurriculumCourseApp ( ) . init ( false ) ; 
 } 
 } ) ) ; 
 contentPane . add ( new JButton ( new AbstractAction ( ""Examination timetabling (ITC2007 track1)"" ) { 
 public void actionPerformed ( ActionEvent e ) { 
 new ExaminationApp ( ) . init ( false ) ; 
 } 
 } ) ) ; 
 contentPane . add ( new JButton ( new AbstractAction ( ""Patient admission scheduling (hospital bed planning)"" ) { 
 public void actionPerformed ( ActionEvent e ) { 
 new PatientAdmissionScheduleApp ( ) . init ( false ) ; 
 } 
 } ) ) ; 
 contentPane . add ( new JButton ( new AbstractAction ( ""Nurse rostering (INRC2010)"" ) { 
 public void actionPerformed ( ActionEvent e ) { 
 new NurseRosteringApp ( ) . init ( false ) ; 
 } 
 } ) ) ; 
 return contentPane ; 
 }  ","private Container createContentPane ( ) { 
 JPanel contentPane = new JPanel ( new GridLayout ( 0 , 1 ) ) ; 
 contentPane . add ( new JLabel ( ""Which example do you want to see?"" ) ) ; 
 contentPane . add ( new JButton ( new AbstractAction ( ""N queens"" ) { 
 public void actionPerformed ( ActionEvent e ) { 
 new NQueensApp ( ) . init ( false ) ; 
 } 
 } ) ) ; 
 contentPane . add ( new JButton ( new AbstractAction ( ""Cloud balancing"" ) { 
 public void actionPerformed ( ActionEvent e ) { 
 new CloudBalancingApp ( ) . init ( false ) ; 
 } 
 } ) ) ; 
 contentPane . add ( new JButton ( new AbstractAction ( ""Machine reassignment (ROADEF 2012)"" ) { 
 public void actionPerformed ( ActionEvent e ) { 
 new MachineReassignmentApp ( ) . init ( false ) ; 
 } 
 } ) ) ; 
 contentPane . add ( new JButton ( new AbstractAction ( ""Miss Manners 2009"" ) { 
 public void actionPerformed ( ActionEvent e ) { 
 new Manners2009App ( ) . init ( false ) ; 
 } 
 } ) ) ; 
 contentPane . add ( new JButton ( new AbstractAction ( ""Traveling salesman problem (TSP)"" ) { 
 public void actionPerformed ( ActionEvent e ) { 
 new TspApp ( ) . init ( false ) ; 
 } 
 } ) ) ; 
 contentPane . add ( new JButton ( new AbstractAction ( ""Traveling tournament problem (TTP)"" ) { 
 public void actionPerformed ( ActionEvent e ) { 
 new SmartTravelingTournamentApp ( ) . init ( false ) ; 
 } 
 } ) ) ; 
 // TODO TrainDesign is still in working progress 
 // contentPane . add ( new JButton ( new AbstractAction ( ""Train design (RAS2011)"" ) { 
 // public void actionPerformed ( ActionEvent e ) { 
 // new TrainDesignApp ( ) . init ( false ) ; 
 // } 
 // } ) ) ; 
 contentPane . add ( new JButton ( new AbstractAction ( ""Curriculum course timetabling (ITC2007 track3)"" ) { 
 public void actionPerformed ( ActionEvent e ) { 
 new CurriculumCourseApp ( ) . init ( false ) ; 
 } 
 } ) ) ; 
 contentPane . add ( new JButton ( new AbstractAction ( ""Examination timetabling (ITC2007 track1)"" ) { 
 public void actionPerformed ( ActionEvent e ) { 
 new ExaminationApp ( ) . init ( false ) ; 
 } 
 } ) ) ; 
 contentPane . add ( new JButton ( new AbstractAction ( ""Patient admission scheduling (hospital bed planning)"" ) { 
 public void actionPerformed ( ActionEvent e ) { 
 new PatientAdmissionScheduleApp ( ) . init ( false ) ; 
 } 
 } ) ) ; 
 contentPane . add ( new JButton ( new AbstractAction ( ""Nurse rostering (INRC2010)"" ) { 
 public void actionPerformed ( ActionEvent e ) { 
 new NurseRosteringApp ( ) . init ( false ) ; 
 } 
 } ) ) ; 
 return contentPane ; 
 }  ",2011-08-05 09:54:25 +0200,2012-02-03 08:12:01 +0100,1,0.9983232032430818
828,390,https://www.github.com/sonarsource/sonarqube,"add(int, File)",,112,112,112,112,TODO refactor this thing into a separate class,https://www.github.com/sonarsource/sonarqube/commit/aeadc1f9129,https://www.github.com/sonarsource/sonarqube/commit/9380e275b3c6267ef3b958e5a0127dd924cab493,sonar-duplications/src/main/java/org/sonar/duplications/cpd/CPD.java,"private void add(int fileCount, File file) throws IOException {
if (skipDuplicates) {
// TODO refactor this thing into a separate class
String signature = file.getName() + '_' + file.length();
if (current.contains(signature)) {
System.err.println(""Skipping "" + file.getAbsolutePath()
+ "" since it appears to be a duplicate file and --skip-duplicate-files is set"");
return;
}
current.add(signature);
}
if ( !file.getCanonicalPath().equals(new File(file.getAbsolutePath()).getCanonicalPath())) {
System.err.println(""Skipping "" + file + "" since it appears to be a symlink"");
return;
}
listener.addedFile(fileCount, file);
SourceCode sourceCode = new SourceCode(new FileCodeLoaderWithoutCache(file, encoding));
language.getTokenizer().tokenize(sourceCode, tokens);
source.put(sourceCode.getFileName(), sourceCode);
}","private void add(int fileCount, File file) throws IOException {
if (!file.getCanonicalPath().equals(new File(file.getAbsolutePath()).getCanonicalPath())) {
System.out.println(""Skipping "" + file + "" since it appears to be a symlink"");
return;
}
listener.addedFile(fileCount, file);
SourceCode sourceCode = new SourceCode(new FileCodeLoaderWithoutCache(file, encoding));
language.getTokenizer().tokenize(sourceCode, tokens);
source.put(sourceCode.getFileName(), sourceCode);
}","private void add ( int fileCount , File file ) throws IOException { 
 if ( skipDuplicates ) { 
 // TODO refactor this thing into a separate class 
 String signature = file . getName ( ) + '_' + file . length ( ) ; 
 if ( current . contains ( signature ) ) { 
 System . err . println ( ""Skipping "" + file . getAbsolutePath ( ) 
 + "" since it appears to be a duplicate file and --skip-duplicate-files is set"" ) ; 
 return ; 
 } 
 current . add ( signature ) ; 
 } 
 if (   ! file . getCanonicalPath ( ) . equals ( new File ( file . getAbsolutePath ( ) ) . getCanonicalPath ( ) ) ) { 
 System . err . println ( ""Skipping "" + file + "" since it appears to be a symlink"" ) ; 
 return ; 
 } 
 listener . addedFile ( fileCount , file ) ; 
 SourceCode sourceCode = new SourceCode ( new FileCodeLoaderWithoutCache ( file , encoding ) ) ; 
 language . getTokenizer ( ) . tokenize ( sourceCode , tokens ) ; 
 source . put ( sourceCode . getFileName ( ) , sourceCode ) ; 
 }  ","private void add ( int fileCount , File file ) throws IOException { 
 if ( ! file . getCanonicalPath ( ) . equals ( new File ( file . getAbsolutePath ( ) ) . getCanonicalPath ( ) ) ) { 
 System . out . println ( ""Skipping "" + file + "" since it appears to be a symlink"" ) ; 
 return ; 
 } 
 listener . addedFile ( fileCount , file ) ; 
 SourceCode sourceCode = new SourceCode ( new FileCodeLoaderWithoutCache ( file , encoding ) ) ; 
 language . getTokenizer ( ) . tokenize ( sourceCode , tokens ) ; 
 source . put ( sourceCode . getFileName ( ) , sourceCode ) ; 
 }  ",2010-09-06 14:08:06 +0000,2011-04-01 23:56:50 +0200,2,0.883494722419842
401,13,https://www.github.com/aosp-mirror/platform_packages_apps_settings,onCreate(Bundle),,51,51,51,51,TODO See b/25772443,https://www.github.com/aosp-mirror/platform_packages_apps_settings/commit/4cfe39f5397d,https://www.github.com/aosp-mirror/platform_packages_apps_settings/commit/17ead044e16878546828d2aedbbd187cfa17cac8,src/com/android/settings/MonitoringCertInfoActivity.java,"@Override
protected void onCreate(Bundle savedStates) {
super.onCreate(savedStates);
DevicePolicyManager dpm =
                (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
final AlertDialog.Builder builder = new AlertDialog.Builder(this);
builder.setTitle(R.string.ssl_ca_cert_dialog_title);
builder.setCancelable(true);
// TODO See b/25772443
hasDeviceOwner = dpm.getDeviceOwnerComponentOnCallingUser() != null;
int buttonLabel;
if (hasDeviceOwner) {
// Institutional case.  Show informational message.
String message = this.getResources().getString(R.string.ssl_ca_cert_info_message,
                    dpm.getDeviceOwnerNameOnAnyUser());
builder.setMessage(message);
buttonLabel = R.string.done_button;
} else {
// Consumer case.  Show scary warning.
builder.setIcon(android.R.drawable.stat_notify_error);
builder.setMessage(R.string.ssl_ca_cert_warning_message);
buttonLabel = R.string.ssl_ca_cert_settings_button;
}
builder.setPositiveButton(buttonLabel, this);
final Dialog dialog = builder.create();
dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
try {
WindowManagerGlobal.getWindowManagerService().dismissKeyguard();
} catch (RemoteException e) {
}
dialog.setOnCancelListener(new DialogInterface.OnCancelListener() {
            @Override public void onCancel(DialogInterface dialog) {
finish();
}
        });
dialog.show();
}","@Override
protected void onCreate(Bundle savedStates) {
super.onCreate(savedStates);
DevicePolicyManager dpm = getSystemService(DevicePolicyManager.class);
final int numberOfCertificates = getIntent().getIntExtra(
                Settings.EXTRA_NUMBER_OF_CERTIFICATES, 1);
final AlertDialog.Builder builder = new AlertDialog.Builder(this);
builder.setTitle(getResources().getQuantityText(R.plurals.ssl_ca_cert_dialog_title,
                numberOfCertificates));
builder.setCancelable(true);
builder.setPositiveButton(getResources().getQuantityText(
                R.plurals.ssl_ca_cert_settings_button, numberOfCertificates) , this);
builder.setNeutralButton(R.string.cancel, null);
builder.setOnDismissListener(this);
if (dpm.getProfileOwner() != null) {
builder.setMessage(getResources().getQuantityString(R.plurals.ssl_ca_cert_info_message,
                    numberOfCertificates, dpm.getProfileOwnerName()));
} else if (dpm.getDeviceOwnerComponentOnCallingUser() != null) {
builder.setMessage(getResources().getQuantityString(R.plurals.ssl_ca_cert_info_message,
                    numberOfCertificates, dpm.getDeviceOwnerNameOnAnyUser()));
} else  {
// Consumer case.  Show scary warning.
builder.setIcon(android.R.drawable.stat_notify_error);
builder.setMessage(R.string.ssl_ca_cert_warning_message);
}
builder.show();
}","@ Override 
 protected void onCreate ( Bundle savedStates ) { 
 super . onCreate ( savedStates ) ; 
 DevicePolicyManager dpm = 
 ( DevicePolicyManager ) getSystemService ( Context . DEVICE_POLICY_SERVICE ) ; 
 final AlertDialog . Builder builder = new AlertDialog . Builder ( this ) ; 
 builder . setTitle ( R . string . ssl_ca_cert_dialog_title ) ; 
 builder . setCancelable ( true ) ; 
 // TODO See b / 25772443 
 hasDeviceOwner = dpm . getDeviceOwnerComponentOnCallingUser ( ) != null ; 
 int buttonLabel ; 
 if ( hasDeviceOwner ) { 
 // Institutional case . Show informational message . 
 String message = this . getResources ( ) . getString ( R . string . ssl_ca_cert_info_message , 
 dpm . getDeviceOwnerNameOnAnyUser ( ) ) ; 
 builder . setMessage ( message ) ; 
 buttonLabel = R . string . done_button ; 
 } else { 
 // Consumer case . Show scary warning . 
 builder . setIcon ( android . R . drawable . stat_notify_error ) ; 
 builder . setMessage ( R . string . ssl_ca_cert_warning_message ) ; 
 buttonLabel = R . string . ssl_ca_cert_settings_button ; 
 } 
 builder . setPositiveButton ( buttonLabel , this ) ; 
 final Dialog dialog = builder . create ( ) ; 
 dialog . getWindow ( ) . setType ( WindowManager . LayoutParams . TYPE_SYSTEM_ALERT ) ; 
 try { 
 WindowManagerGlobal . getWindowManagerService ( ) . dismissKeyguard ( ) ; 
 } catch ( RemoteException e ) { 
 } 
 dialog . setOnCancelListener ( new DialogInterface . OnCancelListener ( ) { 
 @ Override public void onCancel ( DialogInterface dialog ) { 
 finish ( ) ; 
 } 
 } ) ; 
 dialog . show ( ) ; 
 }  ","@ Override 
 protected void onCreate ( Bundle savedStates ) { 
 super . onCreate ( savedStates ) ; 
 DevicePolicyManager dpm = getSystemService ( DevicePolicyManager . class ) ; 
 final int numberOfCertificates = getIntent ( ) . getIntExtra ( 
 Settings . EXTRA_NUMBER_OF_CERTIFICATES , 1 ) ; 
 final AlertDialog . Builder builder = new AlertDialog . Builder ( this ) ; 
 builder . setTitle ( getResources ( ) . getQuantityText ( R . plurals . ssl_ca_cert_dialog_title , 
 numberOfCertificates ) ) ; 
 builder . setCancelable ( true ) ; 
 builder . setPositiveButton ( getResources ( ) . getQuantityText ( 
 R . plurals . ssl_ca_cert_settings_button , numberOfCertificates ) , this ) ; 
 builder . setNeutralButton ( R . string . cancel , null ) ; 
 builder . setOnDismissListener ( this ) ; 
 if ( dpm . getProfileOwner ( ) != null ) { 
 builder . setMessage ( getResources ( ) . getQuantityString ( R . plurals . ssl_ca_cert_info_message , 
 numberOfCertificates , dpm . getProfileOwnerName ( ) ) ) ; 
 } else if ( dpm . getDeviceOwnerComponentOnCallingUser ( ) != null ) { 
 builder . setMessage ( getResources ( ) . getQuantityString ( R . plurals . ssl_ca_cert_info_message , 
 numberOfCertificates , dpm . getDeviceOwnerNameOnAnyUser ( ) ) ) ; 
 } else { 
 // Consumer case . Show scary warning . 
 builder . setIcon ( android . R . drawable . stat_notify_error ) ; 
 builder . setMessage ( R . string . ssl_ca_cert_warning_message ) ; 
 } 
 builder . show ( ) ; 
 }  ",2015/11/24 14:55,2016-04-13 11:13:58 +0100,1,0.6122207455038697
124,427,https://www.github.com/jbossas/console,execute(AsyncCallback<List<SocketBinding>>),NOT_DESIGN,66,66,66,66,TODO: multicast properties,https://www.github.com/jbossas/console/commit/d518e5ec0,https://www.github.com/jbossas/console/commit/5e5e5ed72a846167a1e2bdafdd422dc6766a2a5d,gui/src/main/java/org/jboss/as/console/client/shared/general/model/LoadSocketBindingsCmd.java,"@Override
public void execute(final AsyncCallback<List<SocketBinding>> callback) {
// /socket-binding-group=standard-sockets:read-resource(recursive=true)
ModelNode operation = new ModelNode();
operation.get(ADDRESS).add(""socket-binding-group"", groupName);
operation.get(OP).set(READ_RESOURCE_OPERATION);
operation.get(RECURSIVE).set(true);
dispatcher.execute(new DMRAction(operation), new SimpleCallback<DMRResponse>() {

            @Override
public void onSuccess(DMRResponse result) {
ModelNode response = ModelNode.fromBase64(result.getResponseText());
ModelNode payload = response.get(""result"").asObject();
List<ModelNode> socketDescriptions= payload.get(""socket-binding"").asList();
List<SocketBinding> bindings = new ArrayList<SocketBinding>();
for(ModelNode socket : socketDescriptions)
{
ModelNode value = socket.asProperty().getValue();
SocketBinding sb = factory.socketBinding().as();
sb.setName(value.get(""name"").asString());
sb.setGroup(groupName);
sb.setPort(value.get(""port"").asInt());
String interfaceValue = value.get(""interface"").isDefined() ?
value.get(""interface"").asString() : ""not set"";
sb.setInterface(interfaceValue);
// TODO: multicast properties
sb.setMultiCastAddress(""not set"");
sb.setMultiCastPort(-1);
bindings.add(sb);
}
callback.onSuccess(bindings);
}
        });
}","@Override
public void execute(final AsyncCallback<List<SocketBinding>> callback) {
// /socket-binding-group=standard-sockets:read-resource(recursive=true)
ModelNode operation = new ModelNode();
operation.get(ADDRESS).add(""socket-binding-group"", groupName);
operation.get(OP).set(READ_RESOURCE_OPERATION);
operation.get(RECURSIVE).set(true);
dispatcher.execute(new DMRAction(operation), new SimpleCallback<DMRResponse>() {

            @Override
public void onSuccess(DMRResponse result) {
ModelNode response = ModelNode.fromBase64(result.getResponseText());
ModelNode payload = response.get(""result"").asObject();
List<ModelNode> socketDescriptions= payload.get(""socket-binding"").asList();
List<SocketBinding> bindings = new ArrayList<SocketBinding>();
for(ModelNode socket : socketDescriptions)
{
ModelNode value = socket.asProperty().getValue();
SocketBinding sb = factory.socketBinding().as();
sb.setName(value.get(""name"").asString());
sb.setGroup(groupName);
sb.setPort(value.get(""port"").asInt());
String interfaceValue = value.get(""interface"").isDefined() ?
value.get(""interface"").asString() : ""not set"";
sb.setInterface(interfaceValue);
if(value.hasDefined(""multicast-port""))
{
sb.setMultiCastAddress(value.get(""multicast-address"").asString());
sb.setMultiCastPort(value.get(""multicast-port"").asInt());
}
else
                    {
sb.setMultiCastAddress("""");
sb.setMultiCastPort(0);
}
bindings.add(sb);
}
callback.onSuccess(bindings);
}
        });
}","@ Override 
 public void execute ( final AsyncCallback < List < SocketBinding >> callback ) { 
 // / socket - binding - group = standard - sockets : read - resource ( recursive = true ) 
 ModelNode operation = new ModelNode ( ) ; 
 operation . get ( ADDRESS ) . add ( ""socket-binding-group"" , groupName ) ; 
 operation . get ( OP ) . set ( READ_RESOURCE_OPERATION ) ; 
 operation . get ( RECURSIVE ) . set ( true ) ; 
 dispatcher . execute ( new DMRAction ( operation ) , new SimpleCallback < DMRResponse > ( ) { 
 
 @ Override 
 public void onSuccess ( DMRResponse result ) { 
 ModelNode response = ModelNode . fromBase64 ( result . getResponseText ( ) ) ; 
 ModelNode payload = response . get ( ""result"" ) . asObject ( ) ; 
 List < ModelNode > socketDescriptions = payload . get ( ""socket-binding"" ) . asList ( ) ; 
 List < SocketBinding > bindings = new ArrayList < SocketBinding > ( ) ; 
 for ( ModelNode socket : socketDescriptions ) 
 { 
 ModelNode value = socket . asProperty ( ) . getValue ( ) ; 
 SocketBinding sb = factory . socketBinding ( ) . as ( ) ; 
 sb . setName ( value . get ( ""name"" ) . asString ( ) ) ; 
 sb . setGroup ( groupName ) ; 
 sb . setPort ( value . get ( ""port"" ) . asInt ( ) ) ; 
 String interfaceValue = value . get ( ""interface"" ) . isDefined ( )   ? 
 value . get ( ""interface"" ) . asString ( ) : ""not set"" ; 
 sb . setInterface ( interfaceValue ) ; 
 // TODO : multicast properties 
 sb . setMultiCastAddress ( ""not set"" ) ; 
 sb . setMultiCastPort ( - 1 ) ; 
 bindings . add ( sb ) ; 
 } 
 callback . onSuccess ( bindings ) ; 
 } 
 } ) ; 
 }  ","@ Override 
 public void execute ( final AsyncCallback < List < SocketBinding >> callback ) { 
 // / socket - binding - group = standard - sockets : read - resource ( recursive = true ) 
 ModelNode operation = new ModelNode ( ) ; 
 operation . get ( ADDRESS ) . add ( ""socket-binding-group"" , groupName ) ; 
 operation . get ( OP ) . set ( READ_RESOURCE_OPERATION ) ; 
 operation . get ( RECURSIVE ) . set ( true ) ; 
 dispatcher . execute ( new DMRAction ( operation ) , new SimpleCallback < DMRResponse > ( ) { 
 
 @ Override 
 public void onSuccess ( DMRResponse result ) { 
 ModelNode response = ModelNode . fromBase64 ( result . getResponseText ( ) ) ; 
 ModelNode payload = response . get ( ""result"" ) . asObject ( ) ; 
 List < ModelNode > socketDescriptions = payload . get ( ""socket-binding"" ) . asList ( ) ; 
 List < SocketBinding > bindings = new ArrayList < SocketBinding > ( ) ; 
 for ( ModelNode socket : socketDescriptions ) 
 { 
 ModelNode value = socket . asProperty ( ) . getValue ( ) ; 
 SocketBinding sb = factory . socketBinding ( ) . as ( ) ; 
 sb . setName ( value . get ( ""name"" ) . asString ( ) ) ; 
 sb . setGroup ( groupName ) ; 
 sb . setPort ( value . get ( ""port"" ) . asInt ( ) ) ; 
 String interfaceValue = value . get ( ""interface"" ) . isDefined ( )   ? 
 value . get ( ""interface"" ) . asString ( ) : ""not set"" ; 
 sb . setInterface ( interfaceValue ) ; 
 if ( value . hasDefined ( ""multicast-port"" ) ) 
 { 
 sb . setMultiCastAddress ( value . get ( ""multicast-address"" ) . asString ( ) ) ; 
 sb . setMultiCastPort ( value . get ( ""multicast-port"" ) . asInt ( ) ) ; 
 } 
 else 
 { 
 sb . setMultiCastAddress ( """" ) ; 
 sb . setMultiCastPort ( 0 ) ; 
 } 
 bindings . add ( sb ) ; 
 } 
 callback . onSuccess ( bindings ) ; 
 } 
 } ) ; 
 }  ",2011-06-07 11:45:29 +0200,2011-07-11 13:34:30 +0200,2,0.9750115264542784
1191,335,https://www.github.com/jenkinsci/tfs-plugin,"perform(Run<?, ?>, FilePath, Launcher, TaskListener)",NOT_DESIGN,47,47,47,47,TODO: use the simpler TeamRestClient overload once pull request #110 is merged,https://www.github.com/jenkinsci/tfs-plugin/commit/f1aa5ac7,https://www.github.com/jenkinsci/tfs-plugin/commit/bbc69acce4d9da5401da6759d9c2c6a5bcea6683,tfs/src/main/java/hudson/plugins/tfs/TeamUpdateWorkItemPostBuildAction.java,"@Override
public void perform(
            @Nonnull final Run<?, ?> run,
            @Nonnull final FilePath workspace,
            @Nonnull final Launcher launcher,
            @Nonnull final TaskListener listener
    ) throws InterruptedException, IOException {
try {
final String absoluteUrl = run.getAbsoluteUrl();
final ArrayList<ResourceRef> workItems = new ArrayList<ResourceRef>();
final URI collectionUri = TeamPullRequestMergedDetailsAction.addWorkItemsForRun(run, workItems);
if (collectionUri != null) {
// TODO: use the simpler TeamRestClient overload once pull request #110 is merged
final StandardUsernamePasswordCredentials credentials = TeamCollectionConfiguration.findCredentialsForCollection(collectionUri);
final TeamRestClient client = new TeamRestClient(collectionUri, credentials);
for (final ResourceRef workItem : workItems) {
final String workItemIdString = workItem.getId();
final Integer workItemId = Integer.valueOf(workItemIdString, 10);
client.addHyperlinkToWorkItem(workItemId, absoluteUrl);
}
}
}
catch (final IllegalArgumentException e) {
listener.error(e.getMessage());
}
catch (final Exception e) {
e.printStackTrace(listener.error(""Error while trying to update associated work items in TFS/Team Services""));
}
}","@Override
public void perform(
            @Nonnull final Run<?, ?> run,
            @Nonnull final FilePath workspace,
            @Nonnull final Launcher launcher,
            @Nonnull final TaskListener listener
    ) throws InterruptedException, IOException {
try {
final String absoluteUrl = run.getAbsoluteUrl();
final ArrayList<ResourceRef> workItems = new ArrayList<ResourceRef>();
final URI collectionUri = TeamPullRequestMergedDetailsAction.addWorkItemsForRun(run, workItems);
if (collectionUri != null) {
final TeamRestClient client = new TeamRestClient(collectionUri);
for (final ResourceRef workItem : workItems) {
final String workItemIdString = workItem.getId();
final Integer workItemId = Integer.valueOf(workItemIdString, 10);
client.addHyperlinkToWorkItem(workItemId, absoluteUrl);
}
}
}
catch (final IllegalArgumentException e) {
listener.error(e.getMessage());
}
catch (final Exception e) {
e.printStackTrace(listener.error(""Error while trying to update associated work items in TFS/Team Services""));
}
}","@ Override 
 public void perform ( 
 @ Nonnull final Run < ? ,   ? > run , 
 @ Nonnull final FilePath workspace , 
 @ Nonnull final Launcher launcher , 
 @ Nonnull final TaskListener listener 
 ) throws InterruptedException , IOException { 
 try { 
 final String absoluteUrl = run . getAbsoluteUrl ( ) ; 
 final ArrayList < ResourceRef > workItems = new ArrayList < ResourceRef > ( ) ; 
 final URI collectionUri = TeamPullRequestMergedDetailsAction . addWorkItemsForRun ( run , workItems ) ; 
 if ( collectionUri != null ) { 
 // TODO : use the simpler TeamRestClient overload once pull request #110 is merged 
 final StandardUsernamePasswordCredentials credentials = TeamCollectionConfiguration . findCredentialsForCollection ( collectionUri ) ; 
 final TeamRestClient client = new TeamRestClient ( collectionUri , credentials ) ; 
 for ( final ResourceRef workItem : workItems ) { 
 final String workItemIdString = workItem . getId ( ) ; 
 final Integer workItemId = Integer . valueOf ( workItemIdString , 10 ) ; 
 client . addHyperlinkToWorkItem ( workItemId , absoluteUrl ) ; 
 } 
 } 
 } 
 catch ( final IllegalArgumentException e ) { 
 listener . error ( e . getMessage ( ) ) ; 
 } 
 catch ( final Exception e ) { 
 e . printStackTrace ( listener . error ( ""Error while trying to update associated work items in TFS/Team Services"" ) ) ; 
 } 
 }  ","@ Override 
 public void perform ( 
 @ Nonnull final Run < ? ,   ? > run , 
 @ Nonnull final FilePath workspace , 
 @ Nonnull final Launcher launcher , 
 @ Nonnull final TaskListener listener 
 ) throws InterruptedException , IOException { 
 try { 
 final String absoluteUrl = run . getAbsoluteUrl ( ) ; 
 final ArrayList < ResourceRef > workItems = new ArrayList < ResourceRef > ( ) ; 
 final URI collectionUri = TeamPullRequestMergedDetailsAction . addWorkItemsForRun ( run , workItems ) ; 
 if ( collectionUri != null ) { 
 final TeamRestClient client = new TeamRestClient ( collectionUri ) ; 
 for ( final ResourceRef workItem : workItems ) { 
 final String workItemIdString = workItem . getId ( ) ; 
 final Integer workItemId = Integer . valueOf ( workItemIdString , 10 ) ; 
 client . addHyperlinkToWorkItem ( workItemId , absoluteUrl ) ; 
 } 
 } 
 } 
 catch ( final IllegalArgumentException e ) { 
 listener . error ( e . getMessage ( ) ) ; 
 } 
 catch ( final Exception e ) { 
 e . printStackTrace ( listener . error ( ""Error while trying to update associated work items in TFS/Team Services"" ) ) ; 
 } 
 }  ",2016/8/24 10:02,2016/9/12 10:40,1,0.9467310961201807
530,55,https://www.github.com/apache/activemq,"end(Xid, int)",NOT_DESIGN,407,407,407,407,TODO: we may want to put the xid in a suspended list.,https://www.github.com/apache/activemq/commit/40a7d3b6a,https://www.github.com/apache/activemq/commit/0a12bcb928f151b5ace9a0cffc34ec717b6a8e9c,activemq-client/src/main/java/org/apache/activemq/TransactionContext.java,"@Override
public void end(Xid xid, int flags) throws XAException {
LOG.debug(""End: {}, flags: {}"", xid, XASupport.toString(flags));
if (isInLocalTransaction()) {
throw new XAException(XAException.XAER_PROTO);
}
if ((flags & (TMSUSPEND | TMFAIL)) != 0) {
// You can only suspend the associated xid.
if (!equals(associatedXid, xid)) {
throw new XAException(XAException.XAER_PROTO);
}
// TODO: we may want to put the xid in a suspended list.
try {
beforeEnd();
} catch (JMSException e) {
throw toXAException(e);
} finally {
setXid(null);
}
} else if ((flags & TMSUCCESS) == TMSUCCESS) {
// set to null if this is the current xid.
// otherwise this could be an asynchronous success call
if (equals(associatedXid, xid)) {
try {
beforeEnd();
} catch (JMSException e) {
throw toXAException(e);
} finally {
setXid(null);
}
}
} else {
throw new XAException(XAException.XAER_INVAL);
}
}","@Override
public void end(Xid xid, int flags) throws XAException {
LOG.debug(""End: {}, flags: {}"", xid, XASupport.toString(flags));
if (isInLocalTransaction()) {
throw new XAException(XAException.XAER_PROTO);
}
if ((flags & (TMSUSPEND | TMFAIL)) != 0) {
// You can only suspend the associated xid.
if (!equals(associatedXid, xid)) {
throw new XAException(XAException.XAER_PROTO);
}
invokeBeforeEnd();
} else if ((flags & TMSUCCESS) == TMSUCCESS) {
// set to null if this is the current xid.
// otherwise this could be an asynchronous success call
if (equals(associatedXid, xid)) {
invokeBeforeEnd();
}
} else {
throw new XAException(XAException.XAER_INVAL);
}
}","@ Override 
 public void end ( Xid xid , int flags ) throws XAException { 
 LOG . debug ( ""End: {}, flags: {}"" , xid , XASupport . toString ( flags ) ) ; 
 if ( isInLocalTransaction ( ) ) { 
 throw new XAException ( XAException . XAER_PROTO ) ; 
 } 
 if ( ( flags & ( TMSUSPEND | TMFAIL ) ) != 0 ) { 
 // You can only suspend the associated xid . 
 if ( ! equals ( associatedXid , xid ) ) { 
 throw new XAException ( XAException . XAER_PROTO ) ; 
 } 
 // TODO : we may want to put the xid in a suspended list . 
 try { 
 beforeEnd ( ) ; 
 } catch ( JMSException e ) { 
 throw toXAException ( e ) ; 
 } finally { 
 setXid ( null ) ; 
 } 
 } else if ( ( flags & TMSUCCESS ) == TMSUCCESS ) { 
 // set to null if this is the current xid . 
 // otherwise this could be an asynchronous success call 
 if ( equals ( associatedXid , xid ) ) { 
 try { 
 beforeEnd ( ) ; 
 } catch ( JMSException e ) { 
 throw toXAException ( e ) ; 
 } finally { 
 setXid ( null ) ; 
 } 
 } 
 } else { 
 throw new XAException ( XAException . XAER_INVAL ) ; 
 } 
 }  ","@ Override 
 public void end ( Xid xid , int flags ) throws XAException { 
 LOG . debug ( ""End: {}, flags: {}"" , xid , XASupport . toString ( flags ) ) ; 
 if ( isInLocalTransaction ( ) ) { 
 throw new XAException ( XAException . XAER_PROTO ) ; 
 } 
 if ( ( flags & ( TMSUSPEND | TMFAIL ) ) != 0 ) { 
 // You can only suspend the associated xid . 
 if ( ! equals ( associatedXid , xid ) ) { 
 throw new XAException ( XAException . XAER_PROTO ) ; 
 } 
 invokeBeforeEnd ( ) ; 
 } else if ( ( flags & TMSUCCESS ) == TMSUCCESS ) { 
 // set to null if this is the current xid . 
 // otherwise this could be an asynchronous success call 
 if ( equals ( associatedXid , xid ) ) { 
 invokeBeforeEnd ( ) ; 
 } 
 } else { 
 throw new XAException ( XAException . XAER_INVAL ) ; 
 } 
 }  ",2005-12-12 17:53:59 +0000,2015-11-27 12:21:56 +0000,4,0.9121011147579724
2580,13,https://www.github.com/aosp-mirror/platform_packages_apps_settings,getPreferenceKey(),,66,66,66,66,"TODO: if preference has children, compare with newly loaded list",https://www.github.com/aosp-mirror/platform_packages_apps_settings/commit/976a07baa6fa,https://www.github.com/aosp-mirror/platform_packages_apps_settings/commit/05f20f44f25a9436d4d198bc48996736420d75ab,src/com/android/settings/notification/app/ConversationListPreferenceController.java,"protected void populateList(List<ConversationChannelWrapper> conversations,
            PreferenceGroup containerGroup) {
// TODO: if preference has children, compare with newly loaded list
containerGroup.removeAll();
if (conversations != null) {
populateConversations(conversations, containerGroup);
}
if (containerGroup.getPreferenceCount() == 0) {
containerGroup.setVisible(false);
} else {
containerGroup.setVisible(true);
Preference summaryPref = getSummaryPreference();
if (summaryPref != null) {
containerGroup.addPreference(summaryPref);
}
}
}","protected void populateList(List<ConversationChannelWrapper> conversations,
            PreferenceGroup containerGroup) {
containerGroup.setVisible(false);
containerGroup.removeAll();
if (conversations != null) {
populateConversations(conversations, containerGroup);
}
if (containerGroup.getPreferenceCount() == 0) {
containerGroup.setVisible(false);
} else {
Preference summaryPref = getSummaryPreference();
if (summaryPref != null) {
containerGroup.addPreference(summaryPref);
}
containerGroup.setVisible(true);
}
}","protected void populateList ( List < ConversationChannelWrapper > conversations , 
 PreferenceGroup containerGroup ) { 
 // TODO : if preference has children , compare with newly loaded list 
 containerGroup . removeAll ( ) ; 
 if ( conversations != null ) { 
 populateConversations ( conversations , containerGroup ) ; 
 } 
 if ( containerGroup . getPreferenceCount ( ) == 0 ) { 
 containerGroup . setVisible ( false ) ; 
 } else { 
 containerGroup . setVisible ( true ) ; 
 Preference summaryPref = getSummaryPreference ( ) ; 
 if ( summaryPref != null ) { 
 containerGroup . addPreference ( summaryPref ) ; 
 } 
 } 
 }  ","protected void populateList ( List < ConversationChannelWrapper > conversations , 
 PreferenceGroup containerGroup ) { 
 containerGroup . setVisible ( false ) ; 
 containerGroup . removeAll ( ) ; 
 if ( conversations != null ) { 
 populateConversations ( conversations , containerGroup ) ; 
 } 
 if ( containerGroup . getPreferenceCount ( ) == 0 ) { 
 containerGroup . setVisible ( false ) ; 
 } else { 
 Preference summaryPref = getSummaryPreference ( ) ; 
 if ( summaryPref != null ) { 
 containerGroup . addPreference ( summaryPref ) ; 
 } 
 containerGroup . setVisible ( true ) ; 
 } 
 }  ",2020/2/7 9:45,2021/5/24 9:02,67,0.954302341313987
1796,146,https://www.github.com/tinkerpop/blueprints,setUp(),NOT_DESIGN,984,984,1000,1000,TODO: listening on removal is not yet supported,https://www.github.com/tinkerpop/blueprints/commit/931a69d76,https://www.github.com/tinkerpop/blueprints/commit/0086acb28b2d5903fd39a816d06e37adb03a784f,blueprints-graph-sail/src/test/java/com/tinkerpop/blueprints/pgm/oupls/sail/SailTest.java,"@Test
public void testSailConnectionListeners() throws Exception {
if (sail instanceof NotifyingSail) {
TestListener listener1 = new TestListener(), listener2 = new TestListener();
NotifyingSailConnection sc = ((NotifyingSail) sail).getConnection();
sc.addConnectionListener(listener1);
URI uriA = sail.getValueFactory().createURI(""http://example.org/uriA"");
sc.removeStatements(null, null, null, uriA);
sc.commit();
sc.addConnectionListener(listener2);
sc.addStatement(uriA, uriA, uriA, uriA);
sc.commit();
// TODO: listening on removal is not yet supported
// assertEquals(1, listener1.getRemoved());
// assertEquals(0, listener2.getRemoved());
assertEquals(1, listener1.getAdded());
assertEquals(1, listener2.getAdded());
sc.close();
}
}","@Test
public void testSailConnectionListeners() throws Exception {
if (sail instanceof NotifyingSail) {
URI uriA = sail.getValueFactory().createURI(""http://example.org/uriA"");
URI uriB = sail.getValueFactory().createURI(""http://example.org/uriB"");
URI uriC = sail.getValueFactory().createURI(""http://example.org/uriC"");
TestListener listener1 = new TestListener(), listener2 = new TestListener();
NotifyingSailConnection sc = ((NotifyingSail) sail).getConnection();
sc.clear();
sc.commit();
// Add a listener and add statements
sc.addConnectionListener(listener1);
sc.addStatement(uriA, uriB, uriC, uriA);
sc.addStatement(uriB, uriC, uriA, uriA);
sc.commit();
// Add another listener and remove a statement
sc.addConnectionListener(listener2);
sc.removeStatements(uriA, null, null);
sc.commit();
assertEquals(2, listener1.getAdded());
assertEquals(0, listener2.getAdded());
assertEquals(1, listener1.getRemoved());
assertEquals(1, listener2.getRemoved());
// Remove a listener and clear
sc.removeConnectionListener(listener1);
sc.clear();
sc.commit();
assertEquals(1, listener1.getRemoved());
assertEquals(2, listener2.getRemoved());
sc.close();
}
}","@ Test 
 public void testSailConnectionListeners ( ) throws Exception { 
 if ( sail instanceof NotifyingSail ) { 
 TestListener listener1 = new TestListener ( ) , listener2 = new TestListener ( ) ; 
 NotifyingSailConnection sc = ( ( NotifyingSail ) sail ) . getConnection ( ) ; 
 sc . addConnectionListener ( listener1 ) ; 
 URI uriA = sail . getValueFactory ( ) . createURI ( ""http://example.org/uriA"" ) ; 
 sc . removeStatements ( null , null , null , uriA ) ; 
 sc . commit ( ) ; 
 sc . addConnectionListener ( listener2 ) ; 
 sc . addStatement ( uriA , uriA , uriA , uriA ) ; 
 sc . commit ( ) ; 
 // TODO : listening on removal is not yet supported 
 // assertEquals ( 1 , listener1 . getRemoved ( ) ) ; 
 // assertEquals ( 0 , listener2 . getRemoved ( ) ) ; 
 assertEquals ( 1 , listener1 . getAdded ( ) ) ; 
 assertEquals ( 1 , listener2 . getAdded ( ) ) ; 
 sc . close ( ) ; 
 } 
 }  ","@ Test 
 public void testSailConnectionListeners ( ) throws Exception { 
 if ( sail instanceof NotifyingSail ) { 
 URI uriA = sail . getValueFactory ( ) . createURI ( ""http://example.org/uriA"" ) ; 
 URI uriB = sail . getValueFactory ( ) . createURI ( ""http://example.org/uriB"" ) ; 
 URI uriC = sail . getValueFactory ( ) . createURI ( ""http://example.org/uriC"" ) ; 
 TestListener listener1 = new TestListener ( ) , listener2 = new TestListener ( ) ; 
 NotifyingSailConnection sc = ( ( NotifyingSail ) sail ) . getConnection ( ) ; 
 sc . clear ( ) ; 
 sc . commit ( ) ; 
 // Add a listener and add statements 
 sc . addConnectionListener ( listener1 ) ; 
 sc . addStatement ( uriA , uriB , uriC , uriA ) ; 
 sc . addStatement ( uriB , uriC , uriA , uriA ) ; 
 sc . commit ( ) ; 
 // Add another listener and remove a statement 
 sc . addConnectionListener ( listener2 ) ; 
 sc . removeStatements ( uriA , null , null ) ; 
 sc . commit ( ) ; 
 assertEquals ( 2 , listener1 . getAdded ( ) ) ; 
 assertEquals ( 0 , listener2 . getAdded ( ) ) ; 
 assertEquals ( 1 , listener1 . getRemoved ( ) ) ; 
 assertEquals ( 1 , listener2 . getRemoved ( ) ) ; 
 // Remove a listener and clear 
 sc . removeConnectionListener ( listener1 ) ; 
 sc . clear ( ) ; 
 sc . commit ( ) ; 
 assertEquals ( 1 , listener1 . getRemoved ( ) ) ; 
 assertEquals ( 2 , listener2 . getRemoved ( ) ) ; 
 sc . close ( ) ; 
 } 
 }  ",2011-03-08 12:41:05 +0800,2011-07-11 20:23:31 +0800,3,0.882872491316005
726,13,https://www.github.com/aosp-mirror/platform_packages_apps_settings,onCreate(Bundle),,102,102,103,103,TODO: pass menu key to homepage,https://www.github.com/aosp-mirror/platform_packages_apps_settings/commit/e427cc6752fa,https://www.github.com/aosp-mirror/platform_packages_apps_settings/commit/3af73364bacc850c5c023b91eae54553396b6b51,src/com/android/settings/search/SearchResultTrampoline.java,"@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
final ComponentName callingActivity = getCallingActivity();
// First make sure caller has privilege to launch a search result page.
FeatureFactory.getFactory(this)
.getSearchFeatureProvider()
.verifyLaunchSearchResultPageCaller(this, callingActivity);
// Didn't crash, proceed and launch the result as a subsetting.
Intent intent = getIntent();
final String highlightMenuKey = intent.getStringExtra(
                Settings.EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_HIGHLIGHT_MENU_KEY);
final String fragment = intent.getStringExtra(SettingsActivity.EXTRA_SHOW_FRAGMENT);
if (!TextUtils.isEmpty(fragment)) {
// Hack to take EXTRA_FRAGMENT_ARG_KEY from intent and set into
// EXTRA_SHOW_FRAGMENT_ARGUMENTS. This is necessary because intent could be from
// external caller and args may not persisted.
final String settingKey = intent.getStringExtra(
                    SettingsActivity.EXTRA_FRAGMENT_ARG_KEY);
final int tab = intent.getIntExtra(EXTRA_SHOW_FRAGMENT_TAB, 0);
final Bundle args = new Bundle();
args.putString(SettingsActivity.EXTRA_FRAGMENT_ARG_KEY, settingKey);
args.putInt(EXTRA_SHOW_FRAGMENT_TAB, tab);
intent.putExtra(EXTRA_SHOW_FRAGMENT_ARGUMENTS, args);
// Reroute request to SubSetting.
intent.setClass(this /* context */, SubSettings.class);
} else {
// Direct link case
final String intentUriString = intent.getStringExtra(
                    Settings.EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI);
if (TextUtils.isEmpty(intentUriString)) {
Log.e(TAG, ""No EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI for deep link"");
finish();
return;
}
try {
intent = Intent.parseUri(intentUriString, Intent.URI_INTENT_SCHEME);
} catch (URISyntaxException e) {
Log.e(TAG, ""Failed to parse deep link intent: "" + e);
finish();
return;
}
}
intent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);
if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)) {
startActivity(intent);
} else if (isSettingsIntelligence(callingActivity)) {
// Register SplitPairRule for SubSettings, set clearTop false to prevent unexpected back
// navigation behavior.
ActivityEmbeddingRulesController.registerSubSettingsPairRule(this,
                    false /* clearTop */);
// TODO: pass menu key to homepage
intent.setFlags(intent.getFlags() & ~Intent.FLAG_ACTIVITY_NEW_TASK);
startActivity(intent);
} else {
// Two-pane case
startActivity(SettingsActivity.getTrampolineIntent(intent, highlightMenuKey));
}
// Done.
finish();
}","@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
final ComponentName callingActivity = getCallingActivity();
// First make sure caller has privilege to launch a search result page.
FeatureFactory.getFactory(this)
.getSearchFeatureProvider()
.verifyLaunchSearchResultPageCaller(this, callingActivity);
// Didn't crash, proceed and launch the result as a subsetting.
Intent intent = getIntent();
final String highlightMenuKey = intent.getStringExtra(
                Settings.EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_HIGHLIGHT_MENU_KEY);
final String fragment = intent.getStringExtra(SettingsActivity.EXTRA_SHOW_FRAGMENT);
if (!TextUtils.isEmpty(fragment)) {
// Hack to take EXTRA_FRAGMENT_ARG_KEY from intent and set into
// EXTRA_SHOW_FRAGMENT_ARGUMENTS. This is necessary because intent could be from
// external caller and args may not persisted.
final String settingKey = intent.getStringExtra(
                    SettingsActivity.EXTRA_FRAGMENT_ARG_KEY);
final int tab = intent.getIntExtra(EXTRA_SHOW_FRAGMENT_TAB, 0);
final Bundle args = new Bundle();
args.putString(SettingsActivity.EXTRA_FRAGMENT_ARG_KEY, settingKey);
args.putInt(EXTRA_SHOW_FRAGMENT_TAB, tab);
intent.putExtra(EXTRA_SHOW_FRAGMENT_ARGUMENTS, args);
// Reroute request to SubSetting.
intent.setClass(this /* context */, SubSettings.class);
} else {
// Direct link case
final String intentUriString = intent.getStringExtra(
                    Settings.EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI);
if (TextUtils.isEmpty(intentUriString)) {
Log.e(TAG, ""No EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI for deep link"");
finish();
return;
}
try {
intent = Intent.parseUri(intentUriString, Intent.URI_INTENT_SCHEME);
} catch (URISyntaxException e) {
Log.e(TAG, ""Failed to parse deep link intent: "" + e);
finish();
return;
}
}
intent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);
if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)) {
startActivity(intent);
} else if (isSettingsIntelligence(callingActivity)) {
// Register SplitPairRule for SubSettings, set clearTop false to prevent unexpected back
// navigation behavior.
ActivityEmbeddingRulesController.registerSubSettingsPairRule(this,
                    false /* clearTop */);
intent.setFlags(intent.getFlags() & ~Intent.FLAG_ACTIVITY_NEW_TASK);
startActivity(intent);
// Pass menu key to homepage
final SettingsHomepageActivity homeActivity =
                    ((SettingsApplication) getApplicationContext()).getHomeActivity();
if (homeActivity != null) {
homeActivity.getMainFragment().setHighlightMenuKey(highlightMenuKey);
}
} else {
// Two-pane case
startActivity(SettingsActivity.getTrampolineIntent(intent, highlightMenuKey)
.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK));
}
// Done.
finish();
}","@ Override 
 protected void onCreate ( Bundle savedInstanceState ) { 
 super . onCreate ( savedInstanceState ) ; 
 final ComponentName callingActivity = getCallingActivity ( ) ; 
 // First make sure caller has privilege to launch a search result page . 
 FeatureFactory . getFactory ( this ) 
 . getSearchFeatureProvider ( ) 
 . verifyLaunchSearchResultPageCaller ( this , callingActivity ) ; 
 // Didn ' t crash , proceed and launch the result as a subsetting . 
 Intent intent = getIntent ( ) ; 
 final String highlightMenuKey = intent . getStringExtra ( 
 Settings . EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_HIGHLIGHT_MENU_KEY ) ; 
 final String fragment = intent . getStringExtra ( SettingsActivity . EXTRA_SHOW_FRAGMENT ) ; 
 if ( ! TextUtils . isEmpty ( fragment ) ) { 
 // Hack to take EXTRA_FRAGMENT_ARG_KEY from intent and set into 
 // EXTRA_SHOW_FRAGMENT_ARGUMENTS . This is necessary because intent could be from 
 // external caller and args may not persisted . 
 final String settingKey = intent . getStringExtra ( 
 SettingsActivity . EXTRA_FRAGMENT_ARG_KEY ) ; 
 final int tab = intent . getIntExtra ( EXTRA_SHOW_FRAGMENT_TAB , 0 ) ; 
 final Bundle args = new Bundle ( ) ; 
 args . putString ( SettingsActivity . EXTRA_FRAGMENT_ARG_KEY , settingKey ) ; 
 args . putInt ( EXTRA_SHOW_FRAGMENT_TAB , tab ) ; 
 intent . putExtra ( EXTRA_SHOW_FRAGMENT_ARGUMENTS , args ) ; 
 // Reroute request to SubSetting . 
 intent . setClass ( this / * context * / , SubSettings . class ) ; 
 } else { 
 // Direct link case 
 final String intentUriString = intent . getStringExtra ( 
 Settings . EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI ) ; 
 if ( TextUtils . isEmpty ( intentUriString ) ) { 
 Log . e ( TAG , ""No EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI for deep link"" ) ; 
 finish ( ) ; 
 return ; 
 } 
 try { 
 intent = Intent . parseUri ( intentUriString , Intent . URI_INTENT_SCHEME ) ; 
 } catch ( URISyntaxException e ) { 
 Log . e ( TAG , ""Failed to parse deep link intent: "" + e ) ; 
 finish ( ) ; 
 return ; 
 } 
 } 
 intent . addFlags ( Intent . FLAG_ACTIVITY_FORWARD_RESULT ) ; 
 if ( ! ActivityEmbeddingUtils . isEmbeddingActivityEnabled ( this ) ) { 
 startActivity ( intent ) ; 
 } else if ( isSettingsIntelligence ( callingActivity ) ) { 
 // Register SplitPairRule for SubSettings , set clearTop false to prevent unexpected back 
 // navigation behavior . 
 ActivityEmbeddingRulesController . registerSubSettingsPairRule ( this , 
 false / * clearTop * / ) ; 
 // TODO : pass menu key to homepage 
 intent . setFlags ( intent . getFlags ( ) & ~ Intent . FLAG_ACTIVITY_NEW_TASK ) ; 
 startActivity ( intent ) ; 
 } else { 
 // Two - pane case 
 startActivity ( SettingsActivity . getTrampolineIntent ( intent , highlightMenuKey ) ) ; 
 } 
 // Done . 
 finish ( ) ; 
 }  ","@ Override 
 protected void onCreate ( Bundle savedInstanceState ) { 
 super . onCreate ( savedInstanceState ) ; 
 final ComponentName callingActivity = getCallingActivity ( ) ; 
 // First make sure caller has privilege to launch a search result page . 
 FeatureFactory . getFactory ( this ) 
 . getSearchFeatureProvider ( ) 
 . verifyLaunchSearchResultPageCaller ( this , callingActivity ) ; 
 // Didn ' t crash , proceed and launch the result as a subsetting . 
 Intent intent = getIntent ( ) ; 
 final String highlightMenuKey = intent . getStringExtra ( 
 Settings . EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_HIGHLIGHT_MENU_KEY ) ; 
 final String fragment = intent . getStringExtra ( SettingsActivity . EXTRA_SHOW_FRAGMENT ) ; 
 if ( ! TextUtils . isEmpty ( fragment ) ) { 
 // Hack to take EXTRA_FRAGMENT_ARG_KEY from intent and set into 
 // EXTRA_SHOW_FRAGMENT_ARGUMENTS . This is necessary because intent could be from 
 // external caller and args may not persisted . 
 final String settingKey = intent . getStringExtra ( 
 SettingsActivity . EXTRA_FRAGMENT_ARG_KEY ) ; 
 final int tab = intent . getIntExtra ( EXTRA_SHOW_FRAGMENT_TAB , 0 ) ; 
 final Bundle args = new Bundle ( ) ; 
 args . putString ( SettingsActivity . EXTRA_FRAGMENT_ARG_KEY , settingKey ) ; 
 args . putInt ( EXTRA_SHOW_FRAGMENT_TAB , tab ) ; 
 intent . putExtra ( EXTRA_SHOW_FRAGMENT_ARGUMENTS , args ) ; 
 // Reroute request to SubSetting . 
 intent . setClass ( this / * context * / , SubSettings . class ) ; 
 } else { 
 // Direct link case 
 final String intentUriString = intent . getStringExtra ( 
 Settings . EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI ) ; 
 if ( TextUtils . isEmpty ( intentUriString ) ) { 
 Log . e ( TAG , ""No EXTRA_SETTINGS_EMBEDDED_DEEP_LINK_INTENT_URI for deep link"" ) ; 
 finish ( ) ; 
 return ; 
 } 
 try { 
 intent = Intent . parseUri ( intentUriString , Intent . URI_INTENT_SCHEME ) ; 
 } catch ( URISyntaxException e ) { 
 Log . e ( TAG , ""Failed to parse deep link intent: "" + e ) ; 
 finish ( ) ; 
 return ; 
 } 
 } 
 intent . addFlags ( Intent . FLAG_ACTIVITY_FORWARD_RESULT ) ; 
 if ( ! ActivityEmbeddingUtils . isEmbeddingActivityEnabled ( this ) ) { 
 startActivity ( intent ) ; 
 } else if ( isSettingsIntelligence ( callingActivity ) ) { 
 // Register SplitPairRule for SubSettings , set clearTop false to prevent unexpected back 
 // navigation behavior . 
 ActivityEmbeddingRulesController . registerSubSettingsPairRule ( this , 
 false / * clearTop * / ) ; 
 intent . setFlags ( intent . getFlags ( ) & ~ Intent . FLAG_ACTIVITY_NEW_TASK ) ; 
 startActivity ( intent ) ; 
 // Pass menu key to homepage 
 final SettingsHomepageActivity homeActivity = 
 ( ( SettingsApplication ) getApplicationContext ( ) ) . getHomeActivity ( ) ; 
 if ( homeActivity != null ) { 
 homeActivity . getMainFragment ( ) . setHighlightMenuKey ( highlightMenuKey ) ; 
 } 
 } else { 
 // Two - pane case 
 startActivity ( SettingsActivity . getTrampolineIntent ( intent , highlightMenuKey ) 
 . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ) ; 
 } 
 // Done . 
 finish ( ) ; 
 }  ",2021-11-03 18:44:01 +0800,2021-11-11 14:33:26 +0800,1,0.9850377583304468
542,93,https://www.github.com/apache/maven-wagon,"get(String, File)",DESIGN,712,712,712,712,TODO: this should be checking out a full hierarchy (requires the -d equiv),https://www.github.com/apache/maven-wagon/commit/a7f8eb8e4,https://www.github.com/apache/maven-wagon/commit/2e70c858b7031b105951ee33252410590ae5e785,wagon-providers/wagon-scm/src/main/java/org/apache/maven/wagon/providers/scm/ScmWagon.java,"public void get( String resourceName, File destination )
throws TransferFailedException, ResourceDoesNotExistException, AuthorizationException
{
Resource resource = new Resource( resourceName );
fireGetInitiated( resource, destination );
String url = getRepository().getUrl() + ""/"" + resourceName;
// remove the file
url = url.substring( 0, url.lastIndexOf( '/' ) );
try
        {
ScmRepository scmRepository = getScmRepository( url );
fireGetStarted( resource, destination );
// TODO: limitations:
// - destination filename must match that in the repository - should allow the ""-d"" CVS equiv to be passed
//   in
// - we don't get granular exceptions from SCM (ie, auth, not found)
// - need to make it non-recursive to save time
// - exists() check doesn't test if it is in SCM already
File scmFile = new File( checkoutDirectory, resourceName );
File basedir = scmFile.getParentFile();
ScmProvider scmProvider = getScmProvider( scmRepository.getProvider() );
String reservedScmFile = scmProvider.getScmSpecificFilename();
if ( reservedScmFile != null && new File( basedir, reservedScmFile ).exists() )
{
scmProvider.update( scmRepository, new ScmFileSet( basedir ), makeScmVersion() );
}
else
            {
// TODO: this should be checking out a full hierarchy (requires the -d equiv)
basedir.mkdirs();
checkOut( scmProvider, scmRepository, new ScmFileSet( basedir ) );
}
if ( !scmFile.exists() )
{
throw new ResourceDoesNotExistException( ""Unable to find resource "" + destination + "" after checkout"" );
}
if ( !scmFile.equals( destination ) )
{
FileUtils.copyFile( scmFile, destination );
}
}
catch ( ScmException e )
{
fireTransferError( resource, e, TransferEvent.REQUEST_GET );
throw new TransferFailedException( ""Error getting file from SCM"", e );
}
catch ( IOException e )
{
fireTransferError( resource, e, TransferEvent.REQUEST_GET );
throw new TransferFailedException( ""Error getting file from SCM"", e );
}
postProcessListeners( resource, destination, TransferEvent.REQUEST_GET );
fireGetCompleted( resource, destination );
}","public void get( String resourceName, File destination )
throws TransferFailedException, ResourceDoesNotExistException, AuthorizationException
{
Resource resource = new Resource( resourceName );
fireGetInitiated( resource, destination );
fireGetStarted( resource, destination );
try
        {
String subdir = getDirname( resourceName );
ScmResult res = tryPartialCheckout( subdir );
if ( !res.isSuccess() && ( partCOSubdir.length() == 0 || res instanceof UpdateScmResult ) )
{
// inability to checkout SVN or CVS subdir is not fatal. We just assume it doesn't exist
// inability to update existing subdir or checkout root is fatal
throw new ScmException( ""command failed: "" + res.getCommandOutput().trim() );
}
resourceName = resourceName.substring( partCOSubdir.length() );
// TODO: limitations:
// - destination filename must match that in the repository - should allow the ""-d"" CVS equiv to be passed
//   in
// - we don't get granular exceptions from SCM (ie, auth, not found)
// - need to make it non-recursive to save time
// - exists() check doesn't test if it is in SCM already
File scmFile = new File( checkoutDirectory, resourceName );
if ( !scmFile.exists() )
{
throw new ResourceDoesNotExistException( ""Unable to find resource "" + destination + "" after checkout"" );
}
if ( !scmFile.equals( destination ) )
{
FileUtils.copyFile( scmFile, destination );
}
}
catch ( ScmException e )
{
fireTransferError( resource, e, TransferEvent.REQUEST_GET );
throw new TransferFailedException( ""Error getting file from SCM"", e );
}
catch ( IOException e )
{
fireTransferError( resource, e, TransferEvent.REQUEST_GET );
throw new TransferFailedException( ""Error getting file from SCM"", e );
}
postProcessListeners( resource, destination, TransferEvent.REQUEST_GET );
fireGetCompleted( resource, destination );
}","public void get ( String resourceName , File destination ) 
 throws TransferFailedException , ResourceDoesNotExistException , AuthorizationException 
 { 
 Resource resource = new Resource ( resourceName ) ; 
 fireGetInitiated ( resource , destination ) ; 
 String url = getRepository ( ) . getUrl ( ) + ""/"" + resourceName ; 
 // remove the file 
 url = url . substring ( 0 , url . lastIndexOf ( '/' ) ) ; 
 try 
 { 
 ScmRepository scmRepository = getScmRepository ( url ) ; 
 fireGetStarted ( resource , destination ) ; 
 // TODO : limitations : 
 // - destination filename must match that in the repository - should allow the ""-d"" CVS equiv to be passed 
 // in 
 // - we don ' t get granular exceptions from SCM ( ie , auth , not found ) 
 // - need to make it non - recursive to save time 
 // - exists ( ) check doesn ' t test if it is in SCM already 
 File scmFile = new File ( checkoutDirectory , resourceName ) ; 
 File basedir = scmFile . getParentFile ( ) ; 
 ScmProvider scmProvider = getScmProvider ( scmRepository . getProvider ( ) ) ; 
 String reservedScmFile = scmProvider . getScmSpecificFilename ( ) ; 
 if ( reservedScmFile != null & & new File ( basedir , reservedScmFile ) . exists ( ) ) 
 { 
 scmProvider . update ( scmRepository , new ScmFileSet ( basedir ) , makeScmVersion ( ) ) ; 
 } 
 else 
 { 
 // TODO : this should be checking out a full hierarchy ( requires the - d equiv ) 
 basedir . mkdirs ( ) ; 
 checkOut ( scmProvider , scmRepository , new ScmFileSet ( basedir ) ) ; 
 } 
 if (   ! scmFile . exists ( ) ) 
 { 
 throw new ResourceDoesNotExistException ( ""Unable to find resource "" + destination + "" after checkout"" ) ; 
 } 
 if (   ! scmFile . equals ( destination ) ) 
 { 
 FileUtils . copyFile ( scmFile , destination ) ; 
 } 
 } 
 catch ( ScmException e ) 
 { 
 fireTransferError ( resource , e , TransferEvent . REQUEST_GET ) ; 
 throw new TransferFailedException ( ""Error getting file from SCM"" , e ) ; 
 } 
 catch ( IOException e ) 
 { 
 fireTransferError ( resource , e , TransferEvent . REQUEST_GET ) ; 
 throw new TransferFailedException ( ""Error getting file from SCM"" , e ) ; 
 } 
 postProcessListeners ( resource , destination , TransferEvent . REQUEST_GET ) ; 
 fireGetCompleted ( resource , destination ) ; 
 }  ","public void get ( String resourceName , File destination ) 
 throws TransferFailedException , ResourceDoesNotExistException , AuthorizationException 
 { 
 Resource resource = new Resource ( resourceName ) ; 
 fireGetInitiated ( resource , destination ) ; 
 fireGetStarted ( resource , destination ) ; 
 try 
 { 
 String subdir = getDirname ( resourceName ) ; 
 ScmResult res = tryPartialCheckout ( subdir ) ; 
 if (   ! res . isSuccess ( ) & & ( partCOSubdir . length ( ) == 0 | | res instanceof UpdateScmResult ) ) 
 { 
 // inability to checkout SVN or CVS subdir is not fatal . We just assume it doesn ' t exist 
 // inability to update existing subdir or checkout root is fatal 
 throw new ScmException ( ""command failed: "" + res . getCommandOutput ( ) . trim ( ) ) ; 
 } 
 resourceName = resourceName . substring ( partCOSubdir . length ( ) ) ; 
 // TODO : limitations : 
 // - destination filename must match that in the repository - should allow the ""-d"" CVS equiv to be passed 
 // in 
 // - we don ' t get granular exceptions from SCM ( ie , auth , not found ) 
 // - need to make it non - recursive to save time 
 // - exists ( ) check doesn ' t test if it is in SCM already 
 File scmFile = new File ( checkoutDirectory , resourceName ) ; 
 if (   ! scmFile . exists ( ) ) 
 { 
 throw new ResourceDoesNotExistException ( ""Unable to find resource "" + destination + "" after checkout"" ) ; 
 } 
 if (   ! scmFile . equals ( destination ) ) 
 { 
 FileUtils . copyFile ( scmFile , destination ) ; 
 } 
 } 
 catch ( ScmException e ) 
 { 
 fireTransferError ( resource , e , TransferEvent . REQUEST_GET ) ; 
 throw new TransferFailedException ( ""Error getting file from SCM"" , e ) ; 
 } 
 catch ( IOException e ) 
 { 
 fireTransferError ( resource , e , TransferEvent . REQUEST_GET ) ; 
 throw new TransferFailedException ( ""Error getting file from SCM"" , e ) ; 
 } 
 postProcessListeners ( resource , destination , TransferEvent . REQUEST_GET ) ; 
 fireGetCompleted ( resource , destination ) ; 
 }  ",2008-08-02 22:21:46 +0000,2018-06-04 11:36:40 +0200,11,0.756081882807894
949,729,https://www.github.com/javaparser/javaparser,"visit(LambdaExpr, Boolean)",,322,322,322,322,FIXME: here we should replace the type parameters that can be resolved,https://www.github.com/javaparser/javaparser/commit/0f40221492,https://www.github.com/javaparser/javaparser/commit/63c7f0fb4247e490bdd05d2779c6983c892fe570,java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/TypeExtractor.java,"@Override
public Type visit(LambdaExpr node, Boolean solveLambdas) {
if (getParentNode(node) instanceof MethodCallExpr) {
MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);
int pos = JavaParserSymbolDeclaration.getParamPos(node);
SymbolReference<com.github.javaparser.symbolsolver.model.declarations.MethodDeclaration> refMethod = facade.solve(callExpr);
if (!refMethod.isSolved()) {
throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());
}
logger.finest(""getType on lambda expr "" + refMethod.getCorrespondingDeclaration().getName());
//logger.finest(""Method param "" + refMethod.getCorrespondingDeclaration().getParam(pos));
if (solveLambdas) {
// The type parameter referred here should be the java.util.stream.Stream.T
Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();
// FIXME: here we should replace the type parameters that can be resolved
//        for example when invoking myListOfStrings.stream().filter(s -> s.length > 0);
//        the MethodDeclaration of filter is:
//        Stream<T> filter(Predicate<? super T> predicate)
//        but T in this case is equal to String
if (callExpr.getScope().isPresent()) {
Expression scope = callExpr.getScope().get();
// If it is a static call we should not try to get the type of the scope
boolean staticCall = false;
if (scope instanceof NameExpr) {
NameExpr nameExpr = (NameExpr) scope;
try {
JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId(), typeSolver);
staticCall = true;
} catch (Exception e) {
}
}
if (!staticCall) {
Type scopeType = facade.getType(scope);
if (scopeType.isReferenceType()) {
result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);
}
}
}
// We need to replace the type variables
Context ctx = JavaParserFactory.getContext(node, typeSolver);
result = facade.solveGenericTypes(result, ctx, typeSolver);
//We should find out which is the functional method (e.g., apply) and replace the params of the
//solveLambdas with it, to derive so the values. We should also consider the value returned by the
//lambdas
Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);
if (functionalMethod.isPresent()) {
LambdaExpr lambdaExpr = node;
InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);
// At this point parameterType
// if Function<T=? super Stream.T, ? extends map.R>
// we should replace Stream.T
Type functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);
//inferenceContext.addPair(parameterType, functionalInterfaceType);
//inferenceContext.addPair(parameterType, result);
inferenceContext.addPair(result, functionalInterfaceType);
if (lambdaExpr.getBody() instanceof ExpressionStmt) {
ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();
Type actualType = facade.getType(expressionStmt.getExpression());
Type formalType = functionalMethod.get().returnType();
// if the functional method returns void anyway
// we don't need to bother inferring types
if (!(formalType instanceof VoidType)){
inferenceContext.addPair(formalType, actualType);
result = inferenceContext.resolve(inferenceContext.addSingle(result));
}
} else {
throw new UnsupportedOperationException();
}
}
return result;
} else {
return refMethod.getCorrespondingDeclaration().getParam(pos).getType();
}
} else {
throw new UnsupportedOperationException(""The type of a lambda expr depends on the position and its return value"");
}
}","@Override
public Type visit(LambdaExpr node, Boolean solveLambdas) {
if (getParentNode(node) instanceof MethodCallExpr) {
MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);
int pos = JavaParserSymbolDeclaration.getParamPos(node);
SymbolReference<MethodDeclaration> refMethod = facade.solve(callExpr);
if (!refMethod.isSolved()) {
throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());
}
logger.finest(""getType on lambda expr "" + refMethod.getCorrespondingDeclaration().getName());
//logger.finest(""Method param "" + refMethod.getCorrespondingDeclaration().getParam(pos));
if (solveLambdas) {
// The type parameter referred here should be the java.util.stream.Stream.T
Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();
if (callExpr.getScope().isPresent()) {
Expression scope = callExpr.getScope().get();
// If it is a static call we should not try to get the type of the scope
boolean staticCall = false;
if (scope instanceof NameExpr) {
NameExpr nameExpr = (NameExpr) scope;
try {
JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId(), typeSolver);
staticCall = true;
} catch (Exception e) {
}
}
if (!staticCall) {
Type scopeType = facade.getType(scope);
if (scopeType.isReferenceType()) {
result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);
}
}
}
// We need to replace the type variables
Context ctx = JavaParserFactory.getContext(node, typeSolver);
result = facade.solveGenericTypes(result, ctx, typeSolver);
//We should find out which is the functional method (e.g., apply) and replace the params of the
//solveLambdas with it, to derive so the values. We should also consider the value returned by the
//lambdas
Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);
if (functionalMethod.isPresent()) {
LambdaExpr lambdaExpr = node;
InferenceContext lambdaCtx = new InferenceContext(MyObjectProvider.INSTANCE);
InferenceContext funcInterfaceCtx = new InferenceContext(MyObjectProvider.INSTANCE);
// At this point parameterType
// if Function<T=? super Stream.T, ? extends map.R>
// we should replace Stream.T
Type functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);
lambdaCtx.addPair(result, functionalInterfaceType);
if (lambdaExpr.getBody() instanceof ExpressionStmt) {
ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();
Type actualType = facade.getType(expressionStmt.getExpression());
Type formalType = functionalMethod.get().returnType();
// Infer the functional interfaces' return vs actual type
funcInterfaceCtx.addPair(actualType, formalType);
// Substitute to obtain a new type
Type functionalTypeWithReturn = funcInterfaceCtx.resolve(funcInterfaceCtx.addSingle(functionalInterfaceType));
// if the functional method returns void anyway
// we don't need to bother inferring types
if (!(formalType instanceof VoidType)){
lambdaCtx.addPair(result, functionalTypeWithReturn);
result = lambdaCtx.resolve(lambdaCtx.addSingle(result));
}
} else {
throw new UnsupportedOperationException();
}
}
return result;
} else {
return refMethod.getCorrespondingDeclaration().getParam(pos).getType();
}
} else {
throw new UnsupportedOperationException(""The type of a lambda expr depends on the position and its return value"");
}
}","@ Override 
 public Type visit ( LambdaExpr node , Boolean solveLambdas ) { 
 if ( getParentNode ( node ) instanceof MethodCallExpr ) { 
 MethodCallExpr callExpr = ( MethodCallExpr ) getParentNode ( node ) ; 
 int pos = JavaParserSymbolDeclaration . getParamPos ( node ) ; 
 SymbolReference < com . github . javaparser . symbolsolver . model . declarations . MethodDeclaration > refMethod = facade . solve ( callExpr ) ; 
 if ( ! refMethod . isSolved ( ) ) { 
 throw new UnsolvedSymbolException ( getParentNode ( node ) . toString ( ) , callExpr . getName ( ) . getId ( ) ) ; 
 } 
 logger . finest ( ""getType on lambda expr "" + refMethod . getCorrespondingDeclaration ( ) . getName ( ) ) ; 
 // logger . finest ( ""Method param "" + refMethod . getCorrespondingDeclaration ( ) . getParam ( pos ) ) ; 
 if ( solveLambdas ) { 
 // The type parameter referred here should be the java . util . stream . Stream . T 
 Type result = refMethod . getCorrespondingDeclaration ( ) . getParam ( pos ) . getType ( ) ; 
 // FIXME : here we should replace the type parameters that can be resolved 
 // for example when invoking myListOfStrings . stream ( ) . filter ( s -> s . length > 0 ) ; 
 // the MethodDeclaration of filter is : 
 // Stream < T > filter ( Predicate < ? super T > predicate ) 
 // but T in this case is equal to String 
 if ( callExpr . getScope ( ) . isPresent ( ) ) { 
 Expression scope = callExpr . getScope ( ) . get ( ) ; 
 // If it is a static call we should not try to get the type of the scope 
 boolean staticCall = false ; 
 if ( scope instanceof NameExpr ) { 
 NameExpr nameExpr = ( NameExpr ) scope ; 
 try { 
 JavaParserFactory . getContext ( nameExpr , typeSolver ) . solveType ( nameExpr . getName ( ) . getId ( ) , typeSolver ) ; 
 staticCall = true ; 
 } catch ( Exception e ) { 
 } 
 } 
 if ( ! staticCall ) { 
 Type scopeType = facade . getType ( scope ) ; 
 if ( scopeType . isReferenceType ( ) ) { 
 result = scopeType . asReferenceType ( ) . useThisTypeParametersOnTheGivenType ( result ) ; 
 } 
 } 
 } 
 // We need to replace the type variables 
 Context ctx = JavaParserFactory . getContext ( node , typeSolver ) ; 
 result = facade . solveGenericTypes ( result , ctx , typeSolver ) ; 
 // We should find out which is the functional method ( e . g . , apply ) and replace the params of the 
 // solveLambdas with it , to derive so the values . We should also consider the value returned by the 
 // lambdas 
 Optional < MethodUsage > functionalMethod = FunctionalInterfaceLogic . getFunctionalMethod ( result ) ; 
 if ( functionalMethod . isPresent ( ) ) { 
 LambdaExpr lambdaExpr = node ; 
 InferenceContext inferenceContext = new InferenceContext ( MyObjectProvider . INSTANCE ) ; 
 // At this point parameterType 
 // if Function < T = ? super Stream . T ,   ? extends map . R > 
 // we should replace Stream . T 
 Type functionalInterfaceType = ReferenceTypeImpl . undeterminedParameters ( functionalMethod . get ( ) . getDeclaration ( ) . declaringType ( ) , typeSolver ) ; 
 // inferenceContext . addPair ( parameterType , functionalInterfaceType ) ; 
 // inferenceContext . addPair ( parameterType , result ) ; 
 inferenceContext . addPair ( result , functionalInterfaceType ) ; 
 if ( lambdaExpr . getBody ( ) instanceof ExpressionStmt ) { 
 ExpressionStmt expressionStmt = ( ExpressionStmt ) lambdaExpr . getBody ( ) ; 
 Type actualType = facade . getType ( expressionStmt . getExpression ( ) ) ; 
 Type formalType = functionalMethod . get ( ) . returnType ( ) ; 
 // if the functional method returns void anyway 
 // we don ' t need to bother inferring types 
 if ( ! ( formalType instanceof VoidType ) ) { 
 inferenceContext . addPair ( formalType , actualType ) ; 
 result = inferenceContext . resolve ( inferenceContext . addSingle ( result ) ) ; 
 } 
 } else { 
 throw new UnsupportedOperationException ( ) ; 
 } 
 } 
 return result ; 
 } else { 
 return refMethod . getCorrespondingDeclaration ( ) . getParam ( pos ) . getType ( ) ; 
 } 
 } else { 
 throw new UnsupportedOperationException ( ""The type of a lambda expr depends on the position and its return value"" ) ; 
 } 
 }  ","@ Override 
 public Type visit ( LambdaExpr node , Boolean solveLambdas ) { 
 if ( getParentNode ( node ) instanceof MethodCallExpr ) { 
 MethodCallExpr callExpr = ( MethodCallExpr ) getParentNode ( node ) ; 
 int pos = JavaParserSymbolDeclaration . getParamPos ( node ) ; 
 SymbolReference < MethodDeclaration > refMethod = facade . solve ( callExpr ) ; 
 if ( ! refMethod . isSolved ( ) ) { 
 throw new UnsolvedSymbolException ( getParentNode ( node ) . toString ( ) , callExpr . getName ( ) . getId ( ) ) ; 
 } 
 logger . finest ( ""getType on lambda expr "" + refMethod . getCorrespondingDeclaration ( ) . getName ( ) ) ; 
 // logger . finest ( ""Method param "" + refMethod . getCorrespondingDeclaration ( ) . getParam ( pos ) ) ; 
 if ( solveLambdas ) { 
 // The type parameter referred here should be the java . util . stream . Stream . T 
 Type result = refMethod . getCorrespondingDeclaration ( ) . getParam ( pos ) . getType ( ) ; 
 if ( callExpr . getScope ( ) . isPresent ( ) ) { 
 Expression scope = callExpr . getScope ( ) . get ( ) ; 
 // If it is a static call we should not try to get the type of the scope 
 boolean staticCall = false ; 
 if ( scope instanceof NameExpr ) { 
 NameExpr nameExpr = ( NameExpr ) scope ; 
 try { 
 JavaParserFactory . getContext ( nameExpr , typeSolver ) . solveType ( nameExpr . getName ( ) . getId ( ) , typeSolver ) ; 
 staticCall = true ; 
 } catch ( Exception e ) { 
 } 
 } 
 if ( ! staticCall ) { 
 Type scopeType = facade . getType ( scope ) ; 
 if ( scopeType . isReferenceType ( ) ) { 
 result = scopeType . asReferenceType ( ) . useThisTypeParametersOnTheGivenType ( result ) ; 
 } 
 } 
 } 
 // We need to replace the type variables 
 Context ctx = JavaParserFactory . getContext ( node , typeSolver ) ; 
 result = facade . solveGenericTypes ( result , ctx , typeSolver ) ; 
 // We should find out which is the functional method ( e . g . , apply ) and replace the params of the 
 // solveLambdas with it , to derive so the values . We should also consider the value returned by the 
 // lambdas 
 Optional < MethodUsage > functionalMethod = FunctionalInterfaceLogic . getFunctionalMethod ( result ) ; 
 if ( functionalMethod . isPresent ( ) ) { 
 LambdaExpr lambdaExpr = node ; 
 InferenceContext lambdaCtx = new InferenceContext ( MyObjectProvider . INSTANCE ) ; 
 InferenceContext funcInterfaceCtx = new InferenceContext ( MyObjectProvider . INSTANCE ) ; 
 // At this point parameterType 
 // if Function < T = ? super Stream . T ,   ? extends map . R > 
 // we should replace Stream . T 
 Type functionalInterfaceType = ReferenceTypeImpl . undeterminedParameters ( functionalMethod . get ( ) . getDeclaration ( ) . declaringType ( ) , typeSolver ) ; 
 lambdaCtx . addPair ( result , functionalInterfaceType ) ; 
 if ( lambdaExpr . getBody ( ) instanceof ExpressionStmt ) { 
 ExpressionStmt expressionStmt = ( ExpressionStmt ) lambdaExpr . getBody ( ) ; 
 Type actualType = facade . getType ( expressionStmt . getExpression ( ) ) ; 
 Type formalType = functionalMethod . get ( ) . returnType ( ) ; 
 // Infer the functional interfaces ' return vs actual type 
 funcInterfaceCtx . addPair ( actualType , formalType ) ; 
 // Substitute to obtain a new type 
 Type functionalTypeWithReturn = funcInterfaceCtx . resolve ( funcInterfaceCtx . addSingle ( functionalInterfaceType ) ) ; 
 // if the functional method returns void anyway 
 // we don ' t need to bother inferring types 
 if ( ! ( formalType instanceof VoidType ) ) { 
 lambdaCtx . addPair ( result , functionalTypeWithReturn ) ; 
 result = lambdaCtx . resolve ( lambdaCtx . addSingle ( result ) ) ; 
 } 
 } else { 
 throw new UnsupportedOperationException ( ) ; 
 } 
 } 
 return result ; 
 } else { 
 return refMethod . getCorrespondingDeclaration ( ) . getParam ( pos ) . getType ( ) ; 
 } 
 } else { 
 throw new UnsupportedOperationException ( ""The type of a lambda expr depends on the position and its return value"" ) ; 
 } 
 }  ",2017-02-13 23:49:53 +0000,2017-03-23 03:31:05 +0200,5,0.9249008607521604
983,265,https://www.github.com/errai/errai,startRedistributionService(),,52,52,52,52,TODO remove clients who have not sent an update for a while,https://www.github.com/errai/errai/commit/12793dfe1e,https://www.github.com/errai/errai/commit/af8114b51a32a34f3049cb3a417db4ea1c5e551a,errai-cdi/demos/errai-cdi-mobile-demo/src/main/java/org/jboss/errai/demo/mobile/server/OrientationDataSatellite.java,"@PostConstruct
public void startRedistributionService() {
ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
executor.scheduleWithFixedDelay(new Runnable() {

      @Override
public void run() {
// TODO remove clients who have not sent an update for a while
List<OrientationEvent> clientOrientationList =
            new ArrayList<OrientationEvent>(clientOrientations.values());
orientationEventSrc.fire(new AllClientOrientations(clientOrientationList));
long cutoffTime = System.currentTimeMillis() - 2000;
Iterator<Map.Entry<String, OrientationEvent>> it = clientOrientations.entrySet().iterator();
while (it.hasNext()) {
Map.Entry<String, OrientationEvent> entry = it.next();
if (entry.getValue().getTimestamp() < cutoffTime) {
it.remove();
disconnectEventSrc.fire(entry.getValue());
}
}
}
    }, 1000, 250, TimeUnit.MILLISECONDS);
}","@PostConstruct
public void startRedistributionService() {
executor.scheduleWithFixedDelay(new Runnable() {

      @Override
public void run() {
List<OrientationEvent> clientOrientationList =
            new ArrayList<OrientationEvent>(clientOrientations.values());
orientationEventSrc.fire(new AllClientOrientations(clientOrientationList));
// Notify everyone about clients who have gone away
long cutoffTime = System.currentTimeMillis() - 2000;
Iterator<Map.Entry<String, OrientationEvent>> it = clientOrientations.entrySet().iterator();
while (it.hasNext()) {
Map.Entry<String, OrientationEvent> entry = it.next();
if (entry.getValue().getTimestamp() < cutoffTime) {
it.remove();
disconnectEventSrc.fire(entry.getValue());
}
}
}
    }, 1000, 250, TimeUnit.MILLISECONDS);
}","@ PostConstruct 
 public void startRedistributionService ( ) { 
 ScheduledExecutorService executor = Executors . newSingleThreadScheduledExecutor ( ) ; 
 executor . scheduleWithFixedDelay ( new Runnable ( ) { 
 
 @ Override 
 public void run ( ) { 
 // TODO remove clients who have not sent an update for a while 
 List < OrientationEvent > clientOrientationList = 
 new ArrayList < OrientationEvent > ( clientOrientations . values ( ) ) ; 
 orientationEventSrc . fire ( new AllClientOrientations ( clientOrientationList ) ) ; 
 long cutoffTime = System . currentTimeMillis ( ) - 2000 ; 
 Iterator < Map . Entry < String , OrientationEvent >> it = clientOrientations . entrySet ( ) . iterator ( ) ; 
 while ( it . hasNext ( ) ) { 
 Map . Entry < String , OrientationEvent > entry = it . next ( ) ; 
 if ( entry . getValue ( ) . getTimestamp ( ) < cutoffTime ) { 
 it . remove ( ) ; 
 disconnectEventSrc . fire ( entry . getValue ( ) ) ; 
 } 
 } 
 } 
 } , 1000 , 250 , TimeUnit . MILLISECONDS ) ; 
 }  ","@ PostConstruct 
 public void startRedistributionService ( ) { 
 executor . scheduleWithFixedDelay ( new Runnable ( ) { 
 
 @ Override 
 public void run ( ) { 
 List < OrientationEvent > clientOrientationList = 
 new ArrayList < OrientationEvent > ( clientOrientations . values ( ) ) ; 
 orientationEventSrc . fire ( new AllClientOrientations ( clientOrientationList ) ) ; 
 // Notify everyone about clients who have gone away 
 long cutoffTime = System . currentTimeMillis ( ) - 2000 ; 
 Iterator < Map . Entry < String , OrientationEvent >> it = clientOrientations . entrySet ( ) . iterator ( ) ; 
 while ( it . hasNext ( ) ) { 
 Map . Entry < String , OrientationEvent > entry = it . next ( ) ; 
 if ( entry . getValue ( ) . getTimestamp ( ) < cutoffTime ) { 
 it . remove ( ) ; 
 disconnectEventSrc . fire ( entry . getValue ( ) ) ; 
 } 
 } 
 } 
 } , 1000 , 250 , TimeUnit . MILLISECONDS ) ; 
 }  ",2012/3/8 15:32,2012/4/12 18:04,2,0.9306866210166663
3472,13,https://www.github.com/aosp-mirror/platform_packages_apps_settings,onPostExecute(Exception),,150,150,151,153,TODO: refine this warning threshold,https://www.github.com/aosp-mirror/platform_packages_apps_settings/commit/0de201438045,https://www.github.com/aosp-mirror/platform_packages_apps_settings/commit/f99b424f3b147ed165a28d4124362f0e53cadf53,src/com/android/settings/deviceinfo/StorageWizardFormatProgress.java,"@Override
protected void onPostExecute(Exception e) {
final StorageWizardFormatProgress activity = mActivity;
if (e != null) {
Log.e(TAG, ""Failed to partition"", e);
Toast.makeText(activity, e.getMessage(), Toast.LENGTH_LONG).show();
activity.finishAffinity();
return;
}
final float pct = (float) mInternalBench / (float) mPrivateBench;
Log.d(TAG, ""New volume is "" + pct + ""x the speed of internal"");
// TODO: refine this warning threshold
if (mPrivateBench > 2000000000) {
final SlowWarningFragment dialog = new SlowWarningFragment();
dialog.show(activity.getFragmentManager(), TAG_SLOW_WARNING);
} else {
activity.onFormatFinished();
}
}","@Override
protected void onPostExecute(Exception e) {
final StorageWizardFormatProgress activity = mActivity;
if (e != null) {
Log.e(TAG, ""Failed to partition"", e);
Toast.makeText(activity, e.getMessage(), Toast.LENGTH_LONG).show();
activity.finishAffinity();
return;
}
if (activity.mFormatPrivate) {
final float pct = (float) mInternalBench / (float) mPrivateBench;
Log.d(TAG, ""New volume is "" + pct + ""x the speed of internal"");
// To help set user expectations around device performance, we
// warn if the adopted media is 0.25x the speed of internal
// storage or slower.
if (Float.isNaN(pct) || pct < 0.25) {
final SlowWarningFragment dialog = new SlowWarningFragment();
dialog.show(activity.getFragmentManager(), TAG_SLOW_WARNING);
} else {
activity.onFormatFinished();
}
} else {
activity.onFormatFinished();
}
}","@ Override 
 protected void onPostExecute ( Exception e ) { 
 final StorageWizardFormatProgress activity = mActivity ; 
 if ( e != null ) { 
 Log . e ( TAG , ""Failed to partition"" , e ) ; 
 Toast . makeText ( activity , e . getMessage ( ) , Toast . LENGTH_LONG ) . show ( ) ; 
 activity . finishAffinity ( ) ; 
 return ; 
 } 
 final float pct = ( float ) mInternalBench / ( float ) mPrivateBench ; 
 Log . d ( TAG , ""New volume is "" + pct + ""x the speed of internal"" ) ; 
 // TODO : refine this warning threshold 
 if ( mPrivateBench > 2000000000 ) { 
 final SlowWarningFragment dialog = new SlowWarningFragment ( ) ; 
 dialog . show ( activity . getFragmentManager ( ) , TAG_SLOW_WARNING ) ; 
 } else { 
 activity . onFormatFinished ( ) ; 
 } 
 }  ","@ Override 
 protected void onPostExecute ( Exception e ) { 
 final StorageWizardFormatProgress activity = mActivity ; 
 if ( e != null ) { 
 Log . e ( TAG , ""Failed to partition"" , e ) ; 
 Toast . makeText ( activity , e . getMessage ( ) , Toast . LENGTH_LONG ) . show ( ) ; 
 activity . finishAffinity ( ) ; 
 return ; 
 } 
 if ( activity . mFormatPrivate ) { 
 final float pct = ( float ) mInternalBench / ( float ) mPrivateBench ; 
 Log . d ( TAG , ""New volume is "" + pct + ""x the speed of internal"" ) ; 
 // To help set user expectations around device performance , we 
 // warn if the adopted media is 0.25 x the speed of internal 
 // storage or slower . 
 if ( Float . isNaN ( pct ) | | pct < 0.25 ) { 
 final SlowWarningFragment dialog = new SlowWarningFragment ( ) ; 
 dialog . show ( activity . getFragmentManager ( ) , TAG_SLOW_WARNING ) ; 
 } else { 
 activity . onFormatFinished ( ) ; 
 } 
 } else { 
 activity . onFormatFinished ( ) ; 
 } 
 }  ",2015/5/19 12:00,2015/7/30 11:51,4,0.8549520150237286
3396,800,https://www.github.com/apavlo/h-store,startNewConnection(),,153,153,153,153,TODO: Cache this builder object?,https://www.github.com/apavlo/h-store/commit/e1f70e244,https://www.github.com/apavlo/h-store/commit/1bab1b5d481e9bfda2f11d8276349b13af32db13,src/frontend/ca/evanjones/protorpc/ProtoRpcChannel.java,"@Override
public void readCallback(SelectableChannel channel) {
while (true) {
// TODO: Cache this builder object?
RpcResponse.Builder builder = RpcResponse.newBuilder();
ProtoConnection.Status status = connection.tryRead(builder);
if (status == ProtoConnection.Status.CLOSED) {
// TODO: Fail any subsequent RPCs
throw new UnsupportedOperationException(""Connection closed: not handled (for now)."");
} else if (status == ProtoConnection.Status.NO_MESSAGE) {
break;
}
assert status == ProtoConnection.Status.MESSAGE;
// Set the appropriate flags on the RPC object
// TODO: Handle bad sequence number by ignoring/logging?
RpcResponse response = builder.build();
ProtoRpcController rpc = null;
synchronized (this) {
rpc = pendingRpcs.remove(response.getSequenceNumber());
assert response.getStatus() == Protocol.Status.OK;
assert rpc != null : ""No ProtoRpcController for Sequence# "" + response.getSequenceNumber();
}
rpc.finishRpcSuccess(response.getResponse());
}
}","@Override
public void readCallback(SelectableChannel channel) {
boolean isOpen = connection.readAllAvailable();
if (!isOpen) {
// TODO: Fail any subsequent RPCs
throw new UnsupportedOperationException(""Connection closed: not handled (for now)."");
}
while (true) {
RpcResponse.Builder builder = RpcResponse.newBuilder();
boolean success = connection.readBufferedMessage(builder);
if (!success) {
// TODO: Cache the builder object to reduce garbage?
break;
}
// Set the appropriate flags on the RPC object
// TODO: Handle bad sequence number by ignoring/logging?
RpcResponse response = builder.build();
ProtoRpcController rpc = null;
synchronized (this) {
rpc = pendingRpcs.remove(response.getSequenceNumber());
assert response.getStatus() == Protocol.Status.OK;
assert rpc != null : ""No ProtoRpcController for Sequence# "" + response.getSequenceNumber();
}
rpc.finishRpcSuccess(response.getResponse());
}
}","@ Override 
 public void readCallback ( SelectableChannel channel ) { 
 while ( true ) { 
 // TODO : Cache this builder object ? 
 RpcResponse . Builder builder = RpcResponse . newBuilder ( ) ; 
 ProtoConnection . Status status = connection . tryRead ( builder ) ; 
 if ( status == ProtoConnection . Status . CLOSED ) { 
 // TODO : Fail any subsequent RPCs 
 throw new UnsupportedOperationException ( ""Connection closed: not handled (for now)."" ) ; 
 } else if ( status == ProtoConnection . Status . NO_MESSAGE ) { 
 break ; 
 } 
 assert status == ProtoConnection . Status . MESSAGE ; 
 // Set the appropriate flags on the RPC object 
 // TODO : Handle bad sequence number by ignoring / logging ? 
 RpcResponse response = builder . build ( ) ; 
 ProtoRpcController rpc = null ; 
 synchronized ( this ) { 
 rpc = pendingRpcs . remove ( response . getSequenceNumber ( ) ) ; 
 assert response . getStatus ( ) == Protocol . Status . OK ; 
 assert rpc != null : ""No ProtoRpcController for Sequence# "" + response . getSequenceNumber ( ) ; 
 } 
 rpc . finishRpcSuccess ( response . getResponse ( ) ) ; 
 } 
 }  ","@ Override 
 public void readCallback ( SelectableChannel channel ) { 
 boolean isOpen = connection . readAllAvailable ( ) ; 
 if ( ! isOpen ) { 
 // TODO : Fail any subsequent RPCs 
 throw new UnsupportedOperationException ( ""Connection closed: not handled (for now)."" ) ; 
 } 
 while ( true ) { 
 RpcResponse . Builder builder = RpcResponse . newBuilder ( ) ; 
 boolean success = connection . readBufferedMessage ( builder ) ; 
 if ( ! success ) { 
 // TODO : Cache the builder object to reduce garbage ? 
 break ; 
 } 
 // Set the appropriate flags on the RPC object 
 // TODO : Handle bad sequence number by ignoring / logging ? 
 RpcResponse response = builder . build ( ) ; 
 ProtoRpcController rpc = null ; 
 synchronized ( this ) { 
 rpc = pendingRpcs . remove ( response . getSequenceNumber ( ) ) ; 
 assert response . getStatus ( ) == Protocol . Status . OK ; 
 assert rpc != null : ""No ProtoRpcController for Sequence# "" + response . getSequenceNumber ( ) ; 
 } 
 rpc . finishRpcSuccess ( response . getResponse ( ) ) ; 
 } 
 }  ",2010-09-23 18:28:18 +0000,2011-04-20 23:03:17 +0000,1,0.7578709258021571
2032,27,https://www.github.com/aosp-mirror/platform_packages_apps_packageinstaller,onCreate(Bundle),DESIGN,55,55,55,55,TODO: Allow proxy package?,https://www.github.com/aosp-mirror/platform_packages_apps_packageinstaller/commit/056a33bcac,https://www.github.com/aosp-mirror/platform_packages_apps_packageinstaller/commit/316e8d80355a0ed19fe2666a8a26a90c9040855e,src/com/android/packageinstaller/role/ui/RequestRoleActivity.java,"@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
getWindow().addSystemFlags(
                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);
String roleName = getIntent().getStringExtra(RoleManager.EXTRA_REQUEST_ROLE_NAME);
if (TextUtils.isEmpty(roleName)) {
Log.w(LOG_TAG, ""Role name cannot be null or empty: "" + roleName);
finish();
return;
}
// TODO: Allow proxy package?
String packageName = getCallingPackage();
if (TextUtils.isEmpty(packageName)) {
Log.w(LOG_TAG, ""Package name cannot be null or empty: "" + packageName);
finish();
return;
}
// Perform checks here so that we have a chance to finish without being visible to user.
Role role = Roles.getRoles(this).get(roleName);
if (role == null) {
Log.w(LOG_TAG, ""Unknown role: "" + roleName);
finish();
return;
}
if (PackageUtils.getApplicationInfo(packageName, this) == null) {
Log.w(LOG_TAG, ""Unknown application: "" + packageName);
finish();
return;
}
RoleManager roleManager = getSystemService(RoleManager.class);
List<String> currentPackageNames = roleManager.getRoleHolders(roleName);
if (currentPackageNames.contains(packageName)) {
Log.i(LOG_TAG, ""Application is already a role holder, role: "" + roleName + "", package: ""
+ packageName);
setResult(RESULT_OK);
finish();
return;
}
if (!role.isPackageQualified(packageName, this)) {
Log.w(LOG_TAG, ""Application doesn't qualify for role, role: "" + roleName + "", package: ""
+ packageName);
finish();
return;
}
// TODO: STOPSHIP: Handle other form factors.
if (savedInstanceState == null) {
RequestRoleFragment fragment = RequestRoleFragment.newInstance(
                    roleName, packageName);
getSupportFragmentManager().beginTransaction()
.add(fragment, null)
.commit();
}
}","@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
getWindow().addSystemFlags(
                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);
mRoleName = getIntent().getStringExtra(RoleManager.EXTRA_REQUEST_ROLE_NAME);
mPackageName = getCallingPackage();
ensureSmsDefaultDialogCompatibility();
if (TextUtils.isEmpty(mRoleName)) {
Log.w(LOG_TAG, ""Role name cannot be null or empty: "" + mRoleName);
finish();
return;
}
if (TextUtils.isEmpty(mPackageName)) {
Log.w(LOG_TAG, ""Package name cannot be null or empty: "" + mPackageName);
finish();
return;
}
// Perform checks here so that we have a chance to finish without being visible to user.
Role role = Roles.getRoles(this).get(mRoleName);
if (role == null) {
Log.w(LOG_TAG, ""Unknown role: "" + mRoleName);
finish();
return;
}
if (PackageUtils.getApplicationInfo(mPackageName, this) == null) {
Log.w(LOG_TAG, ""Unknown application: "" + mPackageName);
finish();
return;
}
RoleManager roleManager = getSystemService(RoleManager.class);
List<String> currentPackageNames = roleManager.getRoleHolders(mRoleName);
if (currentPackageNames.contains(mPackageName)) {
Log.i(LOG_TAG, ""Application is already a role holder, role: "" + mRoleName
+ "", package: "" + mPackageName);
setResult(RESULT_OK);
finish();
return;
}
if (!role.isPackageQualified(mPackageName, this)) {
Log.w(LOG_TAG, ""Application doesn't qualify for role, role: "" + mRoleName
+ "", package: "" + mPackageName);
finish();
return;
}
// TODO: STOPSHIP: Handle other form factors.
if (savedInstanceState == null) {
RequestRoleFragment fragment = RequestRoleFragment.newInstance(mRoleName, mPackageName);
getSupportFragmentManager().beginTransaction()
.add(fragment, null)
.commit();
}
}","@ Override 
 protected void onCreate ( @ Nullable Bundle savedInstanceState ) { 
 super . onCreate ( savedInstanceState ) ; 
 getWindow ( ) . addSystemFlags ( 
 WindowManager . LayoutParams . SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS ) ; 
 String roleName = getIntent ( ) . getStringExtra ( RoleManager . EXTRA_REQUEST_ROLE_NAME ) ; 
 if ( TextUtils . isEmpty ( roleName ) ) { 
 Log . w ( LOG_TAG , ""Role name cannot be null or empty: "" + roleName ) ; 
 finish ( ) ; 
 return ; 
 } 
 // TODO : Allow proxy package ? 
 String packageName = getCallingPackage ( ) ; 
 if ( TextUtils . isEmpty ( packageName ) ) { 
 Log . w ( LOG_TAG , ""Package name cannot be null or empty: "" + packageName ) ; 
 finish ( ) ; 
 return ; 
 } 
 // Perform checks here so that we have a chance to finish without being visible to user . 
 Role role = Roles . getRoles ( this ) . get ( roleName ) ; 
 if ( role == null ) { 
 Log . w ( LOG_TAG , ""Unknown role: "" + roleName ) ; 
 finish ( ) ; 
 return ; 
 } 
 if ( PackageUtils . getApplicationInfo ( packageName , this ) == null ) { 
 Log . w ( LOG_TAG , ""Unknown application: "" + packageName ) ; 
 finish ( ) ; 
 return ; 
 } 
 RoleManager roleManager = getSystemService ( RoleManager . class ) ; 
 List < String > currentPackageNames = roleManager . getRoleHolders ( roleName ) ; 
 if ( currentPackageNames . contains ( packageName ) ) { 
 Log . i ( LOG_TAG , ""Application is already a role holder, role: "" + roleName + "", package: "" 
 + packageName ) ; 
 setResult ( RESULT_OK ) ; 
 finish ( ) ; 
 return ; 
 } 
 if ( ! role . isPackageQualified ( packageName , this ) ) { 
 Log . w ( LOG_TAG , ""Application doesn't qualify for role, role: "" + roleName + "", package: "" 
 + packageName ) ; 
 finish ( ) ; 
 return ; 
 } 
 // TODO : STOPSHIP : Handle other form factors . 
 if ( savedInstanceState == null ) { 
 RequestRoleFragment fragment = RequestRoleFragment . newInstance ( 
 roleName , packageName ) ; 
 getSupportFragmentManager ( ) . beginTransaction ( ) 
 . add ( fragment , null ) 
 . commit ( ) ; 
 } 
 }  ","@ Override 
 protected void onCreate ( @ Nullable Bundle savedInstanceState ) { 
 super . onCreate ( savedInstanceState ) ; 
 getWindow ( ) . addSystemFlags ( 
 WindowManager . LayoutParams . SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS ) ; 
 mRoleName = getIntent ( ) . getStringExtra ( RoleManager . EXTRA_REQUEST_ROLE_NAME ) ; 
 mPackageName = getCallingPackage ( ) ; 
 ensureSmsDefaultDialogCompatibility ( ) ; 
 if ( TextUtils . isEmpty ( mRoleName ) ) { 
 Log . w ( LOG_TAG , ""Role name cannot be null or empty: "" + mRoleName ) ; 
 finish ( ) ; 
 return ; 
 } 
 if ( TextUtils . isEmpty ( mPackageName ) ) { 
 Log . w ( LOG_TAG , ""Package name cannot be null or empty: "" + mPackageName ) ; 
 finish ( ) ; 
 return ; 
 } 
 // Perform checks here so that we have a chance to finish without being visible to user . 
 Role role = Roles . getRoles ( this ) . get ( mRoleName ) ; 
 if ( role == null ) { 
 Log . w ( LOG_TAG , ""Unknown role: "" + mRoleName ) ; 
 finish ( ) ; 
 return ; 
 } 
 if ( PackageUtils . getApplicationInfo ( mPackageName , this ) == null ) { 
 Log . w ( LOG_TAG , ""Unknown application: "" + mPackageName ) ; 
 finish ( ) ; 
 return ; 
 } 
 RoleManager roleManager = getSystemService ( RoleManager . class ) ; 
 List < String > currentPackageNames = roleManager . getRoleHolders ( mRoleName ) ; 
 if ( currentPackageNames . contains ( mPackageName ) ) { 
 Log . i ( LOG_TAG , ""Application is already a role holder, role: "" + mRoleName 
 + "", package: "" + mPackageName ) ; 
 setResult ( RESULT_OK ) ; 
 finish ( ) ; 
 return ; 
 } 
 if ( ! role . isPackageQualified ( mPackageName , this ) ) { 
 Log . w ( LOG_TAG , ""Application doesn't qualify for role, role: "" + mRoleName 
 + "", package: "" + mPackageName ) ; 
 finish ( ) ; 
 return ; 
 } 
 // TODO : STOPSHIP : Handle other form factors . 
 if ( savedInstanceState == null ) { 
 RequestRoleFragment fragment = RequestRoleFragment . newInstance ( mRoleName , mPackageName ) ; 
 getSupportFragmentManager ( ) . beginTransaction ( ) 
 . add ( fragment , null ) 
 . commit ( ) ; 
 } 
 }  ",2018/11/12 10:31,2018/12/20 14:31,17,0.6005353530210161
1917,632,https://www.github.com/genericworkflownodes/genericknimenodes,loadValidatedSettingsFrom(NodeSettingsRO),NOT_DESIGN,389,389,390,390,TODO Might throw if it does not exist.,https://www.github.com/genericworkflownodes/genericknimenodes/commit/1427ef89c,https://www.github.com/genericworkflownodes/genericknimenodes/commit/ce8600440ff03ddd22e40ea6a2b856efe3402f82,com.genericworkflownodes.knime/src/com/genericworkflownodes/knime/generic_node/GenericKnimeNodeModel.java,"@Override
protected void loadValidatedSettingsFrom(final NodeSettingsRO settings)
throws InvalidSettingsException {
// - we know that values are validated and thus are valid
// - we transfer the values into the corresponding model objects
for (String key : m_nodeConfig.getParameterKeys()) {
// FileParameters are not set by the UI
if (m_nodeConfig.getParameter(key) instanceof IFileParameter)
continue;
String value = settings.getString(key);
try {
m_nodeConfig.getParameter(key).fillFromString(value);
} catch (InvalidParameterValueException e) {
//TODO I think we could hard fail here and throw an InvalidSettingsException
LOGGER.warn(
                        ""Caught InvalidParameterValueException in loadValidatedSettingsFrom()"",
                        e);
}
}
//TODO this is fully  copied from the load settings in the Dialog
// there has to be sth that we can do about that duplications
int nP = m_nodeConfig.getNumberOfOutputPorts();
selectedPorts = new int[nP];
activePorts = new boolean[nP];
linkedInputPorts = new int[nP];
customBasenames = new String[nP];
for (int i = 0; i < nP; i++) {
int idx = -1;
//TODO Might throw if it does not exist.
idx = settings.getInt(GenericKnimeNodeModel.GENERIC_KNIME_NODES_OUT_TYPE + i);
selectedPorts[i] = idx;
try{
// A found activeness setting takes precedence
boolean active = settings
.getBoolean(GenericKnimeNodeModel.GENERIC_KNIME_NODES_OUT_ACTIVE
+ i);
activePorts[i] = active;
} catch (InvalidSettingsException e) {
// else check if index is invalid
if (idx < 0 || idx > m_nodeConfig.getOutputPorts().get(i).getMimeTypes().size())
{
activePorts[i] = false;
} // otherwise default to active
else
                    {
activePorts[i] = true;
}
}
try{ //get linked inport
int linked = settings
.getInt(GenericKnimeNodeModel.GENERIC_KNIME_NODES_OUT_LINKEDINPUT
+ i);
linkedInputPorts[i] = linked;
} catch (InvalidSettingsException e) {
// probably an older version then. Index 0 is auto.
linkedInputPorts[i] = 0;
}
try{ //get custom basename
String bn = settings
.getString(GenericKnimeNodeModel.GENERIC_KNIME_NODES_OUT_CUSTOMBASENAME
+ i);
customBasenames[i] = bn;
} catch (InvalidSettingsException e) {
// probably an older version then.
customBasenames[i] = """";
}
}
}","@Override
protected void loadValidatedSettingsFrom(final NodeSettingsRO settings)
throws InvalidSettingsException {
// - we know that values are validated and thus are valid
// - we transfer the values into the corresponding model objects
for (String key : m_nodeConfig.getParameterKeys()) {
// FileParameters are not set by the UI
if (m_nodeConfig.getParameter(key) instanceof IFileParameter)
continue;
String value = settings.getString(key);
try {
m_nodeConfig.getParameter(key).fillFromString(value);
} catch (InvalidParameterValueException e) {
//TODO I think we could hard fail here and throw an InvalidSettingsException
LOGGER.warn(
                        ""Caught InvalidParameterValueException in loadValidatedSettingsFrom()"",
                        e);
}
}
//TODO this is fully  copied from the load settings in the Dialog
// there has to be sth that we can do about that duplications
//TODO Shouldn't this also be done in the validateSettings method?
int nP = m_nodeConfig.getNumberOfOutputPorts();
selectedPorts = new int[nP];
activePorts = new boolean[nP];
linkedInputPorts = new int[nP];
customBasenames = new String[nP];
for (int i = 0; i < nP; i++) {
Port p = m_nodeConfig.getOutputPorts().get(i);
int idx = 0; // default mimetype is the first
try{
idx = settings.getInt(GenericKnimeNodeModel.GENERIC_KNIME_NODES_OUT_TYPE + i);
selectedPorts[i] = idx;
} catch (InvalidSettingsException e) {
//TODO Warning that we fell back to defaults?
}
boolean idxOOR = (idx < 0 || idx >= p.getMimeTypes().size());
if (idxOOR && !p.isOptional()) // invalid required port setting read
{
idx = 0;
//TODO Best would be to also deactivate this port to show the user that they have to reconfigure.
// But currently I disabled the editing of the activeness checkbox for required ports, so it would get
// initialized with an unchecked checkbox and you could not reactivate.
// You could do a function that, when the OutputTypes tab is clicked, that it resets to active
// for all required ports, because we assume the user has seen/thought about the new settings.
// But then, anyways a loaded unchanged workflow would fail due to inactiveness of the port, so no general best solution
// for it.
// Maybe provide better defaults (e.g. by looking at a mapping from old to new versions, if available). But
// that is a lot of work and does not work if the invalidness didnt come from a version change.
LOGGER.warn(""Invalid mime-type index in settings.xml for required port #"" + i + "". Using default (first)."");
}
try{
// A found activeness setting always takes precedence
boolean active = settings
.getBoolean(GenericKnimeNodeModel.GENERIC_KNIME_NODES_OUT_ACTIVE
+ i);
activePorts[i] = active;
} catch (InvalidSettingsException e) {
// else check if index is invalid otherwise default to active. This is also to cope
// with old versions that encoded invalidness in an additional mimetype that is either present as inactive
// in old generated NodeFactories or out of range in newer ones/dynamic factories.
activePorts[i] = !(idxOOR || p.getMimeTypes().get(selectedPorts[i]).toLowerCase() == ""inactive"");
}
try{ //get linked inport
int linked = settings
.getInt(GenericKnimeNodeModel.GENERIC_KNIME_NODES_OUT_LINKEDINPUT
+ i);
linkedInputPorts[i] = linked;
} catch (InvalidSettingsException e) {
// probably an older version then. Index 0 is auto.
linkedInputPorts[i] = 0;
}
try{ //get custom basename
String bn = settings
.getString(GenericKnimeNodeModel.GENERIC_KNIME_NODES_OUT_CUSTOMBASENAME
+ i);
customBasenames[i] = bn;
} catch (InvalidSettingsException e) {
// probably an older version then.
customBasenames[i] = """";
}
m_nodeConfig.getOutputPorts().get(i).setActive(activePorts[i]);
m_nodeConfig.getOutputPorts().get(i).setLinkedPortIndex(linkedInputPorts[i]);
m_nodeConfig.getOutputPorts().get(i).setUserBasename(customBasenames[i]);
}
}","@ Override 
 protected void loadValidatedSettingsFrom ( final NodeSettingsRO settings ) 
 throws InvalidSettingsException { 
 // - we know that values are validated and thus are valid 
 // - we transfer the values into the corresponding model objects 
 for ( String key : m_nodeConfig . getParameterKeys ( ) ) { 
 // FileParameters are not set by the UI 
 if ( m_nodeConfig . getParameter ( key ) instanceof IFileParameter ) 
 continue ; 
 String value = settings . getString ( key ) ; 
 try { 
 m_nodeConfig . getParameter ( key ) . fillFromString ( value ) ; 
 } catch ( InvalidParameterValueException e ) { 
 // TODO I think we could hard fail here and throw an InvalidSettingsException 
 LOGGER . warn ( 
 ""Caught InvalidParameterValueException in loadValidatedSettingsFrom()"" , 
 e ) ; 
 } 
 } 
 // TODO this is fully copied from the load settings in the Dialog 
 // there has to be sth that we can do about that duplications 
 int nP = m_nodeConfig . getNumberOfOutputPorts ( ) ; 
 selectedPorts = new int [ nP ] ; 
 activePorts = new boolean [ nP ] ; 
 linkedInputPorts = new int [ nP ] ; 
 customBasenames = new String [ nP ] ; 
 for ( int i = 0 ; i < nP ; i + + ) { 
 int idx = - 1 ; 
 // TODO Might throw if it does not exist . 
 idx = settings . getInt ( GenericKnimeNodeModel . GENERIC_KNIME_NODES_OUT_TYPE + i ) ; 
 selectedPorts [ i ] = idx ; 
 try { 
 // A found activeness setting takes precedence 
 boolean active = settings 
 . getBoolean ( GenericKnimeNodeModel . GENERIC_KNIME_NODES_OUT_ACTIVE 
 + i ) ; 
 activePorts [ i ] = active ; 
 } catch ( InvalidSettingsException e ) { 
 // else check if index is invalid 
 if ( idx < 0 | | idx > m_nodeConfig . getOutputPorts ( ) . get ( i ) . getMimeTypes ( ) . size ( ) ) 
 { 
 activePorts [ i ] = false ; 
 } // otherwise default to active 
 else 
 { 
 activePorts [ i ] = true ; 
 } 
 } 
 try { // get linked inport 
 int linked = settings 
 . getInt ( GenericKnimeNodeModel . GENERIC_KNIME_NODES_OUT_LINKEDINPUT 
 + i ) ; 
 linkedInputPorts [ i ] = linked ; 
 } catch ( InvalidSettingsException e ) { 
 // probably an older version then . Index 0 is auto . 
 linkedInputPorts [ i ] = 0 ; 
 } 
 try { // get custom basename 
 String bn = settings 
 . getString ( GenericKnimeNodeModel . GENERIC_KNIME_NODES_OUT_CUSTOMBASENAME 
 + i ) ; 
 customBasenames [ i ] = bn ; 
 } catch ( InvalidSettingsException e ) { 
 // probably an older version then . 
 customBasenames [ i ] = """" ; 
 } 
 } 
 }  ","@ Override 
 protected void loadValidatedSettingsFrom ( final NodeSettingsRO settings ) 
 throws InvalidSettingsException { 
 // - we know that values are validated and thus are valid 
 // - we transfer the values into the corresponding model objects 
 for ( String key : m_nodeConfig . getParameterKeys ( ) ) { 
 // FileParameters are not set by the UI 
 if ( m_nodeConfig . getParameter ( key ) instanceof IFileParameter ) 
 continue ; 
 String value = settings . getString ( key ) ; 
 try { 
 m_nodeConfig . getParameter ( key ) . fillFromString ( value ) ; 
 } catch ( InvalidParameterValueException e ) { 
 // TODO I think we could hard fail here and throw an InvalidSettingsException 
 LOGGER . warn ( 
 ""Caught InvalidParameterValueException in loadValidatedSettingsFrom()"" , 
 e ) ; 
 } 
 } 
 // TODO this is fully copied from the load settings in the Dialog 
 // there has to be sth that we can do about that duplications 
 // TODO Shouldn ' t this also be done in the validateSettings method ? 
 int nP = m_nodeConfig . getNumberOfOutputPorts ( ) ; 
 selectedPorts = new int [ nP ] ; 
 activePorts = new boolean [ nP ] ; 
 linkedInputPorts = new int [ nP ] ; 
 customBasenames = new String [ nP ] ; 
 for ( int i = 0 ; i < nP ; i + + ) { 
 Port p = m_nodeConfig . getOutputPorts ( ) . get ( i ) ; 
 int idx = 0 ; // default mimetype is the first 
 try { 
 idx = settings . getInt ( GenericKnimeNodeModel . GENERIC_KNIME_NODES_OUT_TYPE + i ) ; 
 selectedPorts [ i ] = idx ; 
 } catch ( InvalidSettingsException e ) { 
 // TODO Warning that we fell back to defaults ? 
 } 
 boolean idxOOR = ( idx < 0 | | idx >= p . getMimeTypes ( ) . size ( ) ) ; 
 if ( idxOOR & &   ! p . isOptional ( ) ) // invalid required port setting read 
 { 
 idx = 0 ; 
 // TODO Best would be to also deactivate this port to show the user that they have to reconfigure . 
 // But currently I disabled the editing of the activeness checkbox for required ports , so it would get 
 // initialized with an unchecked checkbox and you could not reactivate . 
 // You could do a function that , when the OutputTypes tab is clicked , that it resets to active 
 // for all required ports , because we assume the user has seen / thought about the new settings . 
 // But then , anyways a loaded unchanged workflow would fail due to inactiveness of the port , so no general best solution 
 // for it . 
 // Maybe provide better defaults ( e . g . by looking at a mapping from old to new versions , if available ) . But 
 // that is a lot of work and does not work if the invalidness didnt come from a version change . 
 LOGGER . warn ( ""Invalid mime-type index in settings.xml for required port #"" + i + "". Using default (first)."" ) ; 
 } 
 try { 
 // A found activeness setting always takes precedence 
 boolean active = settings 
 . getBoolean ( GenericKnimeNodeModel . GENERIC_KNIME_NODES_OUT_ACTIVE 
 + i ) ; 
 activePorts [ i ] = active ; 
 } catch ( InvalidSettingsException e ) { 
 // else check if index is invalid otherwise default to active . This is also to cope 
 // with old versions that encoded invalidness in an additional mimetype that is either present as inactive 
 // in old generated NodeFactories or out of range in newer ones / dynamic factories . 
 activePorts [ i ] =   ! ( idxOOR | | p . getMimeTypes ( ) . get ( selectedPorts [ i ] ) . toLowerCase ( ) == ""inactive"" ) ; 
 } 
 try { // get linked inport 
 int linked = settings 
 . getInt ( GenericKnimeNodeModel . GENERIC_KNIME_NODES_OUT_LINKEDINPUT 
 + i ) ; 
 linkedInputPorts [ i ] = linked ; 
 } catch ( InvalidSettingsException e ) { 
 // probably an older version then . Index 0 is auto . 
 linkedInputPorts [ i ] = 0 ; 
 } 
 try { // get custom basename 
 String bn = settings 
 . getString ( GenericKnimeNodeModel . GENERIC_KNIME_NODES_OUT_CUSTOMBASENAME 
 + i ) ; 
 customBasenames [ i ] = bn ; 
 } catch ( InvalidSettingsException e ) { 
 // probably an older version then . 
 customBasenames [ i ] = """" ; 
 } 
 m_nodeConfig . getOutputPorts ( ) . get ( i ) . setActive ( activePorts [ i ] ) ; 
 m_nodeConfig . getOutputPorts ( ) . get ( i ) . setLinkedPortIndex ( linkedInputPorts [ i ] ) ; 
 m_nodeConfig . getOutputPorts ( ) . get ( i ) . setUserBasename ( customBasenames [ i ] ) ; 
 } 
 }  ",2018-03-12 20:39:27 +0100,2018-11-05 15:02:24 +0100,3,0.8145303923271934
1043,443,https://www.github.com/spring-projects/grails-data-mapping,"refreshObjectStateFromNativeEntry(PersistentEntity, Object, Serializable, DBObject, boolean)",DESIGN,623,623,626,626,TODO this should be done with a CAS approach if possible,https://www.github.com/spring-projects/grails-data-mapping/commit/4ab15c4d3,https://www.github.com/spring-projects/grails-data-mapping/commit/da6aaa9c1e717f7e9f99c21d2852c91f8cf65871,grails-datastore-mongo/src/main/groovy/org/grails/datastore/mapping/mongo/engine/MongoEntityPersister.java,"@Override
public void updateEntry(final PersistentEntity persistentEntity, final EntityAccess ea,
            final Object key, final DBObject entry) {
mongoTemplate.execute(new DbCallback<Object>() {
            public Object doInDB(DB con) throws MongoException, DataAccessException {
String collectionName = getCollectionName(persistentEntity, entry);
DBCollection dbCollection = con.getCollection(collectionName);
DBObject dbo = createDBObjectWithKey(key);
if (isVersioned(ea)) {
// TODO this should be done with a CAS approach if possible
DBObject previous = dbCollection.findOne(dbo);
checkVersion(ea, previous, persistentEntity, key);
}
DBObject newEntry = modifyNullsToUnsets(entry);
MongoSession mongoSession = (MongoSession) session;
WriteConcern writeConcern = mongoSession.getDeclaredWriteConcern(getPersistentEntity());
if (writeConcern != null) {
dbCollection.update(dbo, newEntry, false, false, writeConcern);
}
else {
dbCollection.update(dbo, newEntry, false, false);
}
return null;
}
        });
}","@Override
public void updateEntry(final PersistentEntity persistentEntity, final EntityAccess ea,
            final Object key, final DBObject entry) {
mongoTemplate.execute(new DbCallback<Object>() {
            public Object doInDB(DB con) throws MongoException, DataAccessException {
String collectionName = getCollectionName(persistentEntity, entry);
DBCollection dbCollection = con.getCollection(collectionName);
DBObject dbo = createDBObjectWithKey(key);
boolean versioned = isVersioned(ea);
if (versioned) {
Object currentVersion = getCurrentVersion(ea);
incrementVersion(ea);
// query for old version to ensure atomicity
if (currentVersion != null) {
dbo.put(""version"", currentVersion);
}
}
DBObject newEntry = modifyNullsToUnsets(entry);
MongoSession mongoSession = (MongoSession) session;
WriteConcern writeConcern = mongoSession.getDeclaredWriteConcern(getPersistentEntity());
WriteResult result;
if (writeConcern != null) {
result = dbCollection.update(dbo, newEntry, false, false, writeConcern);
}
else {
result = dbCollection.update(dbo, newEntry, false, false);
}
if (versioned) {
// ok, we need to check whether the write worked:
// note that this will use the standard write concern unless it wasn't at least ACKNOWLEDGE:
CommandResult error = result.getLastError(WriteConcern.ACKNOWLEDGED);
// may as well handle any networking errors:
error.throwOnError();
// if the document count ""n"" of the update was 0, the versioning check must have failed:
if (error.getInt(""n"") == 0) {
throw new OptimisticLockingException(persistentEntity, key);
}
}
return null;
}
        });
}","@ Override 
 public void updateEntry ( final PersistentEntity persistentEntity , final EntityAccess ea , 
 final Object key , final DBObject entry ) { 
 mongoTemplate . execute ( new DbCallback < Object > ( ) { 
 public Object doInDB ( DB con ) throws MongoException , DataAccessException { 
 String collectionName = getCollectionName ( persistentEntity , entry ) ; 
 DBCollection dbCollection = con . getCollection ( collectionName ) ; 
 DBObject dbo = createDBObjectWithKey ( key ) ; 
 if ( isVersioned ( ea ) ) { 
 // TODO this should be done with a CAS approach if possible 
 DBObject previous = dbCollection . findOne ( dbo ) ; 
 checkVersion ( ea , previous , persistentEntity , key ) ; 
 } 
 DBObject newEntry = modifyNullsToUnsets ( entry ) ; 
 MongoSession mongoSession = ( MongoSession ) session ; 
 WriteConcern writeConcern = mongoSession . getDeclaredWriteConcern ( getPersistentEntity ( ) ) ; 
 if ( writeConcern != null ) { 
 dbCollection . update ( dbo , newEntry , false , false , writeConcern ) ; 
 } 
 else { 
 dbCollection . update ( dbo , newEntry , false , false ) ; 
 } 
 return null ; 
 } 
 } ) ; 
 }  ","@ Override 
 public void updateEntry ( final PersistentEntity persistentEntity , final EntityAccess ea , 
 final Object key , final DBObject entry ) { 
 mongoTemplate . execute ( new DbCallback < Object > ( ) { 
 public Object doInDB ( DB con ) throws MongoException , DataAccessException { 
 String collectionName = getCollectionName ( persistentEntity , entry ) ; 
 DBCollection dbCollection = con . getCollection ( collectionName ) ; 
 DBObject dbo = createDBObjectWithKey ( key ) ; 
 boolean versioned = isVersioned ( ea ) ; 
 if ( versioned ) { 
 Object currentVersion = getCurrentVersion ( ea ) ; 
 incrementVersion ( ea ) ; 
 // query for old version to ensure atomicity 
 if ( currentVersion != null ) { 
 dbo . put ( ""version"" , currentVersion ) ; 
 } 
 } 
 DBObject newEntry = modifyNullsToUnsets ( entry ) ; 
 MongoSession mongoSession = ( MongoSession ) session ; 
 WriteConcern writeConcern = mongoSession . getDeclaredWriteConcern ( getPersistentEntity ( ) ) ; 
 WriteResult result ; 
 if ( writeConcern != null ) { 
 result = dbCollection . update ( dbo , newEntry , false , false , writeConcern ) ; 
 } 
 else { 
 result = dbCollection . update ( dbo , newEntry , false , false ) ; 
 } 
 if ( versioned ) { 
 // ok , we need to check whether the write worked : 
 // note that this will use the standard write concern unless it wasn ' t at least ACKNOWLEDGE : 
 CommandResult error = result . getLastError ( WriteConcern . ACKNOWLEDGED ) ; 
 // may as well handle any networking errors : 
 error . throwOnError ( ) ; 
 // if the document count ""n"" of the update was 0 , the versioning check must have failed : 
 if ( error . getInt ( ""n"" ) == 0 ) { 
 throw new OptimisticLockingException ( persistentEntity , key ) ; 
 } 
 } 
 return null ; 
 } 
 } ) ; 
 }  ",2011-04-08 12:07:40 +0100,2013-01-10 10:45:02 +0000,21,0.7786443387981232
3404,13,https://www.github.com/aosp-mirror/platform_packages_apps_settings,loadContextualCards(ContextualCardsFragment),,198,198,198,198,TODO(b/123668403): remove the log here once we do the change with FutureTask,https://www.github.com/aosp-mirror/platform_packages_apps_settings/commit/1f595d9659aa,https://www.github.com/aosp-mirror/platform_packages_apps_settings/commit/620d6aeccb20994da2fe43149aa3e005f4d2ba26,src/com/android/settings/homepage/contextualcards/ContextualCardManager.java,"@Override
public void onFinishCardLoading(List<ContextualCard> cards) {
final long loadTime = System.currentTimeMillis() - mStartTime;
//TODO(b/123668403): remove the log here once we do the change with FutureTask
Log.d(TAG, ""Total loading time = "" + loadTime);
final List<ContextualCard> cardsToKeep = getCardsToKeep(cards);
//navigate back to the homepage, screen rotate or after card dismissal
if (!mIsFirstLaunch) {
onContextualCardUpdated(cardsToKeep.stream()
.collect(groupingBy(ContextualCard::getCardType)));
return;
}
//only log homepage display upon a fresh launch
final long timeoutLimit = getCardLoaderTimeout(mContext);
if (loadTime <= timeoutLimit) {
onContextualCardUpdated(cards.stream()
.collect(groupingBy(ContextualCard::getCardType)));
}
final long totalTime = System.currentTimeMillis() - mStartTime;
FeatureFactory.getFactory(mContext).getContextualCardFeatureProvider(mContext)
.logHomepageDisplay(totalTime);
mIsFirstLaunch = false;
}","@Override
public void onFinishCardLoading(List<ContextualCard> cards) {
final long loadTime = System.currentTimeMillis() - mStartTime;
Log.d(TAG, ""Total loading time = "" + loadTime);
final List<ContextualCard> cardsToKeep = getCardsToKeep(cards);
//navigate back to the homepage, screen rotate or after card dismissal
if (!mIsFirstLaunch) {
onContextualCardUpdated(cardsToKeep.stream()
.collect(groupingBy(ContextualCard::getCardType)));
return;
}
final MetricsFeatureProvider metricsFeatureProvider =
                FeatureFactory.getFactory(mContext).getMetricsFeatureProvider();
final long timeoutLimit = getCardLoaderTimeout(mContext);
if (loadTime <= timeoutLimit) {
onContextualCardUpdated(cards.stream()
.collect(groupingBy(ContextualCard::getCardType)));
} else {
// log timeout occurrence
metricsFeatureProvider.action(SettingsEnums.PAGE_UNKNOWN,
                    SettingsEnums.ACTION_CONTEXTUAL_CARD_LOAD_TIMEOUT,
                    SettingsEnums.SETTINGS_HOMEPAGE,
                    null /* key */, (int) loadTime /* value */);
}
//only log homepage display upon a fresh launch
final long totalTime = System.currentTimeMillis() - mStartTime;
FeatureFactory.getFactory(mContext).getContextualCardFeatureProvider(mContext)
.logHomepageDisplay(totalTime);
metricsFeatureProvider.action(mContext,
                SettingsEnums.ACTION_CONTEXTUAL_HOME_SHOW, (int) totalTime);
mIsFirstLaunch = false;
}","@ Override 
 public void onFinishCardLoading ( List < ContextualCard > cards ) { 
 final long loadTime = System . currentTimeMillis ( ) - mStartTime ; 
 // TODO ( b / 123668403 ) : remove the log here once we do the change with FutureTask 
 Log . d ( TAG , ""Total loading time = "" + loadTime ) ; 
 final List < ContextualCard > cardsToKeep = getCardsToKeep ( cards ) ; 
 // navigate back to the homepage , screen rotate or after card dismissal 
 if ( ! mIsFirstLaunch ) { 
 onContextualCardUpdated ( cardsToKeep . stream ( ) 
 . collect ( groupingBy ( ContextualCard : : getCardType ) ) ) ; 
 return ; 
 } 
 // only log homepage display upon a fresh launch 
 final long timeoutLimit = getCardLoaderTimeout ( mContext ) ; 
 if ( loadTime <= timeoutLimit ) { 
 onContextualCardUpdated ( cards . stream ( ) 
 . collect ( groupingBy ( ContextualCard : : getCardType ) ) ) ; 
 } 
 final long totalTime = System . currentTimeMillis ( ) - mStartTime ; 
 FeatureFactory . getFactory ( mContext ) . getContextualCardFeatureProvider ( mContext ) 
 . logHomepageDisplay ( totalTime ) ; 
 mIsFirstLaunch = false ; 
 }  ","@ Override 
 public void onFinishCardLoading ( List < ContextualCard > cards ) { 
 final long loadTime = System . currentTimeMillis ( ) - mStartTime ; 
 Log . d ( TAG , ""Total loading time = "" + loadTime ) ; 
 final List < ContextualCard > cardsToKeep = getCardsToKeep ( cards ) ; 
 // navigate back to the homepage , screen rotate or after card dismissal 
 if ( ! mIsFirstLaunch ) { 
 onContextualCardUpdated ( cardsToKeep . stream ( ) 
 . collect ( groupingBy ( ContextualCard : : getCardType ) ) ) ; 
 return ; 
 } 
 final MetricsFeatureProvider metricsFeatureProvider = 
 FeatureFactory . getFactory ( mContext ) . getMetricsFeatureProvider ( ) ; 
 final long timeoutLimit = getCardLoaderTimeout ( mContext ) ; 
 if ( loadTime <= timeoutLimit ) { 
 onContextualCardUpdated ( cards . stream ( ) 
 . collect ( groupingBy ( ContextualCard : : getCardType ) ) ) ; 
 } else { 
 // log timeout occurrence 
 metricsFeatureProvider . action ( SettingsEnums . PAGE_UNKNOWN , 
 SettingsEnums . ACTION_CONTEXTUAL_CARD_LOAD_TIMEOUT , 
 SettingsEnums . SETTINGS_HOMEPAGE , 
 null / * key * / , ( int ) loadTime / * value * / ) ; 
 } 
 // only log homepage display upon a fresh launch 
 final long totalTime = System . currentTimeMillis ( ) - mStartTime ; 
 FeatureFactory . getFactory ( mContext ) . getContextualCardFeatureProvider ( mContext ) 
 . logHomepageDisplay ( totalTime ) ; 
 metricsFeatureProvider . action ( mContext , 
 SettingsEnums . ACTION_CONTEXTUAL_HOME_SHOW , ( int ) totalTime ) ; 
 mIsFirstLaunch = false ; 
 }  ",2019-01-31 13:29:41 +0800,2019-03-19 18:31:01 +0800,6,0.8257271747700287
2974,13,https://www.github.com/aosp-mirror/platform_packages_apps_settings,dispatchSetNewPasswordIntent(),,114,114,114,114,"TODO: handle the case with multiple biometrics, perhaps take an arg for biometric type?",https://www.github.com/aosp-mirror/platform_packages_apps_settings/commit/81dc0295d7e2,https://www.github.com/aosp-mirror/platform_packages_apps_settings/commit/87bb772e161d22671119845cc21d5d354155d059,src/com/android/settings/password/SetNewPasswordController.java,"public void dispatchSetNewPasswordIntent() {
final Bundle extras;
// TODO: handle the case with multiple biometrics, perhaps take an arg for biometric type?
if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_FACE)
&& mFaceManager != null
&& mFaceManager.isHardwareDetected()
&& !mFaceManager.hasEnrolledTemplates(mTargetUserId)
&& !isFaceDisabledByAdmin()) {
extras = getFaceChooseLockExtras();
} else if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_FINGERPRINT)
&& mFingerprintManager != null
&& mFingerprintManager.isHardwareDetected()
&& !mFingerprintManager.hasEnrolledFingerprints(mTargetUserId)
&& !isFingerprintDisabledByAdmin()) {
extras = getFingerprintChooseLockExtras();
} else {
extras = new Bundle();
}
// No matter we show fingerprint options or not, we should tell the next activity which
// user is setting new password.
extras.putInt(Intent.EXTRA_USER_ID, mTargetUserId);
mUi.launchChooseLock(extras);
}","public void dispatchSetNewPasswordIntent() {
final Bundle extras;
final boolean hasFeatureFingerprint = mPackageManager
.hasSystemFeature(PackageManager.FEATURE_FINGERPRINT);
final boolean hasFeatureFace = mPackageManager
.hasSystemFeature(PackageManager.FEATURE_FACE);
final boolean shouldShowFingerprintEnroll = mFingerprintManager != null
&& mFingerprintManager.isHardwareDetected()
&& !mFingerprintManager.hasEnrolledFingerprints(mTargetUserId)
&& !isFingerprintDisabledByAdmin();
final boolean shouldShowFaceEnroll = mFaceManager != null
&& mFaceManager.isHardwareDetected()
&& !mFaceManager.hasEnrolledTemplates(mTargetUserId)
&& !isFaceDisabledByAdmin();
if (hasFeatureFace && shouldShowFaceEnroll
&& hasFeatureFingerprint && shouldShowFingerprintEnroll) {
extras = getBiometricChooseLockExtras();
} else if (hasFeatureFace && shouldShowFaceEnroll) {
extras = getFaceChooseLockExtras();
} else if (hasFeatureFingerprint && shouldShowFingerprintEnroll) {
extras = getFingerprintChooseLockExtras();
} else {
extras = new Bundle();
}
// No matter we show fingerprint options or not, we should tell the next activity which
// user is setting new password.
extras.putInt(Intent.EXTRA_USER_ID, mTargetUserId);
mUi.launchChooseLock(extras);
}","public void dispatchSetNewPasswordIntent ( ) { 
 final Bundle extras ; 
 // TODO : handle the case with multiple biometrics , perhaps take an arg for biometric type ? 
 if ( mPackageManager . hasSystemFeature ( PackageManager . FEATURE_FACE ) 
 & & mFaceManager != null 
 & & mFaceManager . isHardwareDetected ( ) 
 & &   ! mFaceManager . hasEnrolledTemplates ( mTargetUserId ) 
 & &   ! isFaceDisabledByAdmin ( ) ) { 
 extras = getFaceChooseLockExtras ( ) ; 
 } else if ( mPackageManager . hasSystemFeature ( PackageManager . FEATURE_FINGERPRINT ) 
 & & mFingerprintManager != null 
 & & mFingerprintManager . isHardwareDetected ( ) 
 & &   ! mFingerprintManager . hasEnrolledFingerprints ( mTargetUserId ) 
 & &   ! isFingerprintDisabledByAdmin ( ) ) { 
 extras = getFingerprintChooseLockExtras ( ) ; 
 } else { 
 extras = new Bundle ( ) ; 
 } 
 // No matter we show fingerprint options or not , we should tell the next activity which 
 // user is setting new password . 
 extras . putInt ( Intent . EXTRA_USER_ID , mTargetUserId ) ; 
 mUi . launchChooseLock ( extras ) ; 
 }  ","public void dispatchSetNewPasswordIntent ( ) { 
 final Bundle extras ; 
 final boolean hasFeatureFingerprint = mPackageManager 
 . hasSystemFeature ( PackageManager . FEATURE_FINGERPRINT ) ; 
 final boolean hasFeatureFace = mPackageManager 
 . hasSystemFeature ( PackageManager . FEATURE_FACE ) ; 
 final boolean shouldShowFingerprintEnroll = mFingerprintManager != null 
 & & mFingerprintManager . isHardwareDetected ( ) 
 & &   ! mFingerprintManager . hasEnrolledFingerprints ( mTargetUserId ) 
 & &   ! isFingerprintDisabledByAdmin ( ) ; 
 final boolean shouldShowFaceEnroll = mFaceManager != null 
 & & mFaceManager . isHardwareDetected ( ) 
 & &   ! mFaceManager . hasEnrolledTemplates ( mTargetUserId ) 
 & &   ! isFaceDisabledByAdmin ( ) ; 
 if ( hasFeatureFace & & shouldShowFaceEnroll 
 & & hasFeatureFingerprint & & shouldShowFingerprintEnroll ) { 
 extras = getBiometricChooseLockExtras ( ) ; 
 } else if ( hasFeatureFace & & shouldShowFaceEnroll ) { 
 extras = getFaceChooseLockExtras ( ) ; 
 } else if ( hasFeatureFingerprint & & shouldShowFingerprintEnroll ) { 
 extras = getFingerprintChooseLockExtras ( ) ; 
 } else { 
 extras = new Bundle ( ) ; 
 } 
 // No matter we show fingerprint options or not , we should tell the next activity which 
 // user is setting new password . 
 extras . putInt ( Intent . EXTRA_USER_ID , mTargetUserId ) ; 
 mUi . launchChooseLock ( extras ) ; 
 }  ",2018/6/29 18:19,2020/9/16 23:30,135,0.8051601655092475
404,135,https://www.github.com/jhy/jsoup,okOnSpacesForeAndAft(),NOT_DESIGN,63,63,63,63,TODO - don't really love that toString() result...,https://www.github.com/jhy/jsoup/commit/f5fc1bb04,https://www.github.com/jhy/jsoup/commit/4861505419b35b5373d00840b3f06775ccbf1454,src/test/java/org/jsoup/select/QueryParserTest.java,"@Test public void okOnSpacesForeAndAft() {
Evaluator parse = QueryParser.parse("" span div  "");
assertEquals(""div :parentspan"", parse.toString()); // TODO - don't really love that toString() result...
}","@Test public void okOnSpacesForeAndAft() {
Evaluator parse = QueryParser.parse("" span div  "");
assertEquals(""span div"", parse.toString());
}","@ Test public void okOnSpacesForeAndAft ( ) { 
 Evaluator parse = QueryParser . parse ( "" span div  "" ) ; 
 assertEquals ( ""div :parentspan"" , parse . toString ( ) ) ; // TODO - don ' t really love that toString ( ) result ... 
 }  ","@ Test public void okOnSpacesForeAndAft ( ) { 
 Evaluator parse = QueryParser . parse ( "" span div  "" ) ; 
 assertEquals ( ""span div"" , parse . toString ( ) ) ; 
 }  ",2020/1/30 22:13,2021-01-05 19:02:43 +1100,3,0.8324190852656586
2636,694,https://www.github.com/nifty-gui/nifty-gui,"updateAtlasTextureSection(int, ByteBuffer, int, int, int, int)",DESIGN,437,437,437,437,TODO Remove this debugging statement.,https://www.github.com/nifty-gui/nifty-gui/commit/350b20bdb,https://www.github.com/nifty-gui/nifty-gui/commit/533525d4d435f0b2e2e4c65eb900b6c9c8caa126,nifty-core/src/main/java/de/lessvoid/nifty/render/batch/core/BatchRenderBackendCoreProfileInternal.java,"private void updateAtlasTextureSection(
          final int atlasTextureId,
          @Nullable final ByteBuffer imageData,
          final int atlasSectionX,
          final int atlasSectionY,
          final int atlasSectionWidth,
          final int atlasSectionHeight) {
if (imageData == null) {
log.severe(""Attempted to update section of atlas texture (id: "" + atlasTextureId + "") with null image data!"");
return;
}
log.warning(""updateAtlasTextureSection with atlas texture id: "" + atlasTextureId); // TODO Remove this debugging statement.
bindAtlasTexture(atlasTextureId);
// TODO Move this OpenGL call and error check to CoreTexture2D!
gl.glTexSubImage2D(
            gl.GL_TEXTURE_2D(),
            0,
            atlasSectionX,
            atlasSectionY,
            atlasSectionWidth,
            atlasSectionHeight,
            gl.GL_RGBA(),
            gl.GL_UNSIGNED_BYTE(),
            imageData);
CheckGL.checkGLError(gl, ""Failed to update section [x, y, w, h]: ["" + atlasSectionX + "", "" + atlasSectionY + "", "" +
atlasSectionWidth + "", "" + atlasSectionHeight + ""] of atlas texture with id: "" + atlasTextureId + ""."");
}","private void updateAtlasTextureSection(
          final int atlasTextureId,
          @Nullable final ByteBuffer imageData,
          final int atlasSectionX,
          final int atlasSectionY,
          final int atlasSectionWidth,
          final int atlasSectionHeight) {
if (imageData == null) {
log.severe(""Attempted to update section of atlas texture (id: "" + atlasTextureId + "") with null image data!"");
return;
}
log.fine(""updateAtlasTextureSection with atlas texture id: "" + atlasTextureId);
bindAtlasTexture(atlasTextureId);
// TODO Move this OpenGL call and error check to CoreTexture2D!
gl.glTexSubImage2D(
            gl.GL_TEXTURE_2D(),
            0,
            atlasSectionX,
            atlasSectionY,
            atlasSectionWidth,
            atlasSectionHeight,
            gl.GL_RGBA(),
            gl.GL_UNSIGNED_BYTE(),
            imageData);
CheckGL.checkGLError(gl, ""Failed to update section [x, y, w, h]: ["" + atlasSectionX + "", "" + atlasSectionY + "", "" +
atlasSectionWidth + "", "" + atlasSectionHeight + ""] of atlas texture with id: "" + atlasTextureId + ""."");
}","private void updateAtlasTextureSection ( 
 final int atlasTextureId , 
 @ Nullable final ByteBuffer imageData , 
 final int atlasSectionX , 
 final int atlasSectionY , 
 final int atlasSectionWidth , 
 final int atlasSectionHeight ) { 
 if ( imageData == null ) { 
 log . severe ( ""Attempted to update section of atlas texture (id: "" + atlasTextureId + "") with null image data!"" ) ; 
 return ; 
 } 
 log . warning ( ""updateAtlasTextureSection with atlas texture id: "" + atlasTextureId ) ; // TODO Remove this debugging statement . 
 bindAtlasTexture ( atlasTextureId ) ; 
 // TODO Move this OpenGL call and error check to CoreTexture2D ! 
 gl . glTexSubImage2D ( 
 gl . GL_TEXTURE_2D ( ) , 
 0 , 
 atlasSectionX , 
 atlasSectionY , 
 atlasSectionWidth , 
 atlasSectionHeight , 
 gl . GL_RGBA ( ) , 
 gl . GL_UNSIGNED_BYTE ( ) , 
 imageData ) ; 
 CheckGL . checkGLError ( gl , ""Failed to update section [x, y, w, h]: ["" + atlasSectionX + "", "" + atlasSectionY + "", "" + 
 atlasSectionWidth + "", "" + atlasSectionHeight + ""] of atlas texture with id: "" + atlasTextureId + ""."" ) ; 
 }  ","private void updateAtlasTextureSection ( 
 final int atlasTextureId , 
 @ Nullable final ByteBuffer imageData , 
 final int atlasSectionX , 
 final int atlasSectionY , 
 final int atlasSectionWidth , 
 final int atlasSectionHeight ) { 
 if ( imageData == null ) { 
 log . severe ( ""Attempted to update section of atlas texture (id: "" + atlasTextureId + "") with null image data!"" ) ; 
 return ; 
 } 
 log . fine ( ""updateAtlasTextureSection with atlas texture id: "" + atlasTextureId ) ; 
 bindAtlasTexture ( atlasTextureId ) ; 
 // TODO Move this OpenGL call and error check to CoreTexture2D ! 
 gl . glTexSubImage2D ( 
 gl . GL_TEXTURE_2D ( ) , 
 0 , 
 atlasSectionX , 
 atlasSectionY , 
 atlasSectionWidth , 
 atlasSectionHeight , 
 gl . GL_RGBA ( ) , 
 gl . GL_UNSIGNED_BYTE ( ) , 
 imageData ) ; 
 CheckGL . checkGLError ( gl , ""Failed to update section [x, y, w, h]: ["" + atlasSectionX + "", "" + atlasSectionY + "", "" + 
 atlasSectionWidth + "", "" + atlasSectionHeight + ""] of atlas texture with id: "" + atlasTextureId + ""."" ) ; 
 }  ",2014/1/23 18:30,2015/5/21 23:16,2,0.9854449489732134
897,549,https://www.github.com/eclipse-vertx/vert.x,setUp(),,77,77,77,77,TODO some way of getting this from the version in pom.xml,https://www.github.com/eclipse-vertx/vert.x/commit/c178f84d08,https://www.github.com/eclipse-vertx/vert.x/commit/0d3aec1fa33ff211b2a59afd08f45954a94e4f8d,src/test/java/io/vertx/test/core/StarterTest.java,"@Test
public void testVersion() throws Exception {
String[] args = {""-version""};
MyStarter starter = new MyStarter();
starter.run(args);
// TODO some way of getting this from the version in pom.xml
assertEquals(System.getProperty(""vertxVersion""), starter.getVersion());
cleanup(starter);
}","@Test
public void testVersion() throws Exception {
String[] args = {""-version""};
MyStarter starter = new MyStarter();
starter.run(args);
assertEquals(System.getProperty(""vertx.version""), starter.getVersion());
cleanup(starter);
}","@ Test 
 public void testVersion ( ) throws Exception { 
 String [ ] args = { ""-version"" } ; 
 MyStarter starter = new MyStarter ( ) ; 
 starter . run ( args ) ; 
 // TODO some way of getting this from the version in pom . xml 
 assertEquals ( System . getProperty ( ""vertxVersion"" ) , starter . getVersion ( ) ) ; 
 cleanup ( starter ) ; 
 }  ","@ Test 
 public void testVersion ( ) throws Exception { 
 String [ ] args = { ""-version"" } ; 
 MyStarter starter = new MyStarter ( ) ; 
 starter . run ( args ) ; 
 assertEquals ( System . getProperty ( ""vertx.version"" ) , starter . getVersion ( ) ) ; 
 cleanup ( starter ) ; 
 }  ",2014-06-05 15:39:05 +0100,2017-09-20 10:15:33 +0200,20,0.8860584575490075
2135,464,https://www.github.com/glowstonemc/glowstone-legacy,"handle(GlowSession, CloseWindowMessage)",DESIGN,14,14,10,10,"todo: drop items from workbench, enchant inventory, own crafting grid if needed",https://www.github.com/glowstonemc/glowstone-legacy/commit/d171e8fd,https://www.github.com/glowstonemc/glowstone-legacy/commit/3997385b73133601f67e1dfabe687b6ccbcda372,src/main/java/net/glowstone/net/handler/play/inv/CloseWindowHandler.java,"@Override
public void handle(GlowSession session, CloseWindowMessage message) {
final GlowPlayer player = session.getPlayer();
// todo: drop items from workbench, enchant inventory, own crafting grid if needed
player.closeInventory();
if (player.getItemOnCursor() != null) {
// player.getWorld().dropItem(player.getEyeLocation(), player.getItemInHand());
if (player.getGameMode() != GameMode.CREATIVE) {
player.getInventory().addItem(player.getItemOnCursor());
}
player.setItemOnCursor(null);
}
}","@Override
public void handle(GlowSession session, CloseWindowMessage message) {
// closing the inventory will drop any items as needed
session.getPlayer().closeInventory();
}","@ Override 
 public void handle ( GlowSession session , CloseWindowMessage message ) { 
 final GlowPlayer player = session . getPlayer ( ) ; 
 // todo : drop items from workbench , enchant inventory , own crafting grid if needed 
 player . closeInventory ( ) ; 
 if ( player . getItemOnCursor ( ) != null ) { 
 // player . getWorld ( ) . dropItem ( player . getEyeLocation ( ) , player . getItemInHand ( ) ) ; 
 if ( player . getGameMode ( ) != GameMode . CREATIVE ) { 
 player . getInventory ( ) . addItem ( player . getItemOnCursor ( ) ) ; 
 } 
 player . setItemOnCursor ( null ) ; 
 } 
 }  ","@ Override 
 public void handle ( GlowSession session , CloseWindowMessage message ) { 
 // closing the inventory will drop any items as needed 
 session . getPlayer ( ) . closeInventory ( ) ; 
 }  ",2014/2/17 1:50,2014/12/27 20:32,3,0.24509516192173003
129,156,https://www.github.com/felixb/websms,addConnector(ConnectorSpec),NOT_DESIGN,1582,1582,1582,1582,FIXME: returns [],https://www.github.com/felixb/websms/commit/63770d6de,https://www.github.com/felixb/websms/commit/232711ae85a24b31b5e82600393c02f8076d1dae,src/de/ub0r/android/websms/WebSMS.java,"static final void addConnector(final ConnectorSpec connector) {
synchronized (CONNECTORS) {
if (connector == null || connector.getID() == null
|| connector.getName() == null) {
return;
}
ConnectorSpec c = getConnectorByID(connector.getID());
if (c != null) {
c.setErrorMessage((String) null); // fix sticky error status
c.update(connector);
} else {
final String name = connector.getName();
if (connector.getSubConnectorCount() == 0 || name == null
|| connector.getID() == null) {
Log.w(TAG, ""skipped adding defect connector: "" + name);
return;
}
Log.d(TAG, ""add connector with id: "" + connector.getID());
Log.d(TAG, ""add connector with name: "" + name);
boolean added = false;
final int l = CONNECTORS.size();
try {
for (int i = 0; i < l; i++) {
final ConnectorSpec cs = CONNECTORS.get(i);
if (name.compareToIgnoreCase(cs.getName()) < 0) {
CONNECTORS.add(i, connector);
added = true;
break;
}
}
} catch (NullPointerException e) {
Log.e(TAG, ""error while sorting"", e);
}
if (!added) {
CONNECTORS.add(connector);
}
c = connector;
}
if (me != null) {
final SharedPreferences p = PreferenceManager
.getDefaultSharedPreferences(me);
// update connectors balance if needed
// FIXME: on error this results in endles loop
if (c.getBalance() == null && c.isReady() && !c.isRunning()
&& c.hasCapabilities(// .
ConnectorSpec.CAPABILITIES_UPDATE)
&& p.getBoolean(PREFS_AUTOUPDATE, false)) {
final String defPrefix = p
.getString(PREFS_DEFPREFIX, ""+49"");
final String defSender = p.getString(PREFS_SENDER, """");
runCommand(me, c, ConnectorCommand.update(defPrefix,
							defSender));
}
if (prefsConnectorSpec == null
&& prefsConnectorID.equals(connector.getID())) {
prefsConnectorSpec = connector;
prefsSubConnectorSpec = connector.getSubConnector(p
.getString(PREFS_SUBCONNECTOR_ID, """"));
me.setButtons();
}
final String b = c.getBalance();
final String ob = c.getOldBalance();
if (b != null && (ob == null || !b.equals(ob))) {
me.updateBalance();
}
// FIXME: returns []
boolean runningConnectors = getConnectors(
						ConnectorSpec.CAPABILITIES_UPDATE,
						ConnectorSpec.STATUS_ENABLED
| ConnectorSpec.STATUS_UPDATING).length != 0;
if (!runningConnectors) {
runningConnectors = getConnectors(
							ConnectorSpec.CAPABILITIES_BOOTSTRAP,
							ConnectorSpec.STATUS_ENABLED
| ConnectorSpec.STATUS_BOOTSTRAPPING).length != 0;
}
me.setProgressBarIndeterminateVisibility(runningConnectors);
}
}
}","static final void addConnector(final ConnectorSpec connector) {
synchronized (CONNECTORS) {
if (connector == null || connector.getID() == null
|| connector.getName() == null) {
return;
}
ConnectorSpec c = getConnectorByID(connector.getID());
if (c != null) {
c.setErrorMessage((String) null); // fix sticky error status
c.update(connector);
} else {
final String name = connector.getName();
if (connector.getSubConnectorCount() == 0 || name == null
|| connector.getID() == null) {
Log.w(TAG, ""skipped adding defect connector: "" + name);
return;
}
Log.d(TAG, ""add connector with id: "" + connector.getID());
Log.d(TAG, ""add connector with name: "" + name);
boolean added = false;
final int l = CONNECTORS.size();
try {
for (int i = 0; i < l; i++) {
final ConnectorSpec cs = CONNECTORS.get(i);
if (name.compareToIgnoreCase(cs.getName()) < 0) {
CONNECTORS.add(i, connector);
added = true;
break;
}
}
} catch (NullPointerException e) {
Log.e(TAG, ""error while sorting"", e);
}
if (!added) {
CONNECTORS.add(connector);
}
c = connector;
if (me != null) {
final SharedPreferences p = PreferenceManager
.getDefaultSharedPreferences(me);
// update connectors balance if needed
if (c.getBalance() == null && c.isReady() && !c.isRunning()
&& c.hasCapabilities(// .
ConnectorSpec.CAPABILITIES_UPDATE)
&& p.getBoolean(PREFS_AUTOUPDATE, false)) {
final String defPrefix = p.getString(PREFS_DEFPREFIX,
								""+49"");
final String defSender = p.getString(PREFS_SENDER, """");
runCommand(me, c, ConnectorCommand.update(defPrefix,
								defSender));
}
}
}
if (me != null) {
final SharedPreferences p = PreferenceManager
.getDefaultSharedPreferences(me);
if (prefsConnectorSpec == null
&& prefsConnectorID.equals(connector.getID())) {
prefsConnectorSpec = connector;
prefsSubConnectorSpec = connector.getSubConnector(p
.getString(PREFS_SUBCONNECTOR_ID, """"));
me.setButtons();
}
final String b = c.getBalance();
final String ob = c.getOldBalance();
if (b != null && (ob == null || !b.equals(ob))) {
me.updateBalance();
}
boolean runningConnectors = getConnectors(
						ConnectorSpec.CAPABILITIES_UPDATE,
						ConnectorSpec.STATUS_ENABLED
| ConnectorSpec.STATUS_UPDATING).length != 0;
if (!runningConnectors) {
runningConnectors = getConnectors(
							ConnectorSpec.CAPABILITIES_BOOTSTRAP,
							ConnectorSpec.STATUS_ENABLED
| ConnectorSpec.STATUS_BOOTSTRAPPING).length != 0;
}
me.setProgressBarIndeterminateVisibility(runningConnectors);
}
}
}","static final void addConnector ( final ConnectorSpec connector ) { 
 synchronized ( CONNECTORS ) { 
 if ( connector == null | | connector . getID ( ) == null 
 | | connector . getName ( ) == null ) { 
 return ; 
 } 
 ConnectorSpec c = getConnectorByID ( connector . getID ( ) ) ; 
 if ( c != null ) { 
 c . setErrorMessage ( ( String ) null ) ; // fix sticky error status 
 c . update ( connector ) ; 
 } else { 
 final String name = connector . getName ( ) ; 
 if ( connector . getSubConnectorCount ( ) == 0 | | name == null 
 | | connector . getID ( ) == null ) { 
 Log . w ( TAG , ""skipped adding defect connector: "" + name ) ; 
 return ; 
 } 
 Log . d ( TAG , ""add connector with id: "" + connector . getID ( ) ) ; 
 Log . d ( TAG , ""add connector with name: "" + name ) ; 
 boolean added = false ; 
 final int l = CONNECTORS . size ( ) ; 
 try { 
 for ( int i = 0 ; i < l ; i + + ) { 
 final ConnectorSpec cs = CONNECTORS . get ( i ) ; 
 if ( name . compareToIgnoreCase ( cs . getName ( ) ) < 0 ) { 
 CONNECTORS . add ( i , connector ) ; 
 added = true ; 
 break ; 
 } 
 } 
 } catch ( NullPointerException e ) { 
 Log . e ( TAG , ""error while sorting"" , e ) ; 
 } 
 if ( ! added ) { 
 CONNECTORS . add ( connector ) ; 
 } 
 c = connector ; 
 } 
 if ( me != null ) { 
 final SharedPreferences p = PreferenceManager 
 . getDefaultSharedPreferences ( me ) ; 
 // update connectors balance if needed 
 // FIXME : on error this results in endles loop 
 if ( c . getBalance ( ) == null & & c . isReady ( ) & &   ! c . isRunning ( ) 
 & & c . hasCapabilities ( // . 
 ConnectorSpec . CAPABILITIES_UPDATE ) 
 & & p . getBoolean ( PREFS_AUTOUPDATE , false ) ) { 
 final String defPrefix = p 
 . getString ( PREFS_DEFPREFIX , ""+49"" ) ; 
 final String defSender = p . getString ( PREFS_SENDER , """" ) ; 
 runCommand ( me , c , ConnectorCommand . update ( defPrefix , 
 defSender ) ) ; 
 } 
 if ( prefsConnectorSpec == null 
 & & prefsConnectorID . equals ( connector . getID ( ) ) ) { 
 prefsConnectorSpec = connector ; 
 prefsSubConnectorSpec = connector . getSubConnector ( p 
 . getString ( PREFS_SUBCONNECTOR_ID , """" ) ) ; 
 me . setButtons ( ) ; 
 } 
 final String b = c . getBalance ( ) ; 
 final String ob = c . getOldBalance ( ) ; 
 if ( b != null & & ( ob == null | |   ! b . equals ( ob ) ) ) { 
 me . updateBalance ( ) ; 
 } 
 // FIXME : returns [ ] 
 boolean runningConnectors = getConnectors ( 
 ConnectorSpec . CAPABILITIES_UPDATE , 
 ConnectorSpec . STATUS_ENABLED 
 | ConnectorSpec . STATUS_UPDATING ) . length != 0 ; 
 if ( ! runningConnectors ) { 
 runningConnectors = getConnectors ( 
 ConnectorSpec . CAPABILITIES_BOOTSTRAP , 
 ConnectorSpec . STATUS_ENABLED 
 | ConnectorSpec . STATUS_BOOTSTRAPPING ) . length != 0 ; 
 } 
 me . setProgressBarIndeterminateVisibility ( runningConnectors ) ; 
 } 
 } 
 }  ","static final void addConnector ( final ConnectorSpec connector ) { 
 synchronized ( CONNECTORS ) { 
 if ( connector == null | | connector . getID ( ) == null 
 | | connector . getName ( ) == null ) { 
 return ; 
 } 
 ConnectorSpec c = getConnectorByID ( connector . getID ( ) ) ; 
 if ( c != null ) { 
 c . setErrorMessage ( ( String ) null ) ; // fix sticky error status 
 c . update ( connector ) ; 
 } else { 
 final String name = connector . getName ( ) ; 
 if ( connector . getSubConnectorCount ( ) == 0 | | name == null 
 | | connector . getID ( ) == null ) { 
 Log . w ( TAG , ""skipped adding defect connector: "" + name ) ; 
 return ; 
 } 
 Log . d ( TAG , ""add connector with id: "" + connector . getID ( ) ) ; 
 Log . d ( TAG , ""add connector with name: "" + name ) ; 
 boolean added = false ; 
 final int l = CONNECTORS . size ( ) ; 
 try { 
 for ( int i = 0 ; i < l ; i + + ) { 
 final ConnectorSpec cs = CONNECTORS . get ( i ) ; 
 if ( name . compareToIgnoreCase ( cs . getName ( ) ) < 0 ) { 
 CONNECTORS . add ( i , connector ) ; 
 added = true ; 
 break ; 
 } 
 } 
 } catch ( NullPointerException e ) { 
 Log . e ( TAG , ""error while sorting"" , e ) ; 
 } 
 if ( ! added ) { 
 CONNECTORS . add ( connector ) ; 
 } 
 c = connector ; 
 if ( me != null ) { 
 final SharedPreferences p = PreferenceManager 
 . getDefaultSharedPreferences ( me ) ; 
 // update connectors balance if needed 
 if ( c . getBalance ( ) == null & & c . isReady ( ) & &   ! c . isRunning ( ) 
 & & c . hasCapabilities ( // . 
 ConnectorSpec . CAPABILITIES_UPDATE ) 
 & & p . getBoolean ( PREFS_AUTOUPDATE , false ) ) { 
 final String defPrefix = p . getString ( PREFS_DEFPREFIX , 
 ""+49"" ) ; 
 final String defSender = p . getString ( PREFS_SENDER , """" ) ; 
 runCommand ( me , c , ConnectorCommand . update ( defPrefix , 
 defSender ) ) ; 
 } 
 } 
 } 
 if ( me != null ) { 
 final SharedPreferences p = PreferenceManager 
 . getDefaultSharedPreferences ( me ) ; 
 if ( prefsConnectorSpec == null 
 & & prefsConnectorID . equals ( connector . getID ( ) ) ) { 
 prefsConnectorSpec = connector ; 
 prefsSubConnectorSpec = connector . getSubConnector ( p 
 . getString ( PREFS_SUBCONNECTOR_ID , """" ) ) ; 
 me . setButtons ( ) ; 
 } 
 final String b = c . getBalance ( ) ; 
 final String ob = c . getOldBalance ( ) ; 
 if ( b != null & & ( ob == null | |   ! b . equals ( ob ) ) ) { 
 me . updateBalance ( ) ; 
 } 
 boolean runningConnectors = getConnectors ( 
 ConnectorSpec . CAPABILITIES_UPDATE , 
 ConnectorSpec . STATUS_ENABLED 
 | ConnectorSpec . STATUS_UPDATING ) . length != 0 ; 
 if ( ! runningConnectors ) { 
 runningConnectors = getConnectors ( 
 ConnectorSpec . CAPABILITIES_BOOTSTRAP , 
 ConnectorSpec . STATUS_ENABLED 
 | ConnectorSpec . STATUS_BOOTSTRAPPING ) . length != 0 ; 
 } 
 me . setProgressBarIndeterminateVisibility ( runningConnectors ) ; 
 } 
 } 
 }  ",2010-02-08 22:00:37 +0100,2010-02-10 17:16:14 +0100,1,0.9902613476725047
2679,644,https://www.github.com/spring-projects/spring-roo,getAllTypes(),,216,216,216,216,"TODO: (cromwellian) HACK! handle foreign-id refs, we assume java.lang.Long is an id",https://www.github.com/spring-projects/spring-roo/commit/328b953120,https://www.github.com/spring-projects/spring-roo/commit/17d0265b903fab7285301e323efddf6ba4bd261d,addon-gwt/src/main/java/org/springframework/roo/addon/gwt/GwtMetadata.java,"private void buildProxy() {
String destinationMetadataId = getDestinationMetadataId(MirrorType.PROXY);
JavaType name = PhysicalTypeIdentifier.getJavaType(destinationMetadataId);
List<AnnotationMetadataBuilder> typeAnnotations = createAnnotations();
// @ProxyFor(Employee.class)
typeAnnotations.add(createAdditionalAnnotation(new JavaType(""com.google.gwt.requestfactory.shared.ProxyFor"")));
List<ConstructorMetadataBuilder> constructors = new ArrayList<ConstructorMetadataBuilder>();
List<MethodMetadataBuilder> methods = new ArrayList<MethodMetadataBuilder>();
List<JavaType> extendsTypes = new ArrayList<JavaType>();
List<JavaType> implementsTypes = new ArrayList<JavaType>();
// attribs.add(new ClassAttributeValue(new JavaSymbolName(""type""), beanInfoMetadata.getJavaBean()));
// attribs.add(new StringAttributeValue(new JavaSymbolName(""token""), governorTypeDetails.getName().getSimpleTypeName()));
// typeAnnotations.add(new DefaultAnnotationMetadata(new JavaType(""com.google.gwt.requestfactory.shared.ServerType""), attribs));
// extends Proxy
extendsTypes.add(new JavaType(""com.google.gwt.requestfactory.shared.EntityProxy""));
// Decide fields we'll be mapping
SortedMap<JavaSymbolName, JavaType> propToGwtSideType = new TreeMap<JavaSymbolName, JavaType>();
if (beanInfoMetadata != null) {
for (MethodMetadata accessor : beanInfoMetadata.getPublicAccessors()) {
JavaSymbolName propertyName = new JavaSymbolName(StringUtils.uncapitalize(BeanInfoMetadata.getPropertyNameForJavaBeanMethod(accessor).getSymbolName()));
JavaType gwtSideType = null;
JavaType returnType = accessor.getReturnType();
PhysicalTypeMetadata ptmd = (PhysicalTypeMetadata) metadataService.get(PhysicalTypeIdentifier.createIdentifier(returnType, Path.SRC_MAIN_JAVA));
boolean isDomainObject = isDomainObject(returnType, ptmd);
if (isDomainObject) {
gwtSideType = getDestinationJavaType(returnType, MirrorType.PROXY);
} else {
gwtSideType = returnType;
if (returnType.isPrimitive()) {
if (returnType.equals(JavaType.BOOLEAN_PRIMITIVE)) {
gwtSideType = JavaType.BOOLEAN_OBJECT;
}
if (returnType.equals(JavaType.INT_PRIMITIVE)) {
gwtSideType = JavaType.INT_OBJECT;
}
if (returnType.equals(JavaType.DOUBLE_PRIMITIVE)) {
gwtSideType = JavaType.DOUBLE_OBJECT;
}
if (returnType.equals(JavaType.LONG_PRIMITIVE)) {
gwtSideType = JavaType.LONG_OBJECT;
}
}
// Handle the identifier special case
if (idPropertyName.equals(propertyName) && idLongOnServerSide) {
gwtSideType = JavaType.LONG_OBJECT;
}
// Handle the version special case
if (versionPropertyName.equals(propertyName) && versionIntegerOnServerSide) {
gwtSideType = JavaType.INT_OBJECT;
}
// TODO: (cromwellian) HACK! handle foreign-id refs, we assume java.lang.Long is an id
if (gwtSideType.getFullyQualifiedTypeName().equals(""java.lang.Long"") && idLongOnServerSide) {
gwtSideType = JavaType.LONG_OBJECT;
}
}
if (""id"".equals(propertyName.getSymbolName()) || ""version"".equals(propertyName.getSymbolName())) {
// This field won't be supported
continue;
}
// Store in the maps
propToGwtSideType.put(propertyName, gwtSideType);
}
}
// Getter methods for EmployeeProxy
for (JavaSymbolName propertyName : propToGwtSideType.keySet()) {
JavaType methodReturnType = propToGwtSideType.get(propertyName);
JavaSymbolName methodName = new JavaSymbolName(""get"" + new JavaSymbolName(propertyName.getSymbolNameCapitalisedFirstLetter()));
List<JavaType> methodParameterTypes = new ArrayList<JavaType>();
List<JavaSymbolName> methodParameterNames = new ArrayList<JavaSymbolName>();
methods.add(new MethodMetadataBuilder(destinationMetadataId, Modifier.ABSTRACT, methodName, methodReturnType, AnnotatedJavaType.convertFromJavaTypes(methodParameterTypes), methodParameterNames, new InvocableMemberBodyBuilder()));
}
// isChanged method
methods.add(new MethodMetadataBuilder(destinationMetadataId, Modifier.ABSTRACT, new JavaSymbolName(""isChanged""), JavaType.BOOLEAN_PRIMITIVE, new InvocableMemberBodyBuilder()));
// Setter methods for EmployeeProxy
for (JavaSymbolName propertyName : propToGwtSideType.keySet()) {
JavaType methodReturnType = JavaType.VOID_PRIMITIVE;
// propToGwtSideType.get(propertyName);
JavaSymbolName methodName = new JavaSymbolName(""set"" + new JavaSymbolName(propertyName.getSymbolNameCapitalisedFirstLetter()));
List<JavaType> methodParameterTypes = Collections.<JavaType> singletonList(propToGwtSideType.get(propertyName));
List<JavaSymbolName> methodParameterNames = Collections.<JavaSymbolName> singletonList(propertyName);
methods.add(new MethodMetadataBuilder(destinationMetadataId, Modifier.ABSTRACT, methodName, methodReturnType, AnnotatedJavaType.convertFromJavaTypes(methodParameterTypes), methodParameterNames, new InvocableMemberBodyBuilder()));
}
ClassOrInterfaceTypeDetailsBuilder typeDetailsBuilder = new ClassOrInterfaceTypeDetailsBuilder(destinationMetadataId, Modifier.PUBLIC, name, PhysicalTypeCategory.INTERFACE);
typeDetailsBuilder.setDeclaredConstructors(constructors);
typeDetailsBuilder.setDeclaredMethods(methods);
typeDetailsBuilder.setExtendsTypes(extendsTypes);
typeDetailsBuilder.setImplementsTypes(implementsTypes);
typeDetailsBuilder.setAnnotations(typeAnnotations);
this.proxy = typeDetailsBuilder.build();
}","private void buildProxy() {
String destinationMetadataId = getDestinationMetadataId(MirrorType.PROXY);
JavaType name = PhysicalTypeIdentifier.getJavaType(destinationMetadataId);
List<AnnotationMetadataBuilder> typeAnnotations = createAnnotations();
// @ProxyFor(Employee.class)
typeAnnotations.add(createAdditionalAnnotation(new JavaType(""com.google.gwt.requestfactory.shared.ProxyFor"")));
List<ConstructorMetadataBuilder> constructors = new ArrayList<ConstructorMetadataBuilder>();
List<MethodMetadataBuilder> methods = new ArrayList<MethodMetadataBuilder>();
List<JavaType> extendsTypes = new ArrayList<JavaType>();
List<JavaType> implementsTypes = new ArrayList<JavaType>();
// attribs.add(new ClassAttributeValue(new JavaSymbolName(""type""), beanInfoMetadata.getJavaBean()));
// attribs.add(new StringAttributeValue(new JavaSymbolName(""token""), governorTypeDetails.getName().getSimpleTypeName()));
// typeAnnotations.add(new DefaultAnnotationMetadata(new JavaType(""com.google.gwt.requestfactory.shared.ServerType""), attribs));
// extends Proxy
extendsTypes.add(new JavaType(""com.google.gwt.requestfactory.shared.EntityProxy""));
// Decide fields we'll be mapping
SortedMap<JavaSymbolName, JavaType> propToGwtSideType = new TreeMap<JavaSymbolName, JavaType>();
if (beanInfoMetadata != null) {
for (MethodMetadata accessor : beanInfoMetadata.getPublicAccessors()) {
JavaSymbolName propertyName = new JavaSymbolName(StringUtils.uncapitalize(BeanInfoMetadata.getPropertyNameForJavaBeanMethod(accessor).getSymbolName()));
JavaType gwtSideType = null;
JavaType returnType = accessor.getReturnType();
PhysicalTypeMetadata ptmd = (PhysicalTypeMetadata) metadataService.get(PhysicalTypeIdentifier.createIdentifier(returnType, Path.SRC_MAIN_JAVA));
boolean isDomainObject = isDomainObject(returnType, ptmd);
if (isDomainObject) {
gwtSideType = getDestinationJavaType(returnType, MirrorType.PROXY);
} else {
gwtSideType = returnType;
if (returnType.isPrimitive()) {
if (returnType.equals(JavaType.BOOLEAN_PRIMITIVE)) {
gwtSideType = JavaType.BOOLEAN_OBJECT;
}
if (returnType.equals(JavaType.INT_PRIMITIVE)) {
gwtSideType = JavaType.INT_OBJECT;
}
if (returnType.equals(JavaType.BYTE_PRIMITIVE)) {
gwtSideType = JavaType.BYTE_OBJECT;
}
if (returnType.equals(JavaType.SHORT_PRIMITIVE)) {
gwtSideType = JavaType.SHORT_OBJECT;
}
if (returnType.equals(JavaType.FLOAT_PRIMITIVE)) {
gwtSideType = JavaType.FLOAT_OBJECT;
}
if (returnType.equals(JavaType.DOUBLE_PRIMITIVE)) {
gwtSideType = JavaType.DOUBLE_OBJECT;
}
if (returnType.equals(JavaType.CHAR_PRIMITIVE)) {
gwtSideType = JavaType.CHAR_OBJECT;
}
if (returnType.equals(JavaType.LONG_PRIMITIVE)) {
gwtSideType = JavaType.LONG_OBJECT;
}
}
}
// Store in the maps
propToGwtSideType.put(propertyName, gwtSideType);
}
}
// Getter methods for EmployeeProxy
for (JavaSymbolName propertyName : propToGwtSideType.keySet()) {
JavaType methodReturnType = propToGwtSideType.get(propertyName);
JavaSymbolName methodName = new JavaSymbolName(""get"" + new JavaSymbolName(propertyName.getSymbolNameCapitalisedFirstLetter()));
List<JavaType> methodParameterTypes = new ArrayList<JavaType>();
List<JavaSymbolName> methodParameterNames = new ArrayList<JavaSymbolName>();
methods.add(new MethodMetadataBuilder(destinationMetadataId, Modifier.ABSTRACT, methodName, methodReturnType, AnnotatedJavaType.convertFromJavaTypes(methodParameterTypes), methodParameterNames, new InvocableMemberBodyBuilder()));
}
// isChanged method
methods.add(new MethodMetadataBuilder(destinationMetadataId, Modifier.ABSTRACT, new JavaSymbolName(""isChanged""), JavaType.BOOLEAN_PRIMITIVE, new InvocableMemberBodyBuilder()));
// Setter methods for EmployeeProxy
for (JavaSymbolName propertyName : propToGwtSideType.keySet()) {
JavaType methodReturnType = JavaType.VOID_PRIMITIVE;
// propToGwtSideType.get(propertyName);
JavaSymbolName methodName = new JavaSymbolName(""set"" + new JavaSymbolName(propertyName.getSymbolNameCapitalisedFirstLetter()));
List<JavaType> methodParameterTypes = Collections.<JavaType> singletonList(propToGwtSideType.get(propertyName));
List<JavaSymbolName> methodParameterNames = Collections.<JavaSymbolName> singletonList(propertyName);
methods.add(new MethodMetadataBuilder(destinationMetadataId, Modifier.ABSTRACT, methodName, methodReturnType, AnnotatedJavaType.convertFromJavaTypes(methodParameterTypes), methodParameterNames, new InvocableMemberBodyBuilder()));
}
ClassOrInterfaceTypeDetailsBuilder typeDetailsBuilder = new ClassOrInterfaceTypeDetailsBuilder(destinationMetadataId, Modifier.PUBLIC, name, PhysicalTypeCategory.INTERFACE);
typeDetailsBuilder.setDeclaredConstructors(constructors);
typeDetailsBuilder.setDeclaredMethods(methods);
typeDetailsBuilder.setExtendsTypes(extendsTypes);
typeDetailsBuilder.setImplementsTypes(implementsTypes);
typeDetailsBuilder.setAnnotations(typeAnnotations);
this.proxy = typeDetailsBuilder.build();
}","private void buildProxy ( ) { 
 String destinationMetadataId = getDestinationMetadataId ( MirrorType . PROXY ) ; 
 JavaType name = PhysicalTypeIdentifier . getJavaType ( destinationMetadataId ) ; 
 List < AnnotationMetadataBuilder > typeAnnotations = createAnnotations ( ) ; 
 // @ ProxyFor ( Employee . class ) 
 typeAnnotations . add ( createAdditionalAnnotation ( new JavaType ( ""com.google.gwt.requestfactory.shared.ProxyFor"" ) ) ) ; 
 List < ConstructorMetadataBuilder > constructors = new ArrayList < ConstructorMetadataBuilder > ( ) ; 
 List < MethodMetadataBuilder > methods = new ArrayList < MethodMetadataBuilder > ( ) ; 
 List < JavaType > extendsTypes = new ArrayList < JavaType > ( ) ; 
 List < JavaType > implementsTypes = new ArrayList < JavaType > ( ) ; 
 // attribs . add ( new ClassAttributeValue ( new JavaSymbolName ( ""type"" ) , beanInfoMetadata . getJavaBean ( ) ) ) ; 
 // attribs . add ( new StringAttributeValue ( new JavaSymbolName ( ""token"" ) , governorTypeDetails . getName ( ) . getSimpleTypeName ( ) ) ) ; 
 // typeAnnotations . add ( new DefaultAnnotationMetadata ( new JavaType ( ""com.google.gwt.requestfactory.shared.ServerType"" ) , attribs ) ) ; 
 // extends Proxy 
 extendsTypes . add ( new JavaType ( ""com.google.gwt.requestfactory.shared.EntityProxy"" ) ) ; 
 // Decide fields we ' ll be mapping 
 SortedMap < JavaSymbolName , JavaType > propToGwtSideType = new TreeMap < JavaSymbolName , JavaType > ( ) ; 
 if ( beanInfoMetadata != null ) { 
 for ( MethodMetadata accessor : beanInfoMetadata . getPublicAccessors ( ) ) { 
 JavaSymbolName propertyName = new JavaSymbolName ( StringUtils . uncapitalize ( BeanInfoMetadata . getPropertyNameForJavaBeanMethod ( accessor ) . getSymbolName ( ) ) ) ; 
 JavaType gwtSideType = null ; 
 JavaType returnType = accessor . getReturnType ( ) ; 
 PhysicalTypeMetadata ptmd = ( PhysicalTypeMetadata ) metadataService . get ( PhysicalTypeIdentifier . createIdentifier ( returnType , Path . SRC_MAIN_JAVA ) ) ; 
 boolean isDomainObject = isDomainObject ( returnType , ptmd ) ; 
 if ( isDomainObject ) { 
 gwtSideType = getDestinationJavaType ( returnType , MirrorType . PROXY ) ; 
 } else { 
 gwtSideType = returnType ; 
 if ( returnType . isPrimitive ( ) ) { 
 if ( returnType . equals ( JavaType . BOOLEAN_PRIMITIVE ) ) { 
 gwtSideType = JavaType . BOOLEAN_OBJECT ; 
 } 
 if ( returnType . equals ( JavaType . INT_PRIMITIVE ) ) { 
 gwtSideType = JavaType . INT_OBJECT ; 
 } 
 if ( returnType . equals ( JavaType . DOUBLE_PRIMITIVE ) ) { 
 gwtSideType = JavaType . DOUBLE_OBJECT ; 
 } 
 if ( returnType . equals ( JavaType . LONG_PRIMITIVE ) ) { 
 gwtSideType = JavaType . LONG_OBJECT ; 
 } 
 } 
 // Handle the identifier special case 
 if ( idPropertyName . equals ( propertyName ) & & idLongOnServerSide ) { 
 gwtSideType = JavaType . LONG_OBJECT ; 
 } 
 // Handle the version special case 
 if ( versionPropertyName . equals ( propertyName ) & & versionIntegerOnServerSide ) { 
 gwtSideType = JavaType . INT_OBJECT ; 
 } 
 // TODO : ( cromwellian ) HACK ! handle foreign - id refs , we assume java . lang . Long is an id 
 if ( gwtSideType . getFullyQualifiedTypeName ( ) . equals ( ""java.lang.Long"" ) & & idLongOnServerSide ) { 
 gwtSideType = JavaType . LONG_OBJECT ; 
 } 
 } 
 if ( ""id"" . equals ( propertyName . getSymbolName ( ) ) | | ""version"" . equals ( propertyName . getSymbolName ( ) ) ) { 
 // This field won ' t be supported 
 continue ; 
 } 
 // Store in the maps 
 propToGwtSideType . put ( propertyName , gwtSideType ) ; 
 } 
 } 
 // Getter methods for EmployeeProxy 
 for ( JavaSymbolName propertyName : propToGwtSideType . keySet ( ) ) { 
 JavaType methodReturnType = propToGwtSideType . get ( propertyName ) ; 
 JavaSymbolName methodName = new JavaSymbolName ( ""get"" + new JavaSymbolName ( propertyName . getSymbolNameCapitalisedFirstLetter ( ) ) ) ; 
 List < JavaType > methodParameterTypes = new ArrayList < JavaType > ( ) ; 
 List < JavaSymbolName > methodParameterNames = new ArrayList < JavaSymbolName > ( ) ; 
 methods . add ( new MethodMetadataBuilder ( destinationMetadataId , Modifier . ABSTRACT , methodName , methodReturnType , AnnotatedJavaType . convertFromJavaTypes ( methodParameterTypes ) , methodParameterNames , new InvocableMemberBodyBuilder ( ) ) ) ; 
 } 
 // isChanged method 
 methods . add ( new MethodMetadataBuilder ( destinationMetadataId , Modifier . ABSTRACT , new JavaSymbolName ( ""isChanged"" ) , JavaType . BOOLEAN_PRIMITIVE , new InvocableMemberBodyBuilder ( ) ) ) ; 
 // Setter methods for EmployeeProxy 
 for ( JavaSymbolName propertyName : propToGwtSideType . keySet ( ) ) { 
 JavaType methodReturnType = JavaType . VOID_PRIMITIVE ; 
 // propToGwtSideType . get ( propertyName ) ; 
 JavaSymbolName methodName = new JavaSymbolName ( ""set"" + new JavaSymbolName ( propertyName . getSymbolNameCapitalisedFirstLetter ( ) ) ) ; 
 List < JavaType > methodParameterTypes = Collections . < JavaType > singletonList ( propToGwtSideType . get ( propertyName ) ) ; 
 List < JavaSymbolName > methodParameterNames = Collections . < JavaSymbolName > singletonList ( propertyName ) ; 
 methods . add ( new MethodMetadataBuilder ( destinationMetadataId , Modifier . ABSTRACT , methodName , methodReturnType , AnnotatedJavaType . convertFromJavaTypes ( methodParameterTypes ) , methodParameterNames , new InvocableMemberBodyBuilder ( ) ) ) ; 
 } 
 ClassOrInterfaceTypeDetailsBuilder typeDetailsBuilder = new ClassOrInterfaceTypeDetailsBuilder ( destinationMetadataId , Modifier . PUBLIC , name , PhysicalTypeCategory . INTERFACE ) ; 
 typeDetailsBuilder . setDeclaredConstructors ( constructors ) ; 
 typeDetailsBuilder . setDeclaredMethods ( methods ) ; 
 typeDetailsBuilder . setExtendsTypes ( extendsTypes ) ; 
 typeDetailsBuilder . setImplementsTypes ( implementsTypes ) ; 
 typeDetailsBuilder . setAnnotations ( typeAnnotations ) ; 
 this . proxy = typeDetailsBuilder . build ( ) ; 
 }  ","private void buildProxy ( ) { 
 String destinationMetadataId = getDestinationMetadataId ( MirrorType . PROXY ) ; 
 JavaType name = PhysicalTypeIdentifier . getJavaType ( destinationMetadataId ) ; 
 List < AnnotationMetadataBuilder > typeAnnotations = createAnnotations ( ) ; 
 // @ ProxyFor ( Employee . class ) 
 typeAnnotations . add ( createAdditionalAnnotation ( new JavaType ( ""com.google.gwt.requestfactory.shared.ProxyFor"" ) ) ) ; 
 List < ConstructorMetadataBuilder > constructors = new ArrayList < ConstructorMetadataBuilder > ( ) ; 
 List < MethodMetadataBuilder > methods = new ArrayList < MethodMetadataBuilder > ( ) ; 
 List < JavaType > extendsTypes = new ArrayList < JavaType > ( ) ; 
 List < JavaType > implementsTypes = new ArrayList < JavaType > ( ) ; 
 // attribs . add ( new ClassAttributeValue ( new JavaSymbolName ( ""type"" ) , beanInfoMetadata . getJavaBean ( ) ) ) ; 
 // attribs . add ( new StringAttributeValue ( new JavaSymbolName ( ""token"" ) , governorTypeDetails . getName ( ) . getSimpleTypeName ( ) ) ) ; 
 // typeAnnotations . add ( new DefaultAnnotationMetadata ( new JavaType ( ""com.google.gwt.requestfactory.shared.ServerType"" ) , attribs ) ) ; 
 // extends Proxy 
 extendsTypes . add ( new JavaType ( ""com.google.gwt.requestfactory.shared.EntityProxy"" ) ) ; 
 // Decide fields we ' ll be mapping 
 SortedMap < JavaSymbolName , JavaType > propToGwtSideType = new TreeMap < JavaSymbolName , JavaType > ( ) ; 
 if ( beanInfoMetadata != null ) { 
 for ( MethodMetadata accessor : beanInfoMetadata . getPublicAccessors ( ) ) { 
 JavaSymbolName propertyName = new JavaSymbolName ( StringUtils . uncapitalize ( BeanInfoMetadata . getPropertyNameForJavaBeanMethod ( accessor ) . getSymbolName ( ) ) ) ; 
 JavaType gwtSideType = null ; 
 JavaType returnType = accessor . getReturnType ( ) ; 
 PhysicalTypeMetadata ptmd = ( PhysicalTypeMetadata ) metadataService . get ( PhysicalTypeIdentifier . createIdentifier ( returnType , Path . SRC_MAIN_JAVA ) ) ; 
 boolean isDomainObject = isDomainObject ( returnType , ptmd ) ; 
 if ( isDomainObject ) { 
 gwtSideType = getDestinationJavaType ( returnType , MirrorType . PROXY ) ; 
 } else { 
 gwtSideType = returnType ; 
 if ( returnType . isPrimitive ( ) ) { 
 if ( returnType . equals ( JavaType . BOOLEAN_PRIMITIVE ) ) { 
 gwtSideType = JavaType . BOOLEAN_OBJECT ; 
 } 
 if ( returnType . equals ( JavaType . INT_PRIMITIVE ) ) { 
 gwtSideType = JavaType . INT_OBJECT ; 
 } 
 if ( returnType . equals ( JavaType . BYTE_PRIMITIVE ) ) { 
 gwtSideType = JavaType . BYTE_OBJECT ; 
 } 
 if ( returnType . equals ( JavaType . SHORT_PRIMITIVE ) ) { 
 gwtSideType = JavaType . SHORT_OBJECT ; 
 } 
 if ( returnType . equals ( JavaType . FLOAT_PRIMITIVE ) ) { 
 gwtSideType = JavaType . FLOAT_OBJECT ; 
 } 
 if ( returnType . equals ( JavaType . DOUBLE_PRIMITIVE ) ) { 
 gwtSideType = JavaType . DOUBLE_OBJECT ; 
 } 
 if ( returnType . equals ( JavaType . CHAR_PRIMITIVE ) ) { 
 gwtSideType = JavaType . CHAR_OBJECT ; 
 } 
 if ( returnType . equals ( JavaType . LONG_PRIMITIVE ) ) { 
 gwtSideType = JavaType . LONG_OBJECT ; 
 } 
 } 
 } 
 // Store in the maps 
 propToGwtSideType . put ( propertyName , gwtSideType ) ; 
 } 
 } 
 // Getter methods for EmployeeProxy 
 for ( JavaSymbolName propertyName : propToGwtSideType . keySet ( ) ) { 
 JavaType methodReturnType = propToGwtSideType . get ( propertyName ) ; 
 JavaSymbolName methodName = new JavaSymbolName ( ""get"" + new JavaSymbolName ( propertyName . getSymbolNameCapitalisedFirstLetter ( ) ) ) ; 
 List < JavaType > methodParameterTypes = new ArrayList < JavaType > ( ) ; 
 List < JavaSymbolName > methodParameterNames = new ArrayList < JavaSymbolName > ( ) ; 
 methods . add ( new MethodMetadataBuilder ( destinationMetadataId , Modifier . ABSTRACT , methodName , methodReturnType , AnnotatedJavaType . convertFromJavaTypes ( methodParameterTypes ) , methodParameterNames , new InvocableMemberBodyBuilder ( ) ) ) ; 
 } 
 // isChanged method 
 methods . add ( new MethodMetadataBuilder ( destinationMetadataId , Modifier . ABSTRACT , new JavaSymbolName ( ""isChanged"" ) , JavaType . BOOLEAN_PRIMITIVE , new InvocableMemberBodyBuilder ( ) ) ) ; 
 // Setter methods for EmployeeProxy 
 for ( JavaSymbolName propertyName : propToGwtSideType . keySet ( ) ) { 
 JavaType methodReturnType = JavaType . VOID_PRIMITIVE ; 
 // propToGwtSideType . get ( propertyName ) ; 
 JavaSymbolName methodName = new JavaSymbolName ( ""set"" + new JavaSymbolName ( propertyName . getSymbolNameCapitalisedFirstLetter ( ) ) ) ; 
 List < JavaType > methodParameterTypes = Collections . < JavaType > singletonList ( propToGwtSideType . get ( propertyName ) ) ; 
 List < JavaSymbolName > methodParameterNames = Collections . < JavaSymbolName > singletonList ( propertyName ) ; 
 methods . add ( new MethodMetadataBuilder ( destinationMetadataId , Modifier . ABSTRACT , methodName , methodReturnType , AnnotatedJavaType . convertFromJavaTypes ( methodParameterTypes ) , methodParameterNames , new InvocableMemberBodyBuilder ( ) ) ) ; 
 } 
 ClassOrInterfaceTypeDetailsBuilder typeDetailsBuilder = new ClassOrInterfaceTypeDetailsBuilder ( destinationMetadataId , Modifier . PUBLIC , name , PhysicalTypeCategory . INTERFACE ) ; 
 typeDetailsBuilder . setDeclaredConstructors ( constructors ) ; 
 typeDetailsBuilder . setDeclaredMethods ( methods ) ; 
 typeDetailsBuilder . setExtendsTypes ( extendsTypes ) ; 
 typeDetailsBuilder . setImplementsTypes ( implementsTypes ) ; 
 typeDetailsBuilder . setAnnotations ( typeAnnotations ) ; 
 this . proxy = typeDetailsBuilder . build ( ) ; 
 }  ",2010-05-26 12:17:00 +1000,2010/9/24 1:52,2,0.9781780087696333
1866,388,https://www.github.com/jenkins-infra/update-center2,initialize(),DESIGN,42,42,42,42,TODO remove use of json-lib,https://www.github.com/jenkins-infra/update-center2/commit/d053b58d,https://www.github.com/jenkins-infra/update-center2/commit/d467159b5359376185ddcacf0fc5a4e87d880bc6,src/main/java/io/jenkins/update_center/Popularities.java,"private static void initialize() throws IOException {
Map<String, Integer> popularities = new HashMap<>();
Request request = new Request.Builder().url(JSON_URL).get().build();
String bodyString;
try (final ResponseBody body = new OkHttpClient().newCall(request).execute().body()){
Objects.requireNonNull(body);
bodyString = body.string();
}
// TODO remove use of json-lib
JSONObject jsonResponse = JSONObject.fromObject(bodyString);
if (!jsonResponse.has(""plugins"")) {
throw new IllegalArgumentException(""Specified popularity URL '"" + JSON_URL + ""' does not contain a JSON object 'plugins'"");
}
final JSONObject plugins = jsonResponse.getJSONObject(""plugins"");
for (Iterator it = plugins.keys(); it.hasNext(); ) {
String pluginId = it.next().toString();
final int popularity = plugins.getInt(pluginId);
popularities.put(pluginId, popularity);
}
instance = new Popularities(popularities);
}","private static void initialize() throws IOException {
Request request = new Request.Builder().url(JSON_URL).get().build();
String bodyString;
try (final ResponseBody body = new OkHttpClient().newCall(request).execute().body()){
Objects.requireNonNull(body);
bodyString = body.string();
}
JsonResponse response = JSON.parseObject(bodyString, JsonResponse.class);
if (response.plugins == null) {
throw new IllegalArgumentException(""Specified popularity URL '"" + JSON_URL + ""' does not contain a JSON object 'plugins'"");
}
Map<String, Integer> popularities = response.plugins.keySet().stream().collect(Collectors.toMap(Function.identity(), value -> Integer.valueOf(response.plugins.get(value))));
instance = new Popularities(popularities);
}","private static void initialize ( ) throws IOException { 
 Map < String , Integer > popularities = new HashMap < > ( ) ; 
 Request request = new Request . Builder ( ) . url ( JSON_URL ) . get ( ) . build ( ) ; 
 String bodyString ; 
 try ( final ResponseBody body = new OkHttpClient ( ) . newCall ( request ) . execute ( ) . body ( ) ) { 
 Objects . requireNonNull ( body ) ; 
 bodyString = body . string ( ) ; 
 } 
 // TODO remove use of json - lib 
 JSONObject jsonResponse = JSONObject . fromObject ( bodyString ) ; 
 if ( ! jsonResponse . has ( ""plugins"" ) ) { 
 throw new IllegalArgumentException ( ""Specified popularity URL '"" + JSON_URL + ""' does not contain a JSON object 'plugins'"" ) ; 
 } 
 final JSONObject plugins = jsonResponse . getJSONObject ( ""plugins"" ) ; 
 for ( Iterator it = plugins . keys ( ) ; it . hasNext ( ) ; ) { 
 String pluginId = it . next ( ) . toString ( ) ; 
 final int popularity = plugins . getInt ( pluginId ) ; 
 popularities . put ( pluginId , popularity ) ; 
 } 
 instance = new Popularities ( popularities ) ; 
 }  ","private static void initialize ( ) throws IOException { 
 Request request = new Request . Builder ( ) . url ( JSON_URL ) . get ( ) . build ( ) ; 
 String bodyString ; 
 try ( final ResponseBody body = new OkHttpClient ( ) . newCall ( request ) . execute ( ) . body ( ) ) { 
 Objects . requireNonNull ( body ) ; 
 bodyString = body . string ( ) ; 
 } 
 JsonResponse response = JSON . parseObject ( bodyString , JsonResponse . class ) ; 
 if ( response . plugins == null ) { 
 throw new IllegalArgumentException ( ""Specified popularity URL '"" + JSON_URL + ""' does not contain a JSON object 'plugins'"" ) ; 
 } 
 Map < String , Integer > popularities = response . plugins . keySet ( ) . stream ( ) . collect ( Collectors . toMap ( Function . identity ( ) , value -> Integer . valueOf ( response . plugins . get ( value ) ) ) ) ; 
 instance = new Popularities ( popularities ) ; 
 }  ",2020-05-23 21:17:08 +0200,2020-06-26 20:31:12 +0200,6,0.7648449293188627
3480,173,https://www.github.com/bcdev/calvalus2,initWidget(),NOT_DESIGN,75,75,75,75,todo - use interaction.getIcon() images here (nf),https://www.github.com/bcdev/calvalus2/commit/bfc71c9d5d,https://www.github.com/bcdev/calvalus2/commit/def56f2c2d00cafffe622d8f8fed9c38f2978cf3,calvalus-portal/src/main/java/com/bc/calvalus/portal/client/map/RegionMapToolbar.java,"private void initWidget() {
interactions = new HashMap<ToggleButton, MapInteraction>();
interactionButtons = new HashMap<MapInteraction, ToggleButton>();
ClickHandler interactionClickHandler = new ClickHandler() {
            @Override
public void onClick(ClickEvent clickEvent) {
ToggleButton selectedToggleButton = (ToggleButton) clickEvent.getSource();
MapInteraction interaction = interactions.get(selectedToggleButton);
regionMap.setCurrentInteraction(interaction);
for (ToggleButton interactorButton : interactions.keySet()) {
if (selectedToggleButton != interactorButton && interactorButton.isDown()) {
interactorButton.setDown(false);
}
}
}
        };
HorizontalPanel buttonPanel = new HorizontalPanel();
buttonPanel.setSpacing(2);
for (final MapAction action : regionMap.getActions()) {
if (action instanceof MapAction.Separator) {
buttonPanel.add(new HTML(""&nbsp;""));
} else if (action instanceof MapInteraction) {
MapInteraction interaction = (MapInteraction) action;
// todo - use interaction.getIcon() images here (nf)
ToggleButton toggleButton = new ToggleButton(interaction.getLabel(), interactionClickHandler);
toggleButton.setTitle(interaction.getDescription());
interactions.put(toggleButton, interaction);
interactionButtons.put(interaction, toggleButton);
if (regionMap.getCurrentInteraction() == null) {
regionMap.setCurrentInteraction(interaction);
toggleButton.setDown(true);
}
buttonPanel.add(toggleButton);
} else {
// todo - use interaction.getIcon() images here (nf)
PushButton pushButton = new PushButton(action.getLabel(), new ClickHandler() {
                    @Override
public void onClick(ClickEvent clickEvent) {
action.run(regionMap);
}
                });
pushButton.setTitle(action.getDescription());
buttonPanel.add(pushButton);
}
}
this.widget = buttonPanel;
}","private void initWidget() {
interactions = new HashMap<ToggleButton, MapInteraction>();
interactionButtons = new HashMap<MapInteraction, ToggleButton>();
ClickHandler interactionClickHandler = new ClickHandler() {
            @Override
public void onClick(ClickEvent clickEvent) {
ToggleButton selectedToggleButton = (ToggleButton) clickEvent.getSource();
MapInteraction interaction = interactions.get(selectedToggleButton);
regionMap.setCurrentInteraction(interaction);
for (ToggleButton interactorButton : interactions.keySet()) {
if (selectedToggleButton != interactorButton && interactorButton.isDown()) {
interactorButton.setDown(false);
}
}
}
        };
final VerticalPanel buttonPanel = new VerticalPanel();
buttonPanel.setSpacing(2);
HorizontalPanel buttonPanel1 = new HorizontalPanel();
HorizontalPanel buttonPanel2 = new HorizontalPanel();
buttonPanel.add(buttonPanel1);
buttonPanel.add(buttonPanel2);
buttonPanel1.setSpacing(2);
buttonPanel2.setSpacing(2);
HorizontalPanel currentPanel = buttonPanel1;
for (final MapAction action : regionMap.getActions()) {
if (action instanceof MapAction.Separator) {
//buttonPanel.add(new HTML(""&nbsp;""));
currentPanel = buttonPanel2;
} else if (action instanceof MapInteraction) {
MapInteraction interaction = (MapInteraction) action;
ToggleButton toggleButton;
if (interaction.getImage() != null) {
toggleButton = new ToggleButton(interaction.getImage(), interactionClickHandler);
} else {
toggleButton = new ToggleButton(interaction.getLabel(), interactionClickHandler);
}
toggleButton.setTitle(interaction.getDescription());
interactions.put(toggleButton, interaction);
interactionButtons.put(interaction, toggleButton);
if (regionMap.getCurrentInteraction() == null) {
regionMap.setCurrentInteraction(interaction);
toggleButton.setDown(true);
}
currentPanel.add(toggleButton);
} else {
PushButton pushButton;
if (action.getImage() != null) {
pushButton = new PushButton(action.getImage(), new ClickHandler() {
                        @Override
public void onClick(ClickEvent clickEvent) {
action.run(regionMap);
}
                    });
} else {
pushButton = new PushButton(action.getLabel(), new ClickHandler() {
                        @Override
public void onClick(ClickEvent clickEvent) {
action.run(regionMap);
}
                    });
}
pushButton.setTitle(action.getDescription());
currentPanel.add(pushButton);
}
}
this.widget = buttonPanel;
}","private void initWidget ( ) { 
 interactions = new HashMap < ToggleButton , MapInteraction > ( ) ; 
 interactionButtons = new HashMap < MapInteraction , ToggleButton > ( ) ; 
 ClickHandler interactionClickHandler = new ClickHandler ( ) { 
 @ Override 
 public void onClick ( ClickEvent clickEvent ) { 
 ToggleButton selectedToggleButton = ( ToggleButton ) clickEvent . getSource ( ) ; 
 MapInteraction interaction = interactions . get ( selectedToggleButton ) ; 
 regionMap . setCurrentInteraction ( interaction ) ; 
 for ( ToggleButton interactorButton : interactions . keySet ( ) ) { 
 if ( selectedToggleButton != interactorButton & & interactorButton . isDown ( ) ) { 
 interactorButton . setDown ( false ) ; 
 } 
 } 
 } 
 } ; 
 HorizontalPanel buttonPanel = new HorizontalPanel ( ) ; 
 buttonPanel . setSpacing ( 2 ) ; 
 for ( final MapAction action : regionMap . getActions ( ) ) { 
 if ( action instanceof MapAction . Separator ) { 
 buttonPanel . add ( new HTML ( ""&nbsp;"" ) ) ; 
 } else if ( action instanceof MapInteraction ) { 
 MapInteraction interaction = ( MapInteraction ) action ; 
 // todo - use interaction . getIcon ( ) images here ( nf ) 
 ToggleButton toggleButton = new ToggleButton ( interaction . getLabel ( ) , interactionClickHandler ) ; 
 toggleButton . setTitle ( interaction . getDescription ( ) ) ; 
 interactions . put ( toggleButton , interaction ) ; 
 interactionButtons . put ( interaction , toggleButton ) ; 
 if ( regionMap . getCurrentInteraction ( ) == null ) { 
 regionMap . setCurrentInteraction ( interaction ) ; 
 toggleButton . setDown ( true ) ; 
 } 
 buttonPanel . add ( toggleButton ) ; 
 } else { 
 // todo - use interaction . getIcon ( ) images here ( nf ) 
 PushButton pushButton = new PushButton ( action . getLabel ( ) , new ClickHandler ( ) { 
 @ Override 
 public void onClick ( ClickEvent clickEvent ) { 
 action . run ( regionMap ) ; 
 } 
 } ) ; 
 pushButton . setTitle ( action . getDescription ( ) ) ; 
 buttonPanel . add ( pushButton ) ; 
 } 
 } 
 this . widget = buttonPanel ; 
 }  ","private void initWidget ( ) { 
 interactions = new HashMap < ToggleButton , MapInteraction > ( ) ; 
 interactionButtons = new HashMap < MapInteraction , ToggleButton > ( ) ; 
 ClickHandler interactionClickHandler = new ClickHandler ( ) { 
 @ Override 
 public void onClick ( ClickEvent clickEvent ) { 
 ToggleButton selectedToggleButton = ( ToggleButton ) clickEvent . getSource ( ) ; 
 MapInteraction interaction = interactions . get ( selectedToggleButton ) ; 
 regionMap . setCurrentInteraction ( interaction ) ; 
 for ( ToggleButton interactorButton : interactions . keySet ( ) ) { 
 if ( selectedToggleButton != interactorButton & & interactorButton . isDown ( ) ) { 
 interactorButton . setDown ( false ) ; 
 } 
 } 
 } 
 } ; 
 final VerticalPanel buttonPanel = new VerticalPanel ( ) ; 
 buttonPanel . setSpacing ( 2 ) ; 
 HorizontalPanel buttonPanel1 = new HorizontalPanel ( ) ; 
 HorizontalPanel buttonPanel2 = new HorizontalPanel ( ) ; 
 buttonPanel . add ( buttonPanel1 ) ; 
 buttonPanel . add ( buttonPanel2 ) ; 
 buttonPanel1 . setSpacing ( 2 ) ; 
 buttonPanel2 . setSpacing ( 2 ) ; 
 HorizontalPanel currentPanel = buttonPanel1 ; 
 for ( final MapAction action : regionMap . getActions ( ) ) { 
 if ( action instanceof MapAction . Separator ) { 
 // buttonPanel . add ( new HTML ( ""&nbsp;"" ) ) ; 
 currentPanel = buttonPanel2 ; 
 } else if ( action instanceof MapInteraction ) { 
 MapInteraction interaction = ( MapInteraction ) action ; 
 ToggleButton toggleButton ; 
 if ( interaction . getImage ( ) != null ) { 
 toggleButton = new ToggleButton ( interaction . getImage ( ) , interactionClickHandler ) ; 
 } else { 
 toggleButton = new ToggleButton ( interaction . getLabel ( ) , interactionClickHandler ) ; 
 } 
 toggleButton . setTitle ( interaction . getDescription ( ) ) ; 
 interactions . put ( toggleButton , interaction ) ; 
 interactionButtons . put ( interaction , toggleButton ) ; 
 if ( regionMap . getCurrentInteraction ( ) == null ) { 
 regionMap . setCurrentInteraction ( interaction ) ; 
 toggleButton . setDown ( true ) ; 
 } 
 currentPanel . add ( toggleButton ) ; 
 } else { 
 PushButton pushButton ; 
 if ( action . getImage ( ) != null ) { 
 pushButton = new PushButton ( action . getImage ( ) , new ClickHandler ( ) { 
 @ Override 
 public void onClick ( ClickEvent clickEvent ) { 
 action . run ( regionMap ) ; 
 } 
 } ) ; 
 } else { 
 pushButton = new PushButton ( action . getLabel ( ) , new ClickHandler ( ) { 
 @ Override 
 public void onClick ( ClickEvent clickEvent ) { 
 action . run ( regionMap ) ; 
 } 
 } ) ; 
 } 
 pushButton . setTitle ( action . getDescription ( ) ) ; 
 currentPanel . add ( pushButton ) ; 
 } 
 } 
 this . widget = buttonPanel ; 
 }  ",2011-06-22 18:38:37 +0200,2014-04-11 20:28:21 +0200,7,0.9226831349129239
3227,121,https://www.github.com/erlang/erlide_eclipse,"addErrorMarkers(IResource, OtpErlangList)",,98,98,98,98,TODO the error is in a file not in the project,https://www.github.com/erlang/erlide_eclipse/commit/6f74e318b1,https://www.github.com/erlang/erlide_eclipse/commit/a6eff2bb360b12c397ccc16df0276b7a4a0acfa8,org.erlide.core/src/org/erlide/core/builder/internal/MarkerHelper.java,"public static void addErrorMarkers(final IResource resource,
			final OtpErlangList errorList) {
for (final OtpErlangObject odata : errorList.elements()) {
try {
final OtpErlangTuple data = (OtpErlangTuple) odata;
String msg = ErlUtils.asString(data.elementAt(2));
if (msg.length() > 1000) {
msg = msg.substring(0, 1000) + ""......"";
}
final String fileName = (String) TypeConverter.erlang2java(data
.elementAt(1), String.class);
IResource res = resource;
if (!BuilderUtils.comparePath(
						resource.getLocation().toString(), fileName)) {
res = BuilderUtils.findResource(resource.getProject(),
							fileName);
if (res == null) {
// TODO the error is in a file not in the project
// try {
// final String includeFile = ErlModelUtils
// .findIncludeFile(project, res.getName(),
// fExternalIncludes, pathVars);
// if (includeFile != null) {
// r = EditorUtility.openExternal(includeFile);
// }
// } catch (final Exception e) {
// ErlLogger.warn(e);
// }
res = resource;
}
}
int line = 0;
if (data.elementAt(0) instanceof OtpErlangLong) {
try {
line = ((OtpErlangLong) data.elementAt(0)).intValue();
} catch (final OtpErlangRangeException e) {
}
}
int sev = IMarker.SEVERITY_INFO;
try {
switch (((OtpErlangLong) data.elementAt(3)).intValue()) {
case 0:
sev = IMarker.SEVERITY_ERROR;
break;
case 1:
sev = IMarker.SEVERITY_WARNING;
break;
default:
sev = IMarker.SEVERITY_INFO;
break;
}
} catch (final OtpErlangRangeException e) {
}
addMarker(res, resource, msg, line, sev, """");
} catch (final Exception e) {
ErlLogger.warn(e);
ErlLogger.warn(""got: %s"", odata);
}
}
}","public static void addErrorMarkers(final IResource resource,
			final OtpErlangList errorList) {
for (final OtpErlangObject odata : errorList.elements()) {
try {
final OtpErlangTuple data = (OtpErlangTuple) odata;
String msg = ErlUtils.asString(data.elementAt(2));
if (msg.length() > 1000) {
msg = msg.substring(0, 1000) + ""......"";
}
final String fileName = (String) TypeConverter.erlang2java(data
.elementAt(1), String.class);
IResource res = resource;
if (!BuilderUtils.samePath(resource.getLocation().toString(),
						fileName)) {
res = BuilderUtils.findResourceByLocation(resource
.getProject(), fileName);
if (res == null) {
try {
final String includeFile = ModelUtils
.findIncludeFile(project, res.getName(),
											fExternalIncludes, pathVars);
if (includeFile != null) {
r = EditorUtility.openExternal(includeFile);
}
} catch (final Exception e) {
ErlLogger.warn(e);
}
res = resource;
}
}
int line = 0;
if (data.elementAt(0) instanceof OtpErlangLong) {
try {
line = ((OtpErlangLong) data.elementAt(0)).intValue();
} catch (final OtpErlangRangeException e) {
}
}
int sev = IMarker.SEVERITY_INFO;
try {
switch (((OtpErlangLong) data.elementAt(3)).intValue()) {
case 0:
sev = IMarker.SEVERITY_ERROR;
break;
case 1:
sev = IMarker.SEVERITY_WARNING;
break;
default:
sev = IMarker.SEVERITY_INFO;
break;
}
} catch (final OtpErlangRangeException e) {
}
addMarker(res, resource, msg, line, sev, """");
} catch (final Exception e) {
ErlLogger.warn(e);
ErlLogger.warn(""got: %s"", odata);
}
}
}","public static void addErrorMarkers ( final IResource resource , 
 final OtpErlangList errorList ) { 
 for ( final OtpErlangObject odata : errorList . elements ( ) ) { 
 try { 
 final OtpErlangTuple data = ( OtpErlangTuple ) odata ; 
 String msg = ErlUtils . asString ( data . elementAt ( 2 ) ) ; 
 if ( msg . length ( ) > 1000 ) { 
 msg = msg . substring ( 0 , 1000 ) + ""......"" ; 
 } 
 final String fileName = ( String ) TypeConverter . erlang2java ( data 
 . elementAt ( 1 ) , String . class ) ; 
 IResource res = resource ; 
 if ( ! BuilderUtils . comparePath ( 
 resource . getLocation ( ) . toString ( ) , fileName ) ) { 
 res = BuilderUtils . findResource ( resource . getProject ( ) , 
 fileName ) ; 
 if ( res == null ) { 
 // TODO the error is in a file not in the project 
 // try { 
 // final String includeFile = ErlModelUtils 
 // . findIncludeFile ( project , res . getName ( ) , 
 // fExternalIncludes , pathVars ) ; 
 // if ( includeFile != null ) { 
 // r = EditorUtility . openExternal ( includeFile ) ; 
 // } 
 // } catch ( final Exception e ) { 
 // ErlLogger . warn ( e ) ; 
 // } 
 res = resource ; 
 } 
 } 
 int line = 0 ; 
 if ( data . elementAt ( 0 ) instanceof OtpErlangLong ) { 
 try { 
 line = ( ( OtpErlangLong ) data . elementAt ( 0 ) ) . intValue ( ) ; 
 } catch ( final OtpErlangRangeException e ) { 
 } 
 } 
 int sev = IMarker . SEVERITY_INFO ; 
 try { 
 switch ( ( ( OtpErlangLong ) data . elementAt ( 3 ) ) . intValue ( ) ) { 
 case 0 : 
 sev = IMarker . SEVERITY_ERROR ; 
 break ; 
 case 1 : 
 sev = IMarker . SEVERITY_WARNING ; 
 break ; 
 default : 
 sev = IMarker . SEVERITY_INFO ; 
 break ; 
 } 
 } catch ( final OtpErlangRangeException e ) { 
 } 
 addMarker ( res , resource , msg , line , sev , """" ) ; 
 } catch ( final Exception e ) { 
 ErlLogger . warn ( e ) ; 
 ErlLogger . warn ( ""got: %s"" , odata ) ; 
 } 
 } 
 }  ","public static void addErrorMarkers ( final IResource resource , 
 final OtpErlangList errorList ) { 
 for ( final OtpErlangObject odata : errorList . elements ( ) ) { 
 try { 
 final OtpErlangTuple data = ( OtpErlangTuple ) odata ; 
 String msg = ErlUtils . asString ( data . elementAt ( 2 ) ) ; 
 if ( msg . length ( ) > 1000 ) { 
 msg = msg . substring ( 0 , 1000 ) + ""......"" ; 
 } 
 final String fileName = ( String ) TypeConverter . erlang2java ( data 
 . elementAt ( 1 ) , String . class ) ; 
 IResource res = resource ; 
 if ( ! BuilderUtils . samePath ( resource . getLocation ( ) . toString ( ) , 
 fileName ) ) { 
 res = BuilderUtils . findResourceByLocation ( resource 
 . getProject ( ) , fileName ) ; 
 if ( res == null ) { 
 try { 
 final String includeFile = ModelUtils 
 . findIncludeFile ( project , res . getName ( ) , 
 fExternalIncludes , pathVars ) ; 
 if ( includeFile != null ) { 
 r = EditorUtility . openExternal ( includeFile ) ; 
 } 
 } catch ( final Exception e ) { 
 ErlLogger . warn ( e ) ; 
 } 
 res = resource ; 
 } 
 } 
 int line = 0 ; 
 if ( data . elementAt ( 0 ) instanceof OtpErlangLong ) { 
 try { 
 line = ( ( OtpErlangLong ) data . elementAt ( 0 ) ) . intValue ( ) ; 
 } catch ( final OtpErlangRangeException e ) { 
 } 
 } 
 int sev = IMarker . SEVERITY_INFO ; 
 try { 
 switch ( ( ( OtpErlangLong ) data . elementAt ( 3 ) ) . intValue ( ) ) { 
 case 0 : 
 sev = IMarker . SEVERITY_ERROR ; 
 break ; 
 case 1 : 
 sev = IMarker . SEVERITY_WARNING ; 
 break ; 
 default : 
 sev = IMarker . SEVERITY_INFO ; 
 break ; 
 } 
 } catch ( final OtpErlangRangeException e ) { 
 } 
 addMarker ( res , resource , msg , line , sev , """" ) ; 
 } catch ( final Exception e ) { 
 ErlLogger . warn ( e ) ; 
 ErlLogger . warn ( ""got: %s"" , odata ) ; 
 } 
 } 
 }  ",2009-10-24 00:12:00 +0200,2010-02-25 11:13:59 +0100,4,0.9825402948353473
545,313,https://www.github.com/whiley/whileycompiler,build(Module),,2171,2171,2171,2171,FIXME: there is a bug here for bool sets,https://www.github.com/whiley/whileycompiler/commit/f932346019,https://www.github.com/whiley/whileycompiler/commit/c63007d1dba4e271a9abc1bd58fd3385b97f4b43,src/wyjc/io/ClassFileBuilder.java,"protected void translate(Value.Set lv, int freeSlot,
			ArrayList<Bytecode> bytecodes) {
construct(WHILEYSET, freeSlot, bytecodes);
JvmType.Function ftype = new JvmType.Function(T_BOOL,
				JAVA_LANG_OBJECT);
for(Value e : lv.values) {
// FIXME: there is a bug here for bool sets
bytecodes.add(new Bytecode.Dup(WHILEYSET));
translate(e, freeSlot, bytecodes);
bytecodes.add(new Bytecode.Invoke(WHILEYSET,""add"",ftype,Bytecode.VIRTUAL));
bytecodes.add(new Bytecode.Pop(JvmTypes.T_BOOL));
}
}","protected void translate(Value.Set lv, int freeSlot,
			ArrayList<Bytecode> bytecodes) {
JvmType.Function ftype = new JvmType.Function(T_VOID);
bytecodes.add(new Bytecode.Invoke(WHILEYLIST, ""<init>"", ftype,
				Bytecode.SPECIAL));
ftype = new JvmType.Function(WHILEYSET, WHILEYSET, JAVA_LANG_OBJECT);
for (Value e : lv.values) {
translate(e, freeSlot, bytecodes);
addWriteConversion(e.type(), bytecodes);
bytecodes.add(new Bytecode.Invoke(WHILEYSET, ""union"", ftype,
					Bytecode.STATIC));
}
}","protected void translate ( Value . Set lv , int freeSlot , 
 ArrayList < Bytecode > bytecodes ) { 
 construct ( WHILEYSET , freeSlot , bytecodes ) ; 
 JvmType . Function ftype = new JvmType . Function ( T_BOOL , 
 JAVA_LANG_OBJECT ) ; 
 for ( Value e : lv . values ) { 
 // FIXME : there is a bug here for bool sets 
 bytecodes . add ( new Bytecode . Dup ( WHILEYSET ) ) ; 
 translate ( e , freeSlot , bytecodes ) ; 
 bytecodes . add ( new Bytecode . Invoke ( WHILEYSET , ""add"" , ftype , Bytecode . VIRTUAL ) ) ; 
 bytecodes . add ( new Bytecode . Pop ( JvmTypes . T_BOOL ) ) ; 
 } 
 }  ","protected void translate ( Value . Set lv , int freeSlot , 
 ArrayList < Bytecode > bytecodes ) { 
 JvmType . Function ftype = new JvmType . Function ( T_VOID ) ; 
 bytecodes . add ( new Bytecode . Invoke ( WHILEYLIST , ""<init>"" , ftype , 
 Bytecode . SPECIAL ) ) ; 
 ftype = new JvmType . Function ( WHILEYSET , WHILEYSET , JAVA_LANG_OBJECT ) ; 
 for ( Value e : lv . values ) { 
 translate ( e , freeSlot , bytecodes ) ; 
 addWriteConversion ( e . type ( ) , bytecodes ) ; 
 bytecodes . add ( new Bytecode . Invoke ( WHILEYSET , ""union"" , ftype , 
 Bytecode . STATIC ) ) ; 
 } 
 }  ",2011-04-26 19:17:22 +1200,2011-06-21 16:29:41 +1200,1,0.8646713965371188
2229,132,https://www.github.com/torquebox/jruby-maven-plugins,"resolveTransitively(Set<Artifact>, Artifact)",NOT_DESIGN,372,372,372,372,TODO do not handle gem only artifacts for now,https://www.github.com/torquebox/jruby-maven-plugins/commit/a2f2d968d,https://www.github.com/torquebox/jruby-maven-plugins/commit/287d37c0d5f6adcd807860035ecd46163409898d,jruby-maven-plugin/src/main/java/de/saumya/mojo/jruby/AbstractJRubyMojo.java,"private void resolveTransitively(final Set<Artifact> artifacts,
            final Artifact artifact) {
// System.out.println(artifact + "" resolve:"");
// if (artifact.getArtifactHandler().isIncludesDependencies()) {
try {
final MavenProject mavenProject = this.builder.buildFromRepository(artifact,
                                                                               this.remoteRepositories,
                                                                               this.localRepository);
final Set<Artifact> moreArtifacts = mavenProject.createArtifacts(this.artifactFactory,
                                                                             null,
                                                                             null);
final ArtifactResolutionResult arr = this.resolver.resolveTransitively(moreArtifacts,
                                                                                   artifact,
                                                                                   this.remoteRepositories,
                                                                                   this.localRepository,
                                                                                   this.metadata);
// System.out.println(artifact + "" "" + arr);
for (final Object artiObject : arr.getArtifacts()) {
// allow older api to work
final Artifact arti = (Artifact) artiObject;
// System.out.println(arti
// + "" ""
// + ""java"".equals(arti.getArtifactHandler()
// .isIncludesDependencies()) + "" ""
// + arti.getArtifactHandler().getExtension() + "" ""
// + arti.getArtifactHandler().getPackaging() + "" ""
// + arti.getArtifactHandler().getClassifier());
if (!artifacts.contains(arti)
// TODO do not handle gem only artifacts for now
&& !(!arti.hasClassifier() && ""gem"".equals(arti.getArtifactHandler()
.getPackaging()))) {
resolveTransitively(artifacts, arti);
}
artifacts.add(arti);
}
}
catch (final ArtifactResolutionException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
catch (final ArtifactNotFoundException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
catch (final InvalidDependencyVersionException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
catch (final ProjectBuildingException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
// }
}","private void resolveTransitively(final Set<Artifact> artifacts,
            final Artifact artifact) {
// System.out.println(artifact + "" resolve:"");
// if (artifact.getArtifactHandler().isIncludesDependencies()) {
try {
final MavenProject mavenProject = this.builder.buildFromRepository(artifact,
                                                                               this.remoteRepositories,
                                                                               this.localRepository);
final Set<Artifact> moreArtifacts = mavenProject.createArtifacts(this.artifactFactory,
                                                                             null,
                                                                             null);
final ArtifactResolutionResult arr = this.resolver.resolveTransitively(moreArtifacts,
                                                                                   artifact,
                                                                                   this.remoteRepositories,
                                                                                   this.localRepository,
                                                                                   this.metadata);
System.out.println(artifact + "" "" + arr);
for (final Object artiObject : arr.getArtifacts()) {
// allow older api to work
final Artifact arti = (Artifact) artiObject;
artifacts.add(arti);
}
}
catch (final ArtifactResolutionException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
catch (final ArtifactNotFoundException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
// catch (final InvalidDependencyVersionException e) {
// // TODO Auto-generated catch block
// e.printStackTrace();
// }
catch (final ProjectBuildingException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
}","private void resolveTransitively ( final Set < Artifact > artifacts , 
 final Artifact artifact ) { 
 // System . out . println ( artifact + "" resolve:"" ) ; 
 // if ( artifact . getArtifactHandler ( ) . isIncludesDependencies ( ) ) { 
 try { 
 final MavenProject mavenProject = this . builder . buildFromRepository ( artifact , 
 this . remoteRepositories , 
 this . localRepository ) ; 
 final Set < Artifact > moreArtifacts = mavenProject . createArtifacts ( this . artifactFactory , 
 null , 
 null ) ; 
 final ArtifactResolutionResult arr = this . resolver . resolveTransitively ( moreArtifacts , 
 artifact , 
 this . remoteRepositories , 
 this . localRepository , 
 this . metadata ) ; 
 // System . out . println ( artifact + "" "" + arr ) ; 
 for ( final Object artiObject : arr . getArtifacts ( ) ) { 
 // allow older api to work 
 final Artifact arti = ( Artifact ) artiObject ; 
 // System . out . println ( arti 
 // + "" "" 
 // + ""java"" . equals ( arti . getArtifactHandler ( ) 
 // . isIncludesDependencies ( ) ) + "" "" 
 // + arti . getArtifactHandler ( ) . getExtension ( ) + "" "" 
 // + arti . getArtifactHandler ( ) . getPackaging ( ) + "" "" 
 // + arti . getArtifactHandler ( ) . getClassifier ( ) ) ; 
 if ( ! artifacts . contains ( arti ) 
 // TODO do not handle gem only artifacts for now 
 & &   ! ( ! arti . hasClassifier ( ) & & ""gem"" . equals ( arti . getArtifactHandler ( ) 
 . getPackaging ( ) ) ) ) { 
 resolveTransitively ( artifacts , arti ) ; 
 } 
 artifacts . add ( arti ) ; 
 } 
 } 
 catch ( final ArtifactResolutionException e ) { 
 // TODO Auto - generated catch block 
 e . printStackTrace ( ) ; 
 } 
 catch ( final ArtifactNotFoundException e ) { 
 // TODO Auto - generated catch block 
 e . printStackTrace ( ) ; 
 } 
 catch ( final InvalidDependencyVersionException e ) { 
 // TODO Auto - generated catch block 
 e . printStackTrace ( ) ; 
 } 
 catch ( final ProjectBuildingException e ) { 
 // TODO Auto - generated catch block 
 e . printStackTrace ( ) ; 
 } 
 // } 
 }  ","private void resolveTransitively ( final Set < Artifact > artifacts , 
 final Artifact artifact ) { 
 // System . out . println ( artifact + "" resolve:"" ) ; 
 // if ( artifact . getArtifactHandler ( ) . isIncludesDependencies ( ) ) { 
 try { 
 final MavenProject mavenProject = this . builder . buildFromRepository ( artifact , 
 this . remoteRepositories , 
 this . localRepository ) ; 
 final Set < Artifact > moreArtifacts = mavenProject . createArtifacts ( this . artifactFactory , 
 null , 
 null ) ; 
 final ArtifactResolutionResult arr = this . resolver . resolveTransitively ( moreArtifacts , 
 artifact , 
 this . remoteRepositories , 
 this . localRepository , 
 this . metadata ) ; 
 System . out . println ( artifact + "" "" + arr ) ; 
 for ( final Object artiObject : arr . getArtifacts ( ) ) { 
 // allow older api to work 
 final Artifact arti = ( Artifact ) artiObject ; 
 artifacts . add ( arti ) ; 
 } 
 } 
 catch ( final ArtifactResolutionException e ) { 
 // TODO Auto - generated catch block 
 e . printStackTrace ( ) ; 
 } 
 catch ( final ArtifactNotFoundException e ) { 
 // TODO Auto - generated catch block 
 e . printStackTrace ( ) ; 
 } 
 // catch ( final InvalidDependencyVersionException e ) { 
 // // TODO Auto - generated catch block 
 // e . printStackTrace ( ) ; 
 // } 
 catch ( final ProjectBuildingException e ) { 
 // TODO Auto - generated catch block 
 e . printStackTrace ( ) ; 
 } 
 } <ERROR>",2009-12-29 18:39:09 +0530,2010-01-11 22:21:42 +0530,1,0.8481447922907484
3201,313,https://www.github.com/whiley/whileycompiler,"infer(int, Code.IndirectSend, Block.Entry, Env)",,247,247,247,247,FIXME: need to do something here,https://www.github.com/whiley/whileycompiler/commit/0d2c1e5c17,https://www.github.com/whiley/whileycompiler/commit/430804cf047eecd20791386ef8452bd2c8b5d766,src/wyil/transforms/BackPropagation.java,"public void infer(int index, Code.IndirectSend code, Block.Entry entry,
			Env environment) {
// FIXME: need to do something here
}","public void infer(int index, Code.IndirectSend code, Block.Entry entry,
			Env environment) {
if(code.type.ret() != Type.T_VOID && code.retval) {
Type req = environment.pop();
coerce(req,code.type.ret(),index,entry);
}
environment.push(code.type);
environment.push(code.type.receiver());
if(code.type.receiver() != null) {
environment.push(code.type.receiver());
}
for(Type t : code.type.params()) {
environment.push(t);
}
}","public void infer ( int index , Code . IndirectSend code , Block . Entry entry , 
 Env environment ) { 
 // FIXME : need to do something here 
 }  ","public void infer ( int index , Code . IndirectSend code , Block . Entry entry , 
 Env environment ) { 
 if ( code . type . ret ( ) != Type . T_VOID & & code . retval ) { 
 Type req = environment . pop ( ) ; 
 coerce ( req , code . type . ret ( ) , index , entry ) ; 
 } 
 environment . push ( code . type ) ; 
 environment . push ( code . type . receiver ( ) ) ; 
 if ( code . type . receiver ( ) != null ) { 
 environment . push ( code . type . receiver ( ) ) ; 
 } 
 for ( Type t : code . type . params ( ) ) { 
 environment . push ( t ) ; 
 } 
 }  ",2011-06-12 12:49:15 +1200,2011-06-27 18:30:58 +1200,3,0.5809210939562323
2450,457,https://www.github.com/asynchttpclient/async-http-client,future(),,75,75,75,75,TODO: channel.getRemoteAddress()).getHostName() is very expensive. Should cache the result.,https://www.github.com/asynchttpclient/async-http-client/commit/8d46c77679,https://www.github.com/asynchttpclient/async-http-client/commit/eb79dcb27a5c252e95cb1b5f680607dd0bc18a35,src/main/java/com/ning/http/client/providers/netty/NettyConnectListener.java,"public final void operationComplete(ChannelFuture f) throws Exception {
if (f.isSuccess()) {
Channel channel = f.getChannel();
channel.getPipeline().getContext(NettyAsyncHttpProvider.class).setAttachment(future);
SslHandler sslHandler = (SslHandler) channel.getPipeline().get(NettyAsyncHttpProvider.SSL_HANDLER);
if (!handshakeDone.getAndSet(true) && (sslHandler != null)) {
((SslHandler) channel.getPipeline().get(NettyAsyncHttpProvider.SSL_HANDLER)).handshake().addListener(this);
return;
}
HostnameVerifier v = config.getHostnameVerifier();
if (sslHandler != null && !AllowAllHostnameVerifier.class.isAssignableFrom(v.getClass())) {
// TODO: channel.getRemoteAddress()).getHostName() is very expensive. Should cache the result.
if (!v.verify(InetSocketAddress.class.cast(channel.getRemoteAddress()).getHostName(),
                        sslHandler.getEngine().getSession())) {
throw new ConnectException(""HostnameVerifier exception."");
}
}
future.provider().writeRequest(f.getChannel(), config, future, nettyRequest);
} else {
Throwable cause = f.getCause();
logger.debug(""Trying to recover a dead cached channel {} with a retry value of {} "", f.getChannel(), future.canRetry());
if (future.canRetry() && cause != null && (NettyAsyncHttpProvider.abortOnDisconnectException(cause)
|| ClosedChannelException.class.isAssignableFrom(cause.getClass())
|| future.getState() != NettyResponseFuture.STATE.NEW)) {
logger.debug(""Retrying {} "", nettyRequest);
if (future.provider().remotelyClosed(f.getChannel(), future)) {
return;
}
}
logger.debug(""Failed to recover from exception: {} with channel {}"", cause, f.getChannel());
boolean printCause = f.getCause() != null && cause.getMessage() != null;
ConnectException e = new ConnectException(printCause ? cause.getMessage() + "" to "" + future.getURI().toString() : future.getURI().toString());
if (cause != null) {
e.initCause(cause);
}
future.abort(e);
}
}","public final void operationComplete(ChannelFuture f) throws Exception {
if (f.isSuccess()) {
Channel channel = f.getChannel();
channel.getPipeline().getContext(NettyAsyncHttpProvider.class).setAttachment(future);
SslHandler sslHandler = (SslHandler) channel.getPipeline().get(NettyAsyncHttpProvider.SSL_HANDLER);
if (!handshakeDone.getAndSet(true) && (sslHandler != null)) {
((SslHandler) channel.getPipeline().get(NettyAsyncHttpProvider.SSL_HANDLER)).handshake().addListener(this);
return;
}
HostnameVerifier v = config.getHostnameVerifier();
if (sslHandler != null) {
if (!v.verify(future.getURI().getHost(), sslHandler.getEngine().getSession())) {
ConnectException exception = new ConnectException(""HostnameVerifier exception."");
future.abort(exception);
throw exception;
}
}
future.provider().writeRequest(f.getChannel(), config, future, nettyRequest);
} else {
Throwable cause = f.getCause();
logger.debug(""Trying to recover a dead cached channel {} with a retry value of {} "", f.getChannel(), future.canRetry());
if (future.canRetry() && cause != null && (NettyAsyncHttpProvider.abortOnDisconnectException(cause)
|| ClosedChannelException.class.isAssignableFrom(cause.getClass())
|| future.getState() != NettyResponseFuture.STATE.NEW)) {
logger.debug(""Retrying {} "", nettyRequest);
if (future.provider().remotelyClosed(f.getChannel(), future)) {
return;
}
}
logger.debug(""Failed to recover from exception: {} with channel {}"", cause, f.getChannel());
boolean printCause = f.getCause() != null && cause.getMessage() != null;
ConnectException e = new ConnectException(printCause ? cause.getMessage() + "" to "" + future.getURI().toString() : future.getURI().toString());
if (cause != null) {
e.initCause(cause);
}
future.abort(e);
}
}","public final void operationComplete ( ChannelFuture f ) throws Exception { 
 if ( f . isSuccess ( ) ) { 
 Channel channel = f . getChannel ( ) ; 
 channel . getPipeline ( ) . getContext ( NettyAsyncHttpProvider . class ) . setAttachment ( future ) ; 
 SslHandler sslHandler = ( SslHandler ) channel . getPipeline ( ) . get ( NettyAsyncHttpProvider . SSL_HANDLER ) ; 
 if ( ! handshakeDone . getAndSet ( true ) & & ( sslHandler != null ) ) { 
 ( ( SslHandler ) channel . getPipeline ( ) . get ( NettyAsyncHttpProvider . SSL_HANDLER ) ) . handshake ( ) . addListener ( this ) ; 
 return ; 
 } 
 HostnameVerifier v = config . getHostnameVerifier ( ) ; 
 if ( sslHandler != null & &   ! AllowAllHostnameVerifier . class . isAssignableFrom ( v . getClass ( ) ) ) { 
 // TODO : channel . getRemoteAddress ( ) ) . getHostName ( ) is very expensive . Should cache the result . 
 if ( ! v . verify ( InetSocketAddress . class . cast ( channel . getRemoteAddress ( ) ) . getHostName ( ) , 
 sslHandler . getEngine ( ) . getSession ( ) ) ) { 
 throw new ConnectException ( ""HostnameVerifier exception."" ) ; 
 } 
 } 
 future . provider ( ) . writeRequest ( f . getChannel ( ) , config , future , nettyRequest ) ; 
 } else { 
 Throwable cause = f . getCause ( ) ; 
 logger . debug ( ""Trying to recover a dead cached channel {} with a retry value of {} "" , f . getChannel ( ) , future . canRetry ( ) ) ; 
 if ( future . canRetry ( ) & & cause != null & & ( NettyAsyncHttpProvider . abortOnDisconnectException ( cause ) 
 | | ClosedChannelException . class . isAssignableFrom ( cause . getClass ( ) ) 
 | | future . getState ( ) != NettyResponseFuture . STATE . NEW ) ) { 
 logger . debug ( ""Retrying {} "" , nettyRequest ) ; 
 if ( future . provider ( ) . remotelyClosed ( f . getChannel ( ) , future ) ) { 
 return ; 
 } 
 } 
 logger . debug ( ""Failed to recover from exception: {} with channel {}"" , cause , f . getChannel ( ) ) ; 
 boolean printCause = f . getCause ( ) != null & & cause . getMessage ( ) != null ; 
 ConnectException e = new ConnectException ( printCause   ? cause . getMessage ( ) + "" to "" + future . getURI ( ) . toString ( ) : future . getURI ( ) . toString ( ) ) ; 
 if ( cause != null ) { 
 e . initCause ( cause ) ; 
 } 
 future . abort ( e ) ; 
 } 
 } <ERROR>","public final void operationComplete ( ChannelFuture f ) throws Exception { 
 if ( f . isSuccess ( ) ) { 
 Channel channel = f . getChannel ( ) ; 
 channel . getPipeline ( ) . getContext ( NettyAsyncHttpProvider . class ) . setAttachment ( future ) ; 
 SslHandler sslHandler = ( SslHandler ) channel . getPipeline ( ) . get ( NettyAsyncHttpProvider . SSL_HANDLER ) ; 
 if ( ! handshakeDone . getAndSet ( true ) & & ( sslHandler != null ) ) { 
 ( ( SslHandler ) channel . getPipeline ( ) . get ( NettyAsyncHttpProvider . SSL_HANDLER ) ) . handshake ( ) . addListener ( this ) ; 
 return ; 
 } 
 HostnameVerifier v = config . getHostnameVerifier ( ) ; 
 if ( sslHandler != null ) { 
 if ( ! v . verify ( future . getURI ( ) . getHost ( ) , sslHandler . getEngine ( ) . getSession ( ) ) ) { 
 ConnectException exception = new ConnectException ( ""HostnameVerifier exception."" ) ; 
 future . abort ( exception ) ; 
 throw exception ; 
 } 
 } 
 future . provider ( ) . writeRequest ( f . getChannel ( ) , config , future , nettyRequest ) ; 
 } else { 
 Throwable cause = f . getCause ( ) ; 
 logger . debug ( ""Trying to recover a dead cached channel {} with a retry value of {} "" , f . getChannel ( ) , future . canRetry ( ) ) ; 
 if ( future . canRetry ( ) & & cause != null & & ( NettyAsyncHttpProvider . abortOnDisconnectException ( cause ) 
 | | ClosedChannelException . class . isAssignableFrom ( cause . getClass ( ) ) 
 | | future . getState ( ) != NettyResponseFuture . STATE . NEW ) ) { 
 logger . debug ( ""Retrying {} "" , nettyRequest ) ; 
 if ( future . provider ( ) . remotelyClosed ( f . getChannel ( ) , future ) ) { 
 return ; 
 } 
 } 
 logger . debug ( ""Failed to recover from exception: {} with channel {}"" , cause , f . getChannel ( ) ) ; 
 boolean printCause = f . getCause ( ) != null & & cause . getMessage ( ) != null ; 
 ConnectException e = new ConnectException ( printCause   ? cause . getMessage ( ) + "" to "" + future . getURI ( ) . toString ( ) : future . getURI ( ) . toString ( ) ) ; 
 if ( cause != null ) { 
 e . initCause ( cause ) ; 
 } 
 future . abort ( e ) ; 
 } 
 }  ",2011/6/27 11:54,2012/5/7 13:55,6,0.9644906263130726
3838,11,https://www.github.com/nodebox/nodebox,testCopyWithUpstream(),NOT_DESIGN,385,385,440,440,TODO: Implement copyNodeWithUpstream,https://www.github.com/nodebox/nodebox/commit/f9243a10b,https://www.github.com/nodebox/nodebox/commit/bae8050f4a4ac4f93f45190fb89a2e6eb90890b3,test/nodebox/node/NodeTest.java,"public void testCopyWithUpstream() {
Node net = testNetworkNode.newInstance(testLibrary, ""net1"");
Node number1 = net.create(numberNode);
Node number2 = net.create(numberNode);
Node add1 = net.create(addNode);
assertEquals(""number1"", number1.getName());
assertEquals(""number2"", number2.getName());
assertEquals(""add1"", add1.getName());
add1.getPort(""v1"").connect(number1);
add1.getPort(""v2"").connect(number2);
// TODO: Implement copyNodeWithUpstream         
//        Node copiedAdd1 = add1.getParent().copyNodeWithUpstream(add1);
//        assertEquals(""add1"", copiedAdd1.getName());
//        Network copiedNetwork = copiedAdd1.getParent();
//        assertEquals(net.getName(), copiedNetwork.getName());
//        Node copiedNumber1 = copiedAdd1.getParent().get(""number1"");
//        Node copiedNumber2 = copiedAdd1.getParent().get(""number2"");
//        assertNotNull(copiedNumber1);
//        assertNotNull(copiedNumber2);
//        assert (copiedAdd1.isConnected());
//        assert (copiedAdd1.getParameter(""v1"").isConnectedTo(copiedNumber1));
//        assert (copiedAdd1.getParameter(""v2"").isConnectedTo(copiedNumber2));
}","public void testCopyWithUpstream() {
// We create a simple network where
// alpha <- beta <- gamma
// beta will be the node to copy. This checks if upstreams/downstreams are handled correctly.
Node net1 = testNetworkNode.newInstance(testLibrary, ""net1"");
Node net2 = testNetworkNode.newInstance(testLibrary, ""net2"");
Node alpha = net1.create(Node.ROOT_NODE, ""alpha"", Integer.class);
Node beta = net1.create(Node.ROOT_NODE, ""beta"", Integer.class);
String originalDescription = ""Beta description"";
beta.setDescription(originalDescription);
beta.setValue(""_code"", new PythonCode(""def cook(self): return self.value""));
Node gamma = net1.create(Node.ROOT_NODE, ""gamma"", Integer.class);
int originalValue = 5;
beta.addParameter(""value"", Parameter.Type.INT, originalValue);
Port betaPort1 = beta.addPort(""betaPort1"");
Port gammaPort1 = gamma.addPort(""gammaPort1"");
betaPort1.connect(alpha);
gammaPort1.connect(beta);
// Update and clean the network.
gamma.update();
assertFalse(beta.isDirty());
assertEquals(originalValue, beta.getOutputValue());
// Copying under the same parent will give the node a unique name.
Node beta1 = beta.copyWithUpstream(net1);
assertEquals(""beta1"", beta1.getName());
// Copying under a different parent keep the original name.
Node beta2 = beta.copyWithUpstream(net2);
assertEquals(""beta"", beta2.getName());
// The node inherits from the same prototype as the original.
assertSame(beta.getPrototype(), beta1.getPrototype());
// It also retains all the same changes as the original.
assertSame(beta.getDataClass(), beta1.getDataClass());
assertTrue(beta1.hasParameter(""value""));
assertEquals(originalValue, beta1.asInt(""value""));
assertTrue(beta1.hasPort(""betaPort1""));
// Some other properties.
assertEquals(0.0, beta1.getX());
assertEquals(0.0, beta1.getY());
assertEquals(originalDescription, beta1.getDescription());
// The new node will be dirty and won't have any output data.
assertTrue(beta1.isDirty());
assertNull(beta1.getOutputValue());
// It also retains connections to the upstream nodes,
// although the connection objects differ.
// It does not retain connections to the downstream nodes since
// that would replace existing connections.
assertTrue(beta1.isConnectedTo(alpha));
Connection newConn = beta1.getPort(""betaPort1"").getConnection();
assertNotSame(betaPort1.getConnection(), newConn);
assertFalse(beta1.isConnectedTo(gamma));
// If the new node is under a different parent connections cannot be retained.
assertFalse(beta2.isConnected());
// Try updating the node to see if the results are still correct.
beta1.update();
assertEquals(originalValue, beta1.getOutputValue());
// Changes to the copy should not affect the original and vice versa.
int newValueForOriginal = 11;
int newValueForCopy = 33;
beta.setValue(""value"", newValueForOriginal);
assertEquals(originalValue, beta1.asInt(""value""));
beta1.setValue(""value"", newValueForCopy);
assertEquals(newValueForOriginal, beta.asInt(""value""));
}","public void testCopyWithUpstream ( ) { 
 Node net = testNetworkNode . newInstance ( testLibrary , ""net1"" ) ; 
 Node number1 = net . create ( numberNode ) ; 
 Node number2 = net . create ( numberNode ) ; 
 Node add1 = net . create ( addNode ) ; 
 assertEquals ( ""number1"" , number1 . getName ( ) ) ; 
 assertEquals ( ""number2"" , number2 . getName ( ) ) ; 
 assertEquals ( ""add1"" , add1 . getName ( ) ) ; 
 add1 . getPort ( ""v1"" ) . connect ( number1 ) ; 
 add1 . getPort ( ""v2"" ) . connect ( number2 ) ; 
 // TODO : Implement copyNodeWithUpstream 
 // Node copiedAdd1 = add1 . getParent ( ) . copyNodeWithUpstream ( add1 ) ; 
 // assertEquals ( ""add1"" , copiedAdd1 . getName ( ) ) ; 
 // Network copiedNetwork = copiedAdd1 . getParent ( ) ; 
 // assertEquals ( net . getName ( ) , copiedNetwork . getName ( ) ) ; 
 // Node copiedNumber1 = copiedAdd1 . getParent ( ) . get ( ""number1"" ) ; 
 // Node copiedNumber2 = copiedAdd1 . getParent ( ) . get ( ""number2"" ) ; 
 // assertNotNull ( copiedNumber1 ) ; 
 // assertNotNull ( copiedNumber2 ) ; 
 // assert ( copiedAdd1 . isConnected ( ) ) ; 
 // assert ( copiedAdd1 . getParameter ( ""v1"" ) . isConnectedTo ( copiedNumber1 ) ) ; 
 // assert ( copiedAdd1 . getParameter ( ""v2"" ) . isConnectedTo ( copiedNumber2 ) ) ; 
 }  ","public void testCopyWithUpstream ( ) { 
 // We create a simple network where 
 // alpha < - beta < - gamma 
 // beta will be the node to copy . This checks if upstreams / downstreams are handled correctly . 
 Node net1 = testNetworkNode . newInstance ( testLibrary , ""net1"" ) ; 
 Node net2 = testNetworkNode . newInstance ( testLibrary , ""net2"" ) ; 
 Node alpha = net1 . create ( Node . ROOT_NODE , ""alpha"" , Integer . class ) ; 
 Node beta = net1 . create ( Node . ROOT_NODE , ""beta"" , Integer . class ) ; 
 String originalDescription = ""Beta description"" ; 
 beta . setDescription ( originalDescription ) ; 
 beta . setValue ( ""_code"" , new PythonCode ( ""def cook(self): return self.value"" ) ) ; 
 Node gamma = net1 . create ( Node . ROOT_NODE , ""gamma"" , Integer . class ) ; 
 int originalValue = 5 ; 
 beta . addParameter ( ""value"" , Parameter . Type . INT , originalValue ) ; 
 Port betaPort1 = beta . addPort ( ""betaPort1"" ) ; 
 Port gammaPort1 = gamma . addPort ( ""gammaPort1"" ) ; 
 betaPort1 . connect ( alpha ) ; 
 gammaPort1 . connect ( beta ) ; 
 // Update and clean the network . 
 gamma . update ( ) ; 
 assertFalse ( beta . isDirty ( ) ) ; 
 assertEquals ( originalValue , beta . getOutputValue ( ) ) ; 
 // Copying under the same parent will give the node a unique name . 
 Node beta1 = beta . copyWithUpstream ( net1 ) ; 
 assertEquals ( ""beta1"" , beta1 . getName ( ) ) ; 
 // Copying under a different parent keep the original name . 
 Node beta2 = beta . copyWithUpstream ( net2 ) ; 
 assertEquals ( ""beta"" , beta2 . getName ( ) ) ; 
 // The node inherits from the same prototype as the original . 
 assertSame ( beta . getPrototype ( ) , beta1 . getPrototype ( ) ) ; 
 // It also retains all the same changes as the original . 
 assertSame ( beta . getDataClass ( ) , beta1 . getDataClass ( ) ) ; 
 assertTrue ( beta1 . hasParameter ( ""value"" ) ) ; 
 assertEquals ( originalValue , beta1 . asInt ( ""value"" ) ) ; 
 assertTrue ( beta1 . hasPort ( ""betaPort1"" ) ) ; 
 // Some other properties . 
 assertEquals ( 0.0 , beta1 . getX ( ) ) ; 
 assertEquals ( 0.0 , beta1 . getY ( ) ) ; 
 assertEquals ( originalDescription , beta1 . getDescription ( ) ) ; 
 // The new node will be dirty and won ' t have any output data . 
 assertTrue ( beta1 . isDirty ( ) ) ; 
 assertNull ( beta1 . getOutputValue ( ) ) ; 
 // It also retains connections to the upstream nodes , 
 // although the connection objects differ . 
 // It does not retain connections to the downstream nodes since 
 // that would replace existing connections . 
 assertTrue ( beta1 . isConnectedTo ( alpha ) ) ; 
 Connection newConn = beta1 . getPort ( ""betaPort1"" ) . getConnection ( ) ; 
 assertNotSame ( betaPort1 . getConnection ( ) , newConn ) ; 
 assertFalse ( beta1 . isConnectedTo ( gamma ) ) ; 
 // If the new node is under a different parent connections cannot be retained . 
 assertFalse ( beta2 . isConnected ( ) ) ; 
 // Try updating the node to see if the results are still correct . 
 beta1 . update ( ) ; 
 assertEquals ( originalValue , beta1 . getOutputValue ( ) ) ; 
 // Changes to the copy should not affect the original and vice versa . 
 int newValueForOriginal = 11 ; 
 int newValueForCopy = 33 ; 
 beta . setValue ( ""value"" , newValueForOriginal ) ; 
 assertEquals ( originalValue , beta1 . asInt ( ""value"" ) ) ; 
 beta1 . setValue ( ""value"" , newValueForCopy ) ; 
 assertEquals ( newValueForOriginal , beta . asInt ( ""value"" ) ) ; 
 }  ",2009-05-19 14:24:48 +0000,2010-01-17 14:45:10 +0200,2,0.15022653268196662
648,272,https://www.github.com/geometer/fbreaderj,canHandleTree(NetworkTree),,328,328,328,328,TODO: make ListView's empty view instead,https://www.github.com/geometer/fbreaderj/commit/55984bec38,https://www.github.com/geometer/fbreaderj/commit/aa3b82a1ba452747d631a9ec4d39aeb8e1e6749f,src/org/geometerplus/android/fbreader/network/NetworkCatalogActions.java,"private void afterUpdateCatalog(String errorMessage, boolean childrenEmpty) {
final ZLResource dialogResource = ZLResource.resource(""dialog"");
ZLResource boxResource = null;
String msg = null;
if (errorMessage != null) {
boxResource = dialogResource.getResource(""networkError"");
msg = errorMessage;
} else if (childrenEmpty) {
// TODO: make ListView's empty view instead
boxResource = dialogResource.getResource(""emptyCatalogBox"");
msg = boxResource.getResource(""message"").getValue();
}
if (msg != null) {
if (NetworkView.Instance().isInitialized()) {
final NetworkCatalogActivity activity = NetworkView.Instance().getOpenedActivity(myKey);
if (activity != null) {
final ZLResource buttonResource = dialogResource.getResource(""button"");
new AlertDialog.Builder(activity)
.setTitle(boxResource.getResource(""title"").getValue())
.setMessage(msg)
.setIcon(0)
.setPositiveButton(buttonResource.getResource(""ok"").getValue(), null)
.create().show();
}
}
}
}","private void afterUpdateCatalog(String errorMessage, boolean childrenEmpty) {
if (!NetworkView.Instance().isInitialized()) {
return;
}
final NetworkCatalogActivity activity = NetworkView.Instance().getOpenedActivity(myKey);
if (activity == null) {
return;
}
String msg = null;
if (errorMessage != null) {
UIUtil.showErrorMessageText(activity, errorMessage);
} else if (childrenEmpty) {
UIUtil.showErrorMessage(activity, ""emptyCatalog"");
}
}","private void afterUpdateCatalog ( String errorMessage , boolean childrenEmpty ) { 
 final ZLResource dialogResource = ZLResource . resource ( ""dialog"" ) ; 
 ZLResource boxResource = null ; 
 String msg = null ; 
 if ( errorMessage != null ) { 
 boxResource = dialogResource . getResource ( ""networkError"" ) ; 
 msg = errorMessage ; 
 } else if ( childrenEmpty ) { 
 // TODO : make ListView ' s empty view instead 
 boxResource = dialogResource . getResource ( ""emptyCatalogBox"" ) ; 
 msg = boxResource . getResource ( ""message"" ) . getValue ( ) ; 
 } 
 if ( msg != null ) { 
 if ( NetworkView . Instance ( ) . isInitialized ( ) ) { 
 final NetworkCatalogActivity activity = NetworkView . Instance ( ) . getOpenedActivity ( myKey ) ; 
 if ( activity != null ) { 
 final ZLResource buttonResource = dialogResource . getResource ( ""button"" ) ; 
 new AlertDialog . Builder ( activity ) 
 . setTitle ( boxResource . getResource ( ""title"" ) . getValue ( ) ) 
 . setMessage ( msg ) 
 . setIcon ( 0 ) 
 . setPositiveButton ( buttonResource . getResource ( ""ok"" ) . getValue ( ) , null ) 
 . create ( ) . show ( ) ; 
 } 
 } 
 } 
 }  ","private void afterUpdateCatalog ( String errorMessage , boolean childrenEmpty ) { 
 if ( ! NetworkView . Instance ( ) . isInitialized ( ) ) { 
 return ; 
 } 
 final NetworkCatalogActivity activity = NetworkView . Instance ( ) . getOpenedActivity ( myKey ) ; 
 if ( activity == null ) { 
 return ; 
 } 
 String msg = null ; 
 if ( errorMessage != null ) { 
 UIUtil . showErrorMessageText ( activity , errorMessage ) ; 
 } else if ( childrenEmpty ) { 
 UIUtil . showErrorMessage ( activity , ""emptyCatalog"" ) ; 
 } 
 }  ",2010-05-07 15:33:32 +0000,2011-02-05 22:06:54 +0000,22,0.42014137293762316
2836,252,https://www.github.com/robolectric/robolectric,reset(),,275,275,275,275,TODO does not support multiple observers for a URI,https://www.github.com/robolectric/robolectric/commit/29a8359eae,https://www.github.com/robolectric/robolectric/commit/1630d3e8a19f047de2e606375b3241f6d576ba43,robolectric-shadows/shadows-core/src/main/java/org/robolectric/shadows/ShadowContentResolver.java,"@Implementation
public void notifyChange(Uri uri, ContentObserver observer, boolean syncToNetwork) {
notifiedUris.add(new NotifiedUri(uri, observer, syncToNetwork));
// TODO does not support multiple observers for a URI
ContentObserver obs = contentObservers.get(uri);
if ( obs != null && obs != observer  ) {
obs.dispatchChange( false, uri );
}
if ( observer != null && observer.deliverSelfNotifications() ) {
observer.dispatchChange( true, uri );
}
}","@Implementation
public void notifyChange(Uri uri, ContentObserver observer, boolean syncToNetwork) {
notifiedUris.add(new NotifiedUri(uri, observer, syncToNetwork));
CopyOnWriteArraySet<ContentObserver> observers = contentObservers.get(uri);
if (observers != null) {
for (ContentObserver obs : observers) {
if ( obs != null && obs != observer  ) {
obs.dispatchChange( false, uri );
}
}
}
if ( observer != null && observer.deliverSelfNotifications() ) {
observer.dispatchChange( true, uri );
}
}","@ Implementation 
 public void notifyChange ( Uri uri , ContentObserver observer , boolean syncToNetwork ) { 
 notifiedUris . add ( new NotifiedUri ( uri , observer , syncToNetwork ) ) ; 
 // TODO does not support multiple observers for a URI 
 ContentObserver obs = contentObservers . get ( uri ) ; 
 if ( obs != null & & obs != observer ) { 
 obs . dispatchChange ( false , uri ) ; 
 } 
 if ( observer != null & & observer . deliverSelfNotifications ( ) ) { 
 observer . dispatchChange ( true , uri ) ; 
 } 
 }  ","@ Implementation 
 public void notifyChange ( Uri uri , ContentObserver observer , boolean syncToNetwork ) { 
 notifiedUris . add ( new NotifiedUri ( uri , observer , syncToNetwork ) ) ; 
 CopyOnWriteArraySet < ContentObserver > observers = contentObservers . get ( uri ) ; 
 if ( observers != null ) { 
 for ( ContentObserver obs : observers ) { 
 if ( obs != null & & obs != observer ) { 
 obs . dispatchChange ( false , uri ) ; 
 } 
 } 
 } 
 if ( observer != null & & observer . deliverSelfNotifications ( ) ) { 
 observer . dispatchChange ( true , uri ) ; 
 } 
 }  ",2013/5/13 15:05,2015-01-16 00:11:21 +0100,5,0.9512091174420159
3378,58,https://www.github.com/simpligility/android-maven-plugin,execute(),DESIGN,90,90,90,90,TODO: This should be src/main/resources instead:,https://www.github.com/simpligility/android-maven-plugin/commit/2493dfdd5,https://www.github.com/simpligility/android-maven-plugin/commit/9e7b8df60ed2fe3171415bc75452cb3e75366a2e,src/main/java/com/jayway/maven/plugins/android/phase08package/ApkMojo.java,"public void execute() throws MojoExecutionException, MojoFailureException {
generateIntermediateAp_();
CommandExecutor executor = CommandExecutor.Factory.createDefaultCommmandExecutor();
executor.setLogger(this.getLog());
File outputFile = new File(project.getBuild().getDirectory(),  project.getBuild().getFinalName() + "".apk"");
List<String> commands = new ArrayList<String>();
commands.add(outputFile.getAbsolutePath());
if(!getAndroidSigner().isSignWithDebugKeyStore()) {
commands.add(""-u"");
}
commands.add(""-z"");
commands.add(new File(project.getBuild().getDirectory(),  project.getBuild().getFinalName() + "".ap_"").getAbsolutePath());
commands.add(""-f"");
commands.add( new File(project.getBuild().getDirectory(),  ""classes.dex"").getAbsolutePath());
commands.add(""-rf"");
// TODO: This should be src/main/resources instead:
commands.add(new File(project.getBuild().getSourceDirectory()).getAbsolutePath());
getLog().info(getAndroidSdk().getPathForTool(""apkbuilder"")+"" "" + commands.toString());
try {
executor.executeCommand(getAndroidSdk().getPathForTool(""apkbuilder""), commands, project.getBasedir(), false);
} catch (ExecutionException e) {
throw new MojoExecutionException("""", e);
}
// Set the generated .apk file as the main artifact (because the pom states <packaging>apk</packaging>)
project.getArtifact().setFile(outputFile);
// Also attach the normal .jar, so it can be depended on by for example an instrumentation project if they need access to our R.java and other things.
projectHelper.attachArtifact(project, ""jar"", new File(project.getBuild().getDirectory(), project.getBuild().getFinalName() + "".jar""));
}","public void execute() throws MojoExecutionException, MojoFailureException {
generateIntermediateAp_();
CommandExecutor executor = CommandExecutor.Factory.createDefaultCommmandExecutor();
executor.setLogger(this.getLog());
File outputFile = new File(project.getBuild().getDirectory(),  project.getBuild().getFinalName() + "".apk"");
List<String> commands = new ArrayList<String>();
commands.add(outputFile.getAbsolutePath());
if(!getAndroidSigner().isSignWithDebugKeyStore()) {
commands.add(""-u"");
}
commands.add(""-z"");
commands.add(new File(project.getBuild().getDirectory(),  project.getBuild().getFinalName() + "".ap_"").getAbsolutePath());
commands.add(""-f"");
commands.add( new File(project.getBuild().getDirectory(),  ""classes.dex"").getAbsolutePath());
commands.add(""-rf"");
commands.add(new File(project.getBuild().getDirectory(), ""classes"").getAbsolutePath());
for (Artifact artifact : (List<Artifact>) project.getCompileArtifacts()) {
if (artifact.getGroupId().equals(""android"")) {
continue;
}
if (artifact.getFile().isDirectory()) {
throw new MojoExecutionException(""Dependent artifact is directory: Directory = "" + artifact.getFile().getAbsolutePath());
}
commands.add(""-rj"");
commands.add(artifact.getFile().getAbsolutePath());
}
getLog().info(getAndroidSdk().getPathForTool(""apkbuilder"")+"" "" + commands.toString());
try {
executor.executeCommand(getAndroidSdk().getPathForTool(""apkbuilder""), commands, project.getBasedir(), false);
} catch (ExecutionException e) {
throw new MojoExecutionException("""", e);
}
// Set the generated .apk file as the main artifact (because the pom states <packaging>apk</packaging>)
project.getArtifact().setFile(outputFile);
// Also attach the normal .jar, so it can be depended on by for example an instrumentation project if they need access to our R.java and other things.
projectHelper.attachArtifact(project, ""jar"", new File(project.getBuild().getDirectory(), project.getBuild().getFinalName() + "".jar""));
}","public void execute ( ) throws MojoExecutionException , MojoFailureException { 
 generateIntermediateAp_ ( ) ; 
 CommandExecutor executor = CommandExecutor . Factory . createDefaultCommmandExecutor ( ) ; 
 executor . setLogger ( this . getLog ( ) ) ; 
 File outputFile = new File ( project . getBuild ( ) . getDirectory ( ) , project . getBuild ( ) . getFinalName ( ) + "".apk"" ) ; 
 List < String > commands = new ArrayList < String > ( ) ; 
 commands . add ( outputFile . getAbsolutePath ( ) ) ; 
 if ( ! getAndroidSigner ( ) . isSignWithDebugKeyStore ( ) ) { 
 commands . add ( ""-u"" ) ; 
 } 
 commands . add ( ""-z"" ) ; 
 commands . add ( new File ( project . getBuild ( ) . getDirectory ( ) , project . getBuild ( ) . getFinalName ( ) + "".ap_"" ) . getAbsolutePath ( ) ) ; 
 commands . add ( ""-f"" ) ; 
 commands . add ( new File ( project . getBuild ( ) . getDirectory ( ) , ""classes.dex"" ) . getAbsolutePath ( ) ) ; 
 commands . add ( ""-rf"" ) ; 
 // TODO : This should be src / main / resources instead : 
 commands . add ( new File ( project . getBuild ( ) . getSourceDirectory ( ) ) . getAbsolutePath ( ) ) ; 
 getLog ( ) . info ( getAndroidSdk ( ) . getPathForTool ( ""apkbuilder"" ) + "" "" + commands . toString ( ) ) ; 
 try { 
 executor . executeCommand ( getAndroidSdk ( ) . getPathForTool ( ""apkbuilder"" ) , commands , project . getBasedir ( ) , false ) ; 
 } catch ( ExecutionException e ) { 
 throw new MojoExecutionException ( """" , e ) ; 
 } 
 // Set the generated . apk file as the main artifact ( because the pom states < packaging > apk < / packaging > ) 
 project . getArtifact ( ) . setFile ( outputFile ) ; 
 // Also attach the normal . jar , so it can be depended on by for example an instrumentation project if they need access to our R . java and other things . 
 projectHelper . attachArtifact ( project , ""jar"" , new File ( project . getBuild ( ) . getDirectory ( ) , project . getBuild ( ) . getFinalName ( ) + "".jar"" ) ) ; 
 }  ","public void execute ( ) throws MojoExecutionException , MojoFailureException { 
 generateIntermediateAp_ ( ) ; 
 CommandExecutor executor = CommandExecutor . Factory . createDefaultCommmandExecutor ( ) ; 
 executor . setLogger ( this . getLog ( ) ) ; 
 File outputFile = new File ( project . getBuild ( ) . getDirectory ( ) , project . getBuild ( ) . getFinalName ( ) + "".apk"" ) ; 
 List < String > commands = new ArrayList < String > ( ) ; 
 commands . add ( outputFile . getAbsolutePath ( ) ) ; 
 if ( ! getAndroidSigner ( ) . isSignWithDebugKeyStore ( ) ) { 
 commands . add ( ""-u"" ) ; 
 } 
 commands . add ( ""-z"" ) ; 
 commands . add ( new File ( project . getBuild ( ) . getDirectory ( ) , project . getBuild ( ) . getFinalName ( ) + "".ap_"" ) . getAbsolutePath ( ) ) ; 
 commands . add ( ""-f"" ) ; 
 commands . add ( new File ( project . getBuild ( ) . getDirectory ( ) , ""classes.dex"" ) . getAbsolutePath ( ) ) ; 
 commands . add ( ""-rf"" ) ; 
 commands . add ( new File ( project . getBuild ( ) . getDirectory ( ) , ""classes"" ) . getAbsolutePath ( ) ) ; 
 for ( Artifact artifact : ( List < Artifact > ) project . getCompileArtifacts ( ) ) { 
 if ( artifact . getGroupId ( ) . equals ( ""android"" ) ) { 
 continue ; 
 } 
 if ( artifact . getFile ( ) . isDirectory ( ) ) { 
 throw new MojoExecutionException ( ""Dependent artifact is directory: Directory = "" + artifact . getFile ( ) . getAbsolutePath ( ) ) ; 
 } 
 commands . add ( ""-rj"" ) ; 
 commands . add ( artifact . getFile ( ) . getAbsolutePath ( ) ) ; 
 } 
 getLog ( ) . info ( getAndroidSdk ( ) . getPathForTool ( ""apkbuilder"" ) + "" "" + commands . toString ( ) ) ; 
 try { 
 executor . executeCommand ( getAndroidSdk ( ) . getPathForTool ( ""apkbuilder"" ) , commands , project . getBasedir ( ) , false ) ; 
 } catch ( ExecutionException e ) { 
 throw new MojoExecutionException ( """" , e ) ; 
 } 
 // Set the generated . apk file as the main artifact ( because the pom states < packaging > apk < / packaging > ) 
 project . getArtifact ( ) . setFile ( outputFile ) ; 
 // Also attach the normal . jar , so it can be depended on by for example an instrumentation project if they need access to our R . java and other things . 
 projectHelper . attachArtifact ( project , ""jar"" , new File ( project . getBuild ( ) . getDirectory ( ) , project . getBuild ( ) . getFinalName ( ) + "".jar"" ) ) ; 
 }  ",2009-03-30 18:22:52 +0200,2009-08-17 09:32:52 +0200,11,0.9337485443317501
93,337,https://www.github.com/jenkinsci/swarm-plugin,"getFlow(Node, int)",DESIGN,199,199,199,199,"TODO: Once JENKINS-41854 is fixed, remove the next two lines.",https://www.github.com/jenkinsci/swarm-plugin/commit/c0e44ac6,https://www.github.com/jenkinsci/swarm-plugin/commit/f39b01031a02c95185d218a444bb0b163c31f28a,plugin/src/test/java/hudson/plugins/swarm/PipelineJobTest.java,"private static String getFlow(Node node, int numSemaphores) {
StringBuilder sb = new StringBuilder();
sb.append(""node('"" + node.getNodeName() + ""') {\n"");
for (int i = 0; i < numSemaphores; i++) {
sb.append(""  semaphore 'wait-"" + i + ""'\n"");
}
// TODO: Once JENKINS-41854 is fixed, remove the next two lines.
sb.append(""}\n"");
sb.append(""node('"" + node.getNodeName() + ""') {\n"");
sb.append(
                ""  isUnix() ? sh('echo ON_SWARM_CLIENT=$ON_SWARM_CLIENT') : bat('echo ON_SWARM_CLIENT=%ON_SWARM_CLIENT%')"");
sb.append(""}\n"");
return sb.toString();
}","private static String getFlow(Node node, int numSemaphores) {
StringBuilder sb = new StringBuilder();
sb.append(""node('"" + node.getNodeName() + ""') {\n"");
for (int i = 0; i < numSemaphores; i++) {
sb.append(""  semaphore 'wait-"" + i + ""'\n"");
}
sb.append(
                ""  isUnix() ? sh('echo ON_SWARM_CLIENT=$ON_SWARM_CLIENT') : bat('echo ON_SWARM_CLIENT=%ON_SWARM_CLIENT%')"");
sb.append(""}\n"");
return sb.toString();
}","private static String getFlow ( Node node , int numSemaphores ) { 
 StringBuilder sb = new StringBuilder ( ) ; 
 sb . append ( ""node('"" + node . getNodeName ( ) + ""') {\n"" ) ; 
 for ( int i = 0 ; i < numSemaphores ; i + + ) { 
 sb . append ( ""  semaphore 'wait-"" + i + ""'\n"" ) ; 
 } 
 // TODO : Once JENKINS - 41854 is fixed , remove the next two lines . 
 sb . append ( ""}\n"" ) ; 
 sb . append ( ""node('"" + node . getNodeName ( ) + ""') {\n"" ) ; 
 sb . append ( 
 ""  isUnix() ? sh('echo ON_SWARM_CLIENT=$ON_SWARM_CLIENT') : bat('echo ON_SWARM_CLIENT=%ON_SWARM_CLIENT%')"" ) ; 
 sb . append ( ""}\n"" ) ; 
 return sb . toString ( ) ; 
 }  ","private static String getFlow ( Node node , int numSemaphores ) { 
 StringBuilder sb = new StringBuilder ( ) ; 
 sb . append ( ""node('"" + node . getNodeName ( ) + ""') {\n"" ) ; 
 for ( int i = 0 ; i < numSemaphores ; i + + ) { 
 sb . append ( ""  semaphore 'wait-"" + i + ""'\n"" ) ; 
 } 
 sb . append ( 
 ""  isUnix() ? sh('echo ON_SWARM_CLIENT=$ON_SWARM_CLIENT') : bat('echo ON_SWARM_CLIENT=%ON_SWARM_CLIENT%')"" ) ; 
 sb . append ( ""}\n"" ) ; 
 return sb . toString ( ) ; 
 }  ",2019/5/21 12:06,2020/5/4 12:00,3,0.9600215359558087
251,439,https://www.github.com/awful/awful.apk,onCreate(Bundle),DESIGN,109,109,109,109,TODO: 16/08/2016 probably best to put this in a method that the menu option calls too,https://www.github.com/awful/awful.apk/commit/6677b4b6a,https://www.github.com/awful/awful.apk/commit/f635ad87931be50d017c52d8d36b5a64a1122918,Awful.apk/src/main/java/com/ferg/awfulapp/ForumsIndexActivity.java,"@Override
public void onNewPm(@NonNull String messageUrl, @NonNull final String sender, final int unreadCount) {
// TODO: 16/08/2016 probably best to put this in a method that the menu option calls too
final Intent pmIntent = new Intent().setClass(this, PrivateMessageActivity.class);
Uri uri = Uri.parse(messageUrl);
if (uri != null) {
pmIntent.setData(uri);
}
runOnUiThread(() -> {
String message = ""Private message from %s\n(%d unread)"";
Snackbar.make(mToolbar, String.format(Locale.getDefault(), message, sender, unreadCount), Snackbar.LENGTH_LONG)
.setDuration(3000)
.setAction(""View"", view -> startActivity(pmIntent))
.show();
});
}","@Override
public void onNewPm(@NonNull String messageUrl, @NonNull final String sender, final int unreadCount) {
NavigationEvent showPmEvent = new NavigationEvent.PrivateMessages(Uri.parse(messageUrl));
runOnUiThread(() -> {
String message = ""Private message from %s\n(%d unread)"";
Snackbar.make(mToolbar, String.format(Locale.getDefault(), message, sender, unreadCount), Snackbar.LENGTH_LONG)
.setDuration(3000)
.setAction(""View"", view -> navigate(showPmEvent))
.show();
});
}","@ Override 
 public void onNewPm ( @ NonNull String messageUrl , @ NonNull final String sender , final int unreadCount ) { 
 // TODO : 16 / 0 8 / 2016 probably best to put this in a method that the menu option calls too 
 final Intent pmIntent = new Intent ( ) . setClass ( this , PrivateMessageActivity . class ) ; 
 Uri uri = Uri . parse ( messageUrl ) ; 
 if ( uri != null ) { 
 pmIntent . setData ( uri ) ; 
 } 
 runOnUiThread ( ( ) -> { 
 String message = ""Private message from %s\n(%d unread)"" ; 
 Snackbar . make ( mToolbar , String . format ( Locale . getDefault ( ) , message , sender , unreadCount ) , Snackbar . LENGTH_LONG ) 
 . setDuration ( 3000 ) 
 . setAction ( ""View"" , view -> startActivity ( pmIntent ) ) 
 . show ( ) ; 
 } ) ; 
 }  ","@ Override 
 public void onNewPm ( @ NonNull String messageUrl , @ NonNull final String sender , final int unreadCount ) { 
 NavigationEvent showPmEvent = new NavigationEvent . PrivateMessages ( Uri . parse ( messageUrl ) ) ; 
 runOnUiThread ( ( ) -> { 
 String message = ""Private message from %s\n(%d unread)"" ; 
 Snackbar . make ( mToolbar , String . format ( Locale . getDefault ( ) , message , sender , unreadCount ) , Snackbar . LENGTH_LONG ) 
 . setDuration ( 3000 ) 
 . setAction ( ""View"" , view -> navigate ( showPmEvent ) ) 
 . show ( ) ; 
 } ) ; 
 }  ",2016-08-16 18:26:25 +0100,2018-05-22 22:38:36 +0100,8,0.671904577990781
298,803,https://www.github.com/spring-projects/spring-security,setProviders(List),,281,281,281,281,"TODO bad idea, should use assignable from or instance of",https://www.github.com/spring-projects/spring-security/commit/80c1ae3bdeb,https://www.github.com/spring-projects/spring-security/commit/298491305124a13991f3f3ee2e1f933e15b91885,core/src/main/java/org/acegisecurity/providers/ProviderManager.java,"public void setProviders(List newList) {
checkIfValidList(newList);
Iterator iter = newList.iterator();
while (iter.hasNext()) {
Object currentObject = null;
try {
currentObject = iter.next();
//TODO bad idea, should use assignable from or instance of 
AuthenticationProvider attemptToCast = (AuthenticationProvider) currentObject;
} catch (ClassCastException cce) {
throw new IllegalArgumentException(""AuthenticationProvider "" + currentObject.getClass().getName()
+ "" must implement AuthenticationProvider"");
}
}
this.providers = newList;
}","public void setProviders(List newList) {
checkIfValidList(newList);
Iterator iter = newList.iterator();
while (iter.hasNext()) {
Object currentObject = iter.next();
Assert.isInstanceOf(AuthenticationProvider.class, currentObject, ""Can only provide AuthenticationProvider instances"");
}
this.providers = newList;
}","public void setProviders ( List newList ) { 
 checkIfValidList ( newList ) ; 
 Iterator iter = newList . iterator ( ) ; 
 while ( iter . hasNext ( ) ) { 
 Object currentObject = null ; 
 try { 
 currentObject = iter . next ( ) ; 
 // TODO bad idea , should use assignable from or instance of 
 AuthenticationProvider attemptToCast = ( AuthenticationProvider ) currentObject ; 
 } catch ( ClassCastException cce ) { 
 throw new IllegalArgumentException ( ""AuthenticationProvider "" + currentObject . getClass ( ) . getName ( ) 
 + "" must implement AuthenticationProvider"" ) ; 
 } 
 } 
 this . providers = newList ; 
 }  ","public void setProviders ( List newList ) { 
 checkIfValidList ( newList ) ; 
 Iterator iter = newList . iterator ( ) ; 
 while ( iter . hasNext ( ) ) { 
 Object currentObject = iter . next ( ) ; 
 Assert . isInstanceOf ( AuthenticationProvider . class , currentObject , ""Can only provide AuthenticationProvider instances"" ) ; 
 } 
 this . providers = newList ; 
 }  ",2006-07-09 22:08:21 +0000,2006-11-16 02:15:43 +0000,1,0.8135576023848636
141,598,https://www.github.com/eclipse-ee4j/cdi-tck,testNewBean(),NOT_DESIGN,185,185,185,185,TODO check possible weld bug,https://www.github.com/eclipse-ee4j/cdi-tck/commit/b60786d9ce,https://www.github.com/eclipse-ee4j/cdi-tck/commit/4ef954a42c2d983746ca0ec831ed7fdc5ea0d49e,impl/src/main/java/org/jboss/cdi/tck/tests/lookup/dynamic/DynamicLookupTest.java,"@Test
@SpecAssertions({ @SpecAssertion(section = ""5.6"", id = ""e""), @SpecAssertion(section = ""5.6.3"", id = ""b"") })
@SuppressWarnings(""serial"")
public void testNewBean() {
// TODO check possible weld bug
// Instance<List<String>> instance = getInstanceByType(ObtainsNewInstanceBean.class).getStrings();
// assert instance.select(new TypeLiteral<ArrayList<String>>(){}).get() instanceof ArrayList<?>;
String instance = getInstanceByType(ObtainsNewInstanceBean.class).getString();
assert instance != null && instance instanceof String;
getInstanceByType(ObtainsNewInstanceBean.class).getMap();
}","@Test
@SpecAssertions({ @SpecAssertion(section = ""5.6"", id = ""e""), @SpecAssertion(section = ""5.6.3"", id = ""b"") })
public void testNewBean() {
Instance<String> string = getInstanceByType(ObtainsNewInstanceBean.class).getString();
assert !string.isAmbiguous();
assert !string.isUnsatisfied();
assert string.get() != null;
assert string.get() instanceof String;
Instance<Map<String, String>> map = getInstanceByType(ObtainsNewInstanceBean.class).getMap();
assert !map.isAmbiguous();
assert !map.isUnsatisfied();
Map<String, String> instance = map.get();
assert instance != null;
assert instance instanceof HashMap<?, ?>;
}","@ Test 
 @ SpecAssertions ( { @ SpecAssertion ( section = ""5.6"" , id = ""e"" ) , @ SpecAssertion ( section = ""5.6.3"" , id = ""b"" ) } ) 
 @ SuppressWarnings ( ""serial"" ) 
 public void testNewBean ( ) { 
 // TODO check possible weld bug 
 // Instance < List < String >> instance = getInstanceByType ( ObtainsNewInstanceBean . class ) . getStrings ( ) ; 
 // assert instance . select ( new TypeLiteral < ArrayList < String >> ( ) { } ) . get ( ) instanceof ArrayList < ? > ; 
 String instance = getInstanceByType ( ObtainsNewInstanceBean . class ) . getString ( ) ; 
 assert instance != null & & instance instanceof String ; 
 getInstanceByType ( ObtainsNewInstanceBean . class ) . getMap ( ) ; 
 }  ","@ Test 
 @ SpecAssertions ( { @ SpecAssertion ( section = ""5.6"" , id = ""e"" ) , @ SpecAssertion ( section = ""5.6.3"" , id = ""b"" ) } ) 
 public void testNewBean ( ) { 
 Instance < String > string = getInstanceByType ( ObtainsNewInstanceBean . class ) . getString ( ) ; 
 assert   ! string . isAmbiguous ( ) ; 
 assert   ! string . isUnsatisfied ( ) ; 
 assert string . get ( ) != null ; 
 assert string . get ( ) instanceof String ; 
 Instance < Map < String , String >> map = getInstanceByType ( ObtainsNewInstanceBean . class ) . getMap ( ) ; 
 assert   ! map . isAmbiguous ( ) ; 
 assert   ! map . isUnsatisfied ( ) ; 
 Map < String , String > instance = map . get ( ) ; 
 assert instance != null ; 
 assert instance instanceof HashMap < ? ,   ? > ; 
 }  ",2011-09-26 14:56:11 +0200,2012-05-15 13:56:47 +0200,2,0.6509488612125942
3073,432,https://www.github.com/guardianproject/chatsecureandroid,initOtrChatSession(),NOT_DESIGN,401,401,401,401,TODO OTRCHAT move setFrom() to ChatSession.sendMessageAsync(),https://www.github.com/guardianproject/chatsecureandroid/commit/7bb96cca1,https://www.github.com/guardianproject/chatsecureandroid/commit/482dacab31f31c7e71c95d40e5980b8c1880cdb6,src/info/guardianproject/otr/app/im/service/ChatSessionAdapter.java,"void sendPostponedMessages() {
String[] projection = new String[] { BaseColumns._ID, Imps.Messages.BODY,
                                             Imps.Messages.PACKET_ID,
                                            Imps.Messages.DATE, Imps.Messages.TYPE, };
String selection = Imps.Messages.TYPE + ""=?"";
Cursor c = mContentResolver.query(mMessageURI, projection, selection,
                new String[] { Integer.toString(Imps.MessageType.POSTPONED) }, null);
if (c == null) {
RemoteImService.debug(""Query error while querying postponed messages"");
return;
}
while (c.moveToNext()) {
String id = c.getString(2);
String body = c.getString(1);
info.guardianproject.otr.app.im.engine.Message msg = new info.guardianproject.otr.app.im.engine.Message(body);
// TODO OTRCHAT move setFrom() to ChatSession.sendMessageAsync()
msg.setFrom(mConnection.getLoginUser().getAddress());
msg.setID(id);
msg.setType(Imps.MessageType.OUTGOING);
int newType = mChatSession.sendMessageAsync(msg);
updateMessageInDb(id, newType, System.currentTimeMillis());
}
c.close();
}","void sendPostponedMessages() {
String[] projection = new String[] { BaseColumns._ID, Imps.Messages.BODY,
                                             Imps.Messages.PACKET_ID,
                                            Imps.Messages.DATE, Imps.Messages.TYPE, };
String selection = Imps.Messages.TYPE + ""=?"";
Cursor c = mContentResolver.query(mMessageURI, projection, selection,
                new String[] { Integer.toString(Imps.MessageType.POSTPONED) }, null);
if (c == null) {
RemoteImService.debug(""Query error while querying postponed messages"");
return;
}
ArrayList<String> messages = new ArrayList<String>();
while (c.moveToNext()) {
String body = c.getString(1);
messages.add(body);
}
c.close();
removeMessageInDb(Imps.MessageType.POSTPONED);
for (String body : messages)
sendMessage(body);
}","void sendPostponedMessages ( ) { 
 String [ ] projection = new String [ ] { BaseColumns . _ID , Imps . Messages . BODY , 
 Imps . Messages . PACKET_ID , 
 Imps . Messages . DATE , Imps . Messages . TYPE , } ; 
 String selection = Imps . Messages . TYPE + ""=?"" ; 
 Cursor c = mContentResolver . query ( mMessageURI , projection , selection , 
 new String [ ] { Integer . toString ( Imps . MessageType . POSTPONED ) } , null ) ; 
 if ( c == null ) { 
 RemoteImService . debug ( ""Query error while querying postponed messages"" ) ; 
 return ; 
 } 
 while ( c . moveToNext ( ) ) { 
 String id = c . getString ( 2 ) ; 
 String body = c . getString ( 1 ) ; 
 info . guardianproject . otr . app . im . engine . Message msg = new info . guardianproject . otr . app . im . engine . Message ( body ) ; 
 // TODO OTRCHAT move setFrom ( ) to ChatSession . sendMessageAsync ( ) 
 msg . setFrom ( mConnection . getLoginUser ( ) . getAddress ( ) ) ; 
 msg . setID ( id ) ; 
 msg . setType ( Imps . MessageType . OUTGOING ) ; 
 int newType = mChatSession . sendMessageAsync ( msg ) ; 
 updateMessageInDb ( id , newType , System . currentTimeMillis ( ) ) ; 
 } 
 c . close ( ) ; 
 }  ","void sendPostponedMessages ( ) { 
 String [ ] projection = new String [ ] { BaseColumns . _ID , Imps . Messages . BODY , 
 Imps . Messages . PACKET_ID , 
 Imps . Messages . DATE , Imps . Messages . TYPE , } ; 
 String selection = Imps . Messages . TYPE + ""=?"" ; 
 Cursor c = mContentResolver . query ( mMessageURI , projection , selection , 
 new String [ ] { Integer . toString ( Imps . MessageType . POSTPONED ) } , null ) ; 
 if ( c == null ) { 
 RemoteImService . debug ( ""Query error while querying postponed messages"" ) ; 
 return ; 
 } 
 ArrayList < String > messages = new ArrayList < String > ( ) ; 
 while ( c . moveToNext ( ) ) { 
 String body = c . getString ( 1 ) ; 
 messages . add ( body ) ; 
 } 
 c . close ( ) ; 
 removeMessageInDb ( Imps . MessageType . POSTPONED ) ; 
 for ( String body : messages ) 
 sendMessage ( body ) ; 
 }  ",2011/2/3 18:42,2015/8/24 0:37,104,0.767783368741674
582,698,https://www.github.com/yamcs/yamcs,setRequest(ReplayRequest),,161,161,161,161,"TODO delete this entire For, once API in proto removed, instead of deprecated",https://www.github.com/yamcs/yamcs/commit/8f8dcf7322,https://www.github.com/yamcs/yamcs/commit/6d694242ac253878efe97a8cdbfc3193b03dc329,yamcs-core/src/main/java/org/yamcs/archive/YarchReplay.java,"private void setRequest(ReplayRequest newRequest) throws YamcsException {
if(state!=ReplayState.INITIALIZATION && state!=ReplayState.STOPPED) {
throw new YamcsException(""changing the request only supported in the INITIALIZATION and STOPPED states"");
}
if (newRequest.getStart()>newRequest.getStop()) {
log.warn(""throwing new packetexception: stop time has to be greater than start time"");
throw new YamcsException(""stop has to be greater than start"");
}
currentRequest=newRequest;
handlers=new HashMap<ProtoDataType,ReplayHandler>();
// TODO delete this entire For, once API in proto removed, instead of deprecated
for (ProtoDataType rdp : currentRequest.getTypeList()) {
switch (rdp) {
case EVENT:
handlers.put(rdp, new EventReplayHandler());
break;
case TM_PACKET:
handlers.put(rdp, new XtceTmReplayHandler(xtceDb));
break;
case PP:
handlers.put(rdp, new PpReplayHandler(xtceDb));
break;
// Covered by new API
//            case PARAMETER:
//                handlers.put(rdp, new ParameterReplayHandler(instance, xtceDb, ppdb));
//                break;
case CMD_HISTORY:
handlers.put(rdp, new CommandHistoryReplayHandler(instance));
break;
default:
log.debug(""Ignoring request for type ""+rdp);
}
}
if (currentRequest.hasEventRequest())
handlers.put(ProtoDataType.EVENT, new EventReplayHandler());
if (currentRequest.hasPacketRequest())
handlers.put(ProtoDataType.TM_PACKET, new XtceTmReplayHandler(xtceDb));
if (currentRequest.hasPpRequest())
handlers.put(ProtoDataType.PP, new PpReplayHandler(xtceDb));
if (currentRequest.hasParameterRequest())
handlers.put(ProtoDataType.PARAMETER, new ParameterReplayHandler(instance, xtceDb));
if (currentRequest.hasCommandHistoryRequest())
handlers.put(ProtoDataType.CMD_HISTORY, new CommandHistoryReplayHandler(instance));
for(ReplayHandler rh:handlers.values()) {
rh.setRequest(newRequest);
}
}","private void setRequest(ReplayRequest newRequest) throws YamcsException {
if(state!=ReplayState.INITIALIZATION && state!=ReplayState.STOPPED) {
throw new YamcsException(""changing the request only supported in the INITIALIZATION and STOPPED states"");
}
//get the start/stop from utcStart/utcStop
ReplayRequest.Builder b = ReplayRequest.newBuilder(newRequest);
if(!newRequest.hasStart() && newRequest.hasUtcStart()) {
b.setStart(TimeEncoding.parse(newRequest.getUtcStart()));
}
if(!newRequest.hasStop() && newRequest.hasUtcStop()) {
b.setStop(TimeEncoding.parse(newRequest.getUtcStop()));
}
newRequest = b.build();
if (newRequest.getStart()>newRequest.getStop()) {
log.warn(""throwing new packetexception: stop time has to be greater than start time"");
throw new YamcsException(""stop has to be greater than start"");
}
currentRequest=newRequest;
handlers=new HashMap<ProtoDataType,ReplayHandler>();
if (currentRequest.hasEventRequest())
handlers.put(ProtoDataType.EVENT, new EventReplayHandler());
if (currentRequest.hasPacketRequest())
handlers.put(ProtoDataType.TM_PACKET, new XtceTmReplayHandler(xtceDb));
if (currentRequest.hasPpRequest())
handlers.put(ProtoDataType.PP, new PpReplayHandler(xtceDb));
if (currentRequest.hasParameterRequest())
handlers.put(ProtoDataType.PARAMETER, new ParameterReplayHandler(instance, xtceDb));
if (currentRequest.hasCommandHistoryRequest())
handlers.put(ProtoDataType.CMD_HISTORY, new CommandHistoryReplayHandler(instance));
for(ReplayHandler rh:handlers.values()) {
rh.setRequest(newRequest);
}
}","private void setRequest ( ReplayRequest newRequest ) throws YamcsException { 
 if ( state != ReplayState . INITIALIZATION & & state != ReplayState . STOPPED ) { 
 throw new YamcsException ( ""changing the request only supported in the INITIALIZATION and STOPPED states"" ) ; 
 } 
 if ( newRequest . getStart ( ) > newRequest . getStop ( ) ) { 
 log . warn ( ""throwing new packetexception: stop time has to be greater than start time"" ) ; 
 throw new YamcsException ( ""stop has to be greater than start"" ) ; 
 } 
 currentRequest = newRequest ; 
 handlers = new HashMap < ProtoDataType , ReplayHandler > ( ) ; 
 // TODO delete this entire For , once API in proto removed , instead of deprecated 
 for ( ProtoDataType rdp : currentRequest . getTypeList ( ) ) { 
 switch ( rdp ) { 
 case EVENT : 
 handlers . put ( rdp , new EventReplayHandler ( ) ) ; 
 break ; 
 case TM_PACKET : 
 handlers . put ( rdp , new XtceTmReplayHandler ( xtceDb ) ) ; 
 break ; 
 case PP : 
 handlers . put ( rdp , new PpReplayHandler ( xtceDb ) ) ; 
 break ; 
 // Covered by new API 
 // case PARAMETER : 
 // handlers . put ( rdp , new ParameterReplayHandler ( instance , xtceDb , ppdb ) ) ; 
 // break ; 
 case CMD_HISTORY : 
 handlers . put ( rdp , new CommandHistoryReplayHandler ( instance ) ) ; 
 break ; 
 default : 
 log . debug ( ""Ignoring request for type "" + rdp ) ; 
 } 
 } 
 if ( currentRequest . hasEventRequest ( ) ) 
 handlers . put ( ProtoDataType . EVENT , new EventReplayHandler ( ) ) ; 
 if ( currentRequest . hasPacketRequest ( ) ) 
 handlers . put ( ProtoDataType . TM_PACKET , new XtceTmReplayHandler ( xtceDb ) ) ; 
 if ( currentRequest . hasPpRequest ( ) ) 
 handlers . put ( ProtoDataType . PP , new PpReplayHandler ( xtceDb ) ) ; 
 if ( currentRequest . hasParameterRequest ( ) ) 
 handlers . put ( ProtoDataType . PARAMETER , new ParameterReplayHandler ( instance , xtceDb ) ) ; 
 if ( currentRequest . hasCommandHistoryRequest ( ) ) 
 handlers . put ( ProtoDataType . CMD_HISTORY , new CommandHistoryReplayHandler ( instance ) ) ; 
 for ( ReplayHandler rh : handlers . values ( ) ) { 
 rh . setRequest ( newRequest ) ; 
 } 
 }  ","private void setRequest ( ReplayRequest newRequest ) throws YamcsException { 
 if ( state != ReplayState . INITIALIZATION & & state != ReplayState . STOPPED ) { 
 throw new YamcsException ( ""changing the request only supported in the INITIALIZATION and STOPPED states"" ) ; 
 } 
 // get the start / stop from utcStart / utcStop 
 ReplayRequest . Builder b = ReplayRequest . newBuilder ( newRequest ) ; 
 if ( ! newRequest . hasStart ( ) & & newRequest . hasUtcStart ( ) ) { 
 b . setStart ( TimeEncoding . parse ( newRequest . getUtcStart ( ) ) ) ; 
 } 
 if ( ! newRequest . hasStop ( ) & & newRequest . hasUtcStop ( ) ) { 
 b . setStop ( TimeEncoding . parse ( newRequest . getUtcStop ( ) ) ) ; 
 } 
 newRequest = b . build ( ) ; 
 if ( newRequest . getStart ( ) > newRequest . getStop ( ) ) { 
 log . warn ( ""throwing new packetexception: stop time has to be greater than start time"" ) ; 
 throw new YamcsException ( ""stop has to be greater than start"" ) ; 
 } 
 currentRequest = newRequest ; 
 handlers = new HashMap < ProtoDataType , ReplayHandler > ( ) ; 
 if ( currentRequest . hasEventRequest ( ) ) 
 handlers . put ( ProtoDataType . EVENT , new EventReplayHandler ( ) ) ; 
 if ( currentRequest . hasPacketRequest ( ) ) 
 handlers . put ( ProtoDataType . TM_PACKET , new XtceTmReplayHandler ( xtceDb ) ) ; 
 if ( currentRequest . hasPpRequest ( ) ) 
 handlers . put ( ProtoDataType . PP , new PpReplayHandler ( xtceDb ) ) ; 
 if ( currentRequest . hasParameterRequest ( ) ) 
 handlers . put ( ProtoDataType . PARAMETER , new ParameterReplayHandler ( instance , xtceDb ) ) ; 
 if ( currentRequest . hasCommandHistoryRequest ( ) ) 
 handlers . put ( ProtoDataType . CMD_HISTORY , new CommandHistoryReplayHandler ( instance ) ) ; 
 for ( ReplayHandler rh : handlers . values ( ) ) { 
 rh . setRequest ( newRequest ) ; 
 } 
 }  ",2013-07-02 14:25:28 +0200,2015-04-30 12:22:36 +0200,7,0.7481908857825506
45,583,https://www.github.com/cgeo/cgeo,handleMessage(Message),,1227,1227,1227,1227,TODO Parameter Map is bad style,https://www.github.com/cgeo/cgeo/commit/e31b4a577e,https://www.github.com/cgeo/cgeo/commit/179b995d6e4f4a49263ec9aef682ad99bbfb28ce,main/src/cgeo/geocaching/maps/CGeoMap.java,"@Override
public void run() { //first time we enter we have crappy long/lat....
try {
stop = false;
working = true;
if (stop) {
displayHandler.sendEmptyMessage(0);
working = false;
return;
}
double lat1 = (centerLat / 1e6) - ((spanLat / 1e6) / 2) - ((spanLat / 1e6) / 4);
double lat2 = (centerLat / 1e6) + ((spanLat / 1e6) / 2) + ((spanLat / 1e6) / 4);
double lon1 = (centerLon / 1e6) - ((spanLon / 1e6) / 2) - ((spanLon / 1e6) / 4);
double lon2 = (centerLon / 1e6) + ((spanLon / 1e6) / 2) + ((spanLon / 1e6) / 4);
double latMin = Math.min(lat1, lat2);
double latMax = Math.max(lat1, lat2);
double lonMin = Math.min(lon1, lon2);
double lonMax = Math.max(lon1, lon2);
//*** this needs to be in it's own thread
// stage 2 - pull and render from geocaching.com
//this should just fetch and insert into the db _and_ be cancel-able if the viewport changes
if (token == null) {
token = base.getMapUserToken(noMapTokenHandler);
}
if (stop) {
displayHandler.sendEmptyMessage(0);
working = false;
return;
}
//TODO Parameter Map is bad style
Map<String, String> params = new HashMap<String, String>();
params.put(""usertoken"", token);
params.put(""latitude-min"", String.format((Locale) null, ""%.6f"", latMin));
params.put(""latitude-max"", String.format((Locale) null, ""%.6f"", latMax));
params.put(""longitude-min"", String.format((Locale) null, ""%.6f"", lonMin));
params.put(""longitude-max"", String.format((Locale) null, ""%.6f"", lonMax));
searchId = base.searchByViewport(params, 0);
if (searchId != null) {
downloaded = true;
}
if (stop) {
displayHandler.sendEmptyMessage(0);
working = false;
return;
}
//TODO Portree Only overwrite if we got some. Otherwise maybe error icon
caches = app.getCaches(searchId, centerLat, centerLon, spanLat, spanLon);
if (stop) {
displayHandler.sendEmptyMessage(0);
working = false;
return;
}
//render
if (displayThread != null && displayThread.isWorking()) {
displayThread.stopIt();
}
displayThread = new DisplayThread(centerLat, centerLon, spanLat, spanLon);
displayThread.start();
} finally {
working = false;
}
}","@Override
public void run() { //first time we enter we have crappy long/lat....
try {
stop = false;
working = true;
if (stop) {
displayHandler.sendEmptyMessage(0);
working = false;
return;
}
double lat1 = (centerLat / 1e6) - ((spanLat / 1e6) / 2) - ((spanLat / 1e6) / 4);
double lat2 = (centerLat / 1e6) + ((spanLat / 1e6) / 2) + ((spanLat / 1e6) / 4);
double lon1 = (centerLon / 1e6) - ((spanLon / 1e6) / 2) - ((spanLon / 1e6) / 4);
double lon2 = (centerLon / 1e6) + ((spanLon / 1e6) / 2) + ((spanLon / 1e6) / 4);
double latMin = Math.min(lat1, lat2);
double latMax = Math.max(lat1, lat2);
double lonMin = Math.min(lon1, lon2);
double lonMax = Math.max(lon1, lon2);
//*** this needs to be in it's own thread
// stage 2 - pull and render from geocaching.com
//this should just fetch and insert into the db _and_ be cancel-able if the viewport changes
if (token == null) {
token = base.getMapUserToken(noMapTokenHandler);
}
if (stop) {
displayHandler.sendEmptyMessage(0);
working = false;
return;
}
searchId = base.searchByViewport(token, latMin, latMax, lonMin, lonMax, 0);
if (searchId != null) {
downloaded = true;
}
if (stop) {
displayHandler.sendEmptyMessage(0);
working = false;
return;
}
//TODO Portree Only overwrite if we got some. Otherwise maybe error icon
caches = app.getCaches(searchId, centerLat, centerLon, spanLat, spanLon);
if (stop) {
displayHandler.sendEmptyMessage(0);
working = false;
return;
}
//render
if (displayThread != null && displayThread.isWorking()) {
displayThread.stopIt();
}
displayThread = new DisplayThread(centerLat, centerLon, spanLat, spanLon);
displayThread.start();
} finally {
working = false;
}
}","@ Override 
 public void run ( ) { // first time we enter we have crappy long / lat ... . 
 try { 
 stop = false ; 
 working = true ; 
 if ( stop ) { 
 displayHandler . sendEmptyMessage ( 0 ) ; 
 working = false ; 
 return ; 
 } 
 double lat1 = ( centerLat / 1e6 ) - ( ( spanLat / 1e6 ) / 2 ) - ( ( spanLat / 1e6 ) / 4 ) ; 
 double lat2 = ( centerLat / 1e6 ) + ( ( spanLat / 1e6 ) / 2 ) + ( ( spanLat / 1e6 ) / 4 ) ; 
 double lon1 = ( centerLon / 1e6 ) - ( ( spanLon / 1e6 ) / 2 ) - ( ( spanLon / 1e6 ) / 4 ) ; 
 double lon2 = ( centerLon / 1e6 ) + ( ( spanLon / 1e6 ) / 2 ) + ( ( spanLon / 1e6 ) / 4 ) ; 
 double latMin = Math . min ( lat1 , lat2 ) ; 
 double latMax = Math . max ( lat1 , lat2 ) ; 
 double lonMin = Math . min ( lon1 , lon2 ) ; 
 double lonMax = Math . max ( lon1 , lon2 ) ; 
 // ** * this needs to be in it ' s own thread 
 // stage 2 - pull and render from geocaching . com 
 // this should just fetch and insert into the db _and_ be cancel - able if the viewport changes 
 if ( token == null ) { 
 token = base . getMapUserToken ( noMapTokenHandler ) ; 
 } 
 if ( stop ) { 
 displayHandler . sendEmptyMessage ( 0 ) ; 
 working = false ; 
 return ; 
 } 
 // TODO Parameter Map is bad style 
 Map < String , String > params = new HashMap < String , String > ( ) ; 
 params . put ( ""usertoken"" , token ) ; 
 params . put ( ""latitude-min"" , String . format ( ( Locale ) null , ""%.6f"" , latMin ) ) ; 
 params . put ( ""latitude-max"" , String . format ( ( Locale ) null , ""%.6f"" , latMax ) ) ; 
 params . put ( ""longitude-min"" , String . format ( ( Locale ) null , ""%.6f"" , lonMin ) ) ; 
 params . put ( ""longitude-max"" , String . format ( ( Locale ) null , ""%.6f"" , lonMax ) ) ; 
 searchId = base . searchByViewport ( params , 0 ) ; 
 if ( searchId != null ) { 
 downloaded = true ; 
 } 
 if ( stop ) { 
 displayHandler . sendEmptyMessage ( 0 ) ; 
 working = false ; 
 return ; 
 } 
 // TODO Portree Only overwrite if we got some . Otherwise maybe error icon 
 caches = app . getCaches ( searchId , centerLat , centerLon , spanLat , spanLon ) ; 
 if ( stop ) { 
 displayHandler . sendEmptyMessage ( 0 ) ; 
 working = false ; 
 return ; 
 } 
 // render 
 if ( displayThread != null & & displayThread . isWorking ( ) ) { 
 displayThread . stopIt ( ) ; 
 } 
 displayThread = new DisplayThread ( centerLat , centerLon , spanLat , spanLon ) ; 
 displayThread . start ( ) ; 
 } finally { 
 working = false ; 
 } 
 }  ","@ Override 
 public void run ( ) { // first time we enter we have crappy long / lat ... . 
 try { 
 stop = false ; 
 working = true ; 
 if ( stop ) { 
 displayHandler . sendEmptyMessage ( 0 ) ; 
 working = false ; 
 return ; 
 } 
 double lat1 = ( centerLat / 1e6 ) - ( ( spanLat / 1e6 ) / 2 ) - ( ( spanLat / 1e6 ) / 4 ) ; 
 double lat2 = ( centerLat / 1e6 ) + ( ( spanLat / 1e6 ) / 2 ) + ( ( spanLat / 1e6 ) / 4 ) ; 
 double lon1 = ( centerLon / 1e6 ) - ( ( spanLon / 1e6 ) / 2 ) - ( ( spanLon / 1e6 ) / 4 ) ; 
 double lon2 = ( centerLon / 1e6 ) + ( ( spanLon / 1e6 ) / 2 ) + ( ( spanLon / 1e6 ) / 4 ) ; 
 double latMin = Math . min ( lat1 , lat2 ) ; 
 double latMax = Math . max ( lat1 , lat2 ) ; 
 double lonMin = Math . min ( lon1 , lon2 ) ; 
 double lonMax = Math . max ( lon1 , lon2 ) ; 
 // ** * this needs to be in it ' s own thread 
 // stage 2 - pull and render from geocaching . com 
 // this should just fetch and insert into the db _and_ be cancel - able if the viewport changes 
 if ( token == null ) { 
 token = base . getMapUserToken ( noMapTokenHandler ) ; 
 } 
 if ( stop ) { 
 displayHandler . sendEmptyMessage ( 0 ) ; 
 working = false ; 
 return ; 
 } 
 searchId = base . searchByViewport ( token , latMin , latMax , lonMin , lonMax , 0 ) ; 
 if ( searchId != null ) { 
 downloaded = true ; 
 } 
 if ( stop ) { 
 displayHandler . sendEmptyMessage ( 0 ) ; 
 working = false ; 
 return ; 
 } 
 // TODO Portree Only overwrite if we got some . Otherwise maybe error icon 
 caches = app . getCaches ( searchId , centerLat , centerLon , spanLat , spanLon ) ; 
 if ( stop ) { 
 displayHandler . sendEmptyMessage ( 0 ) ; 
 working = false ; 
 return ; 
 } 
 // render 
 if ( displayThread != null & & displayThread . isWorking ( ) ) { 
 displayThread . stopIt ( ) ; 
 } 
 displayThread = new DisplayThread ( centerLat , centerLon , spanLat , spanLon ) ; 
 displayThread . start ( ) ; 
 } finally { 
 working = false ; 
 } 
 }  ",2011-09-23 14:42:46 +0200,2011-09-29 11:33:57 +0200,1,0.9088758828062814
