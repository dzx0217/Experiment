uuid,p_id,project,method,satd_type,start_line_before,end_line_before,start_line_after,end_line_after,comment,commit_before,commit_after,file_path,function_before,function_after,function_before_tokenized,function_after_tokenized,commit_before_time,commit_after_time,survive_time,comment_type
722,508,https://www.github.com/impetus/kundera,test(),,95,95,98,98,TODO: This needs to fixed. There is an issue(runtime error) with proxy.remove(). Amresh need to fix it.,https://www.github.com/impetus/kundera/commit/9f7cd18696,https://www.github.com/impetus/kundera/commit/2c8c0d9d9b610d730daf96f151e51bf4178194b9,src/jpa-engine/core/src/test/java/com/impetus/kundera/proxy/collection/ProxySetTest.java,"@Test
public void test() throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException
{
AddressEntity p = new AddressEntity();
AddressEntity subaddress = new AddressEntity();
Set<AddressEntity> subaddresses = new HashSet<AddressEntity>(1);
subaddresses.add(subaddress);
p.setSubaddresses(subaddresses);
Relation relation = new Relation(AddressEntity.class.getDeclaredField(""subaddresses""), AddressEntity.class,
                Set.class, FetchType.LAZY, null, false, null, ForeignKey.ONE_TO_MANY);
PersistenceDelegator delegator = CoreTestUtilities.getDelegator(em);
ProxySet proxySet = new ProxySet(delegator, relation);
proxySet.setOwner(p);
proxySet.add(p);
Assert.assertTrue(proxySet.contains(p));
Assert.assertEquals(p, proxySet.getOwner());
Assert.assertNotNull(proxySet.getDataCollection());
Assert.assertNotNull(proxySet.getRelation());
Assert.assertEquals(relation, proxySet.getRelation());
Assert.assertEquals(delegator, proxySet.getPersistenceDelegator());
Assert.assertNotNull(proxySet.getCopy());
Assert.assertEquals(proxySet.getRelation(),proxySet.getCopy().getRelation());
proxySet.addAll(subaddresses);
Assert.assertNotNull(proxySet.getDataCollection());
Assert.assertEquals(2, ((Collection)proxySet.getDataCollection()).size());
Assert.assertTrue(proxySet.contains(p));
Assert.assertTrue(proxySet.containsAll(subaddresses));
// TODO: This needs to fixed. There is an issue(runtime error) with proxy.remove(). Amresh need to fix it.
//        proxySet.remove(p);
//        Assert.assertNotNull(proxySet.getDataCollection());
//        Assert.assertEquals(1,proxySet.getDataCollection().size());
//
//        proxySet.removeAll(subaddresses);
//        Assert.assertNull(proxySet.getDataCollection());
proxySet.retainAll(subaddresses);
Assert.assertNotNull(proxySet.getDataCollection());
Assert.assertEquals(2, ((Collection)proxySet.getDataCollection()).size());
Iterator<AddressEntity> iter = proxySet.iterator();
int counter=0;
while(iter.hasNext())
{
Assert.assertNotNull(iter.next());
++counter;
}
Assert.assertEquals(2, counter);
Assert.assertNotNull(proxySet.toArray());
Assert.assertEquals(2, proxySet.toArray().length);
Assert.assertEquals(2, proxySet.size());
proxySet.remove(p);
Assert.assertNotNull(proxySet.getDataCollection());
Assert.assertEquals(1,proxySet.size());
proxySet.removeAll(subaddresses);
Assert.assertNull(proxySet.getDataCollection());
proxySet.clear();
Assert.assertTrue(proxySet.isEmpty());
}","@Test
public void test() throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException
{
AddressEntity p = new AddressEntity();
AddressEntity subaddress = new AddressEntity();
Set<AddressEntity> subaddresses = new HashSet<AddressEntity>(1);
subaddresses.add(subaddress);
p.setSubaddresses(subaddresses);
Relation relation = new Relation(AddressEntity.class.getDeclaredField(""subaddresses""), AddressEntity.class,
                Set.class, FetchType.LAZY, null, false, null, ForeignKey.ONE_TO_MANY);
PersistenceDelegator delegator = CoreTestUtilities.getDelegator(em);
ProxySet proxySet = new ProxySet(delegator, relation);
proxySet.setOwner(p);
proxySet.add(p);
Assert.assertTrue(proxySet.contains(p));
Assert.assertEquals(p, proxySet.getOwner());
Assert.assertNotNull(proxySet.getDataCollection());
Assert.assertNotNull(proxySet.getRelation());
Assert.assertEquals(relation, proxySet.getRelation());
Assert.assertEquals(delegator, proxySet.getPersistenceDelegator());
Assert.assertNotNull(proxySet.getCopy());
Assert.assertEquals(proxySet.getRelation(), proxySet.getCopy().getRelation());
proxySet.addAll(subaddresses);
Assert.assertNotNull(proxySet.getDataCollection());
Assert.assertEquals(2, ((Collection) proxySet.getDataCollection()).size());
Assert.assertTrue(proxySet.contains(p));
Assert.assertTrue(proxySet.containsAll(subaddresses));
// TODO: This needs to fixed. There is an issue(runtime error) with
// proxy.remove(). Amresh need to fix it.
// proxySet.remove(p);
// Assert.assertNotNull(proxySet.getDataCollection());
// Assert.assertEquals(1,proxySet.getDataCollection().size());
//
// proxySet.removeAll(subaddresses);
// Assert.assertNull(proxySet.getDataCollection());
proxySet.retainAll(subaddresses);
Assert.assertNotNull(proxySet.getDataCollection());
Assert.assertEquals(2, ((Collection) proxySet.getDataCollection()).size());
Iterator<AddressEntity> iter = proxySet.iterator();
int counter = 0;
while (iter.hasNext())
{
Assert.assertNotNull(iter.next());
++counter;
}
Assert.assertEquals(2, counter);
Assert.assertNotNull(proxySet.toArray());
Assert.assertEquals(2, proxySet.toArray().length);
Assert.assertEquals(2, proxySet.size());
proxySet.remove(p);
Assert.assertNotNull(proxySet.getDataCollection());
Assert.assertEquals(1, proxySet.size());
proxySet.removeAll(subaddresses);
Assert.assertNotNull(proxySet.getDataCollection());
Assert.assertTrue(((HashSet)proxySet.getDataCollection()).isEmpty());
proxySet.clear();
Assert.assertTrue(proxySet.isEmpty());
}","@ Test public void test  ( ) throws NoSuchFieldException , SecurityException , IllegalArgumentException , IllegalAccessException  { AddressEntity p = new AddressEntity ( ) ; AddressEntity subaddress = new AddressEntity ( ) ; Set < AddressEntity > subaddresses = new HashSet < AddressEntity > ( 1 ) ; subaddresses . add ( subaddress ) ; p . setSubaddresses ( subaddresses ) ; Relation relation = new Relation ( AddressEntity . class . getDeclaredField ( "" subaddresses "" ) , AddressEntity . class , Set . class , FetchType . LAZY , null , false , null , ForeignKey . ONE_TO_MANY ) ; PersistenceDelegator delegator = CoreTestUtilities . getDelegator ( em ) ; ProxySet proxySet = new ProxySet ( delegator , relation ) ; proxySet . setOwner ( p ) ; proxySet . add ( p ) ; Assert . assertTrue ( proxySet . contains ( p ) ) ; Assert . assertEquals ( p , proxySet . getOwner ( ) ) ; Assert . assertNotNull ( proxySet . getDataCollection ( ) ) ; Assert . assertNotNull ( proxySet . getRelation ( ) ) ; Assert . assertEquals ( relation , proxySet . getRelation ( ) ) ; Assert . assertEquals ( delegator , proxySet . getPersistenceDelegator ( ) ) ; Assert . assertNotNull ( proxySet . getCopy ( ) ) ; Assert . assertEquals ( proxySet . getRelation ( ) , proxySet . getCopy ( ) . getRelation ( ) ) ; proxySet . addAll ( subaddresses ) ; Assert . assertNotNull ( proxySet . getDataCollection ( ) ) ; Assert . assertEquals ( 2 , ( ( Collection ) proxySet . getDataCollection ( ) ) . size ( ) ) ; Assert . assertTrue ( proxySet . contains ( p ) ) ; Assert . assertTrue ( proxySet . containsAll ( subaddresses ) ) ; // <SATD_START> TODO: This needs to fixed. There is an issue(runtime error) with proxy.remove(). Amresh need to fix it. <SATD_END> //        proxySet.remove(p); //        Assert.assertNotNull(proxySet.getDataCollection()); //        Assert.assertEquals(1,proxySet.getDataCollection().size()); // //        proxySet.removeAll(subaddresses); //        Assert.assertNull(proxySet.getDataCollection()); proxySet . retainAll ( subaddresses ) ; Assert . assertNotNull ( proxySet . getDataCollection ( ) ) ; Assert . assertEquals ( 2 , ( ( Collection ) proxySet . getDataCollection ( ) ) . size ( ) ) ; Iterator < AddressEntity > iter = proxySet . iterator ( ) ; int counter = 0 ; while ( iter . hasNext ( ) ) { Assert . assertNotNull ( iter . next ( ) ) ; ++ counter ; } Assert . assertEquals ( 2 , counter ) ; Assert . assertNotNull ( proxySet . toArray ( ) ) ; Assert . assertEquals ( 2 , proxySet . toArray ( ) . length ) ; Assert . assertEquals ( 2 , proxySet . size ( ) ) ; proxySet . remove ( p ) ; Assert . assertNotNull ( proxySet . getDataCollection ( ) ) ; Assert . assertEquals ( 1 , proxySet . size ( ) ) ; proxySet . removeAll ( subaddresses ) ; Assert . assertNull ( proxySet . getDataCollection ( ) ) ; proxySet . clear ( ) ; Assert . assertTrue ( proxySet . isEmpty ( ) ) ; }","@ Test public void test  ( ) throws NoSuchFieldException , SecurityException , IllegalArgumentException , IllegalAccessException  { AddressEntity p = new AddressEntity ( ) ; AddressEntity subaddress = new AddressEntity ( ) ; Set < AddressEntity > subaddresses = new HashSet < AddressEntity > ( 1 ) ; subaddresses . add ( subaddress ) ; p . setSubaddresses ( subaddresses ) ; Relation relation = new Relation ( AddressEntity . class . getDeclaredField ( "" subaddresses "" ) , AddressEntity . class , Set . class , FetchType . LAZY , null , false , null , ForeignKey . ONE_TO_MANY ) ; PersistenceDelegator delegator = CoreTestUtilities . getDelegator ( em ) ; ProxySet proxySet = new ProxySet ( delegator , relation ) ; proxySet . setOwner ( p ) ; proxySet . add ( p ) ; Assert . assertTrue ( proxySet . contains ( p ) ) ; Assert . assertEquals ( p , proxySet . getOwner ( ) ) ; Assert . assertNotNull ( proxySet . getDataCollection ( ) ) ; Assert . assertNotNull ( proxySet . getRelation ( ) ) ; Assert . assertEquals ( relation , proxySet . getRelation ( ) ) ; Assert . assertEquals ( delegator , proxySet . getPersistenceDelegator ( ) ) ; Assert . assertNotNull ( proxySet . getCopy ( ) ) ; Assert . assertEquals ( proxySet . getRelation ( ) , proxySet . getCopy ( ) . getRelation ( ) ) ; proxySet . addAll ( subaddresses ) ; Assert . assertNotNull ( proxySet . getDataCollection ( ) ) ; Assert . assertEquals ( 2 , ( ( Collection ) proxySet . getDataCollection ( ) ) . size ( ) ) ; Assert . assertTrue ( proxySet . contains ( p ) ) ; Assert . assertTrue ( proxySet . containsAll ( subaddresses ) ) ; // TODO: This needs to fixed. There is an issue(runtime error) with // proxy.remove(). Amresh need to fix it. // proxySet.remove(p); // Assert.assertNotNull(proxySet.getDataCollection()); // Assert.assertEquals(1,proxySet.getDataCollection().size()); // // proxySet.removeAll(subaddresses); // Assert.assertNull(proxySet.getDataCollection()); proxySet . retainAll ( subaddresses ) ; Assert . assertNotNull ( proxySet . getDataCollection ( ) ) ; Assert . assertEquals ( 2 , ( ( Collection ) proxySet . getDataCollection ( ) ) . size ( ) ) ; Iterator < AddressEntity > iter = proxySet . iterator ( ) ; int counter = 0 ; while ( iter . hasNext ( ) ) { Assert . assertNotNull ( iter . next ( ) ) ; ++ counter ; } Assert . assertEquals ( 2 , counter ) ; Assert . assertNotNull ( proxySet . toArray ( ) ) ; Assert . assertEquals ( 2 , proxySet . toArray ( ) . length ) ; Assert . assertEquals ( 2 , proxySet . size ( ) ) ; proxySet . remove ( p ) ; Assert . assertNotNull ( proxySet . getDataCollection ( ) ) ; Assert . assertEquals ( 1 , proxySet . size ( ) ) ; proxySet . removeAll ( subaddresses ) ; Assert . assertNotNull ( proxySet . getDataCollection ( ) ) ; Assert . assertTrue ( ( ( HashSet ) proxySet . getDataCollection ( ) ) . isEmpty ( ) ) ; proxySet . clear ( ) ; Assert . assertTrue ( proxySet . isEmpty ( ) ) ; }",2013-09-22 20:02:59 +0530,2014-08-01 13:22:50 +0530,9,Exclamatory
1065,38,https://www.github.com/freenet/fred,registerKnownLocation(double),,1043,1043,1043,1043,FIXME: The TreeMap size will keep on increasing...,https://www.github.com/freenet/fred/commit/9b16ca5825a,https://www.github.com/freenet/fred/commit/c0d83924a661272b056a58e5a37a1e6742743331,src/freenet/node/LocationManager.java,"void registerKnownLocation(double d) {
if(logMINOR) Logger.minor(this, ""Known Location: ""+d);
Double dd = new Double(d);
Date timestamp = new Date();
Long longTime = new Long(timestamp.getTime());
synchronized(knownLocs) {
// FIXME: The TreeMap size will keep on increasing...
// knownLocs.values().remove(dd); would be costy
// Maybe the best solution is to do a 
// knownLocs = knownLocs.headMap(longTime - arbitrary_value)
//Add the location to the map with the current timestamp as key
knownLocs.put(longTime, dd);
}
if(logMINOR) Logger.minor(this, ""Estimated net size(session): ""+knownLocs.size());
}","void registerKnownLocation(double d) {
if(logMINOR) Logger.minor(this, ""Known Location: ""+d);
Double dd = new Double(d);
long now = System.currentTimeMillis();
synchronized(knownLocs) {
Logger.minor(this, ""Adding location ""+dd+"" knownLocs size ""+knownLocs.size());
knownLocs.push(dd, now);
Logger.minor(this, ""Added location ""+dd+"" knownLocs size ""+knownLocs.size());
knownLocs.removeBefore(now - MAX_AGE);
Logger.minor(this, ""Added and pruned location ""+dd+"" knownLocs size ""+knownLocs.size());
}
if(logMINOR) Logger.minor(this, ""Estimated net size(session): ""+knownLocs.size());
}","void registerKnownLocation  ( double d ) { if ( logMINOR ) Logger . minor ( this , "" Known Location:  "" + d ) ; Double dd = new Double ( d ) ; Date timestamp = new Date ( ) ; Long longTime = new Long ( timestamp . getTime ( ) ) ; synchronized ( knownLocs ) { // <SATD_START> FIXME: The TreeMap size will keep on increasing... <SATD_END> // knownLocs.values().remove(dd); would be costy // Maybe the best solution is to do a  // knownLocs = knownLocs.headMap(longTime - arbitrary_value) //Add the location to the map with the current timestamp as key knownLocs . put ( longTime , dd ) ; } if ( logMINOR ) Logger . minor ( this , "" Estimated net size(session):  "" + knownLocs . size ( ) ) ; }","void registerKnownLocation  ( double d ) { if ( logMINOR ) Logger . minor ( this , "" Known Location:  "" + d ) ; Double dd = new Double ( d ) ; long now = System . currentTimeMillis ( ) ; synchronized ( knownLocs ) { Logger . minor ( this , "" Adding location  "" + dd + ""  knownLocs size  "" + knownLocs . size ( ) ) ; knownLocs . push ( dd , now ) ; Logger . minor ( this , "" Added location  "" + dd + ""  knownLocs size  "" + knownLocs . size ( ) ) ; knownLocs . removeBefore ( now - MAX_AGE ) ; Logger . minor ( this , "" Added and pruned location  "" + dd + ""  knownLocs size  "" + knownLocs . size ( ) ) ; } if ( logMINOR ) Logger . minor ( this , "" Estimated net size(session):  "" + knownLocs . size ( ) ) ; }",2007-03-08 12:55:27 +0000,2007-03-09 02:28:26 +0000,1,Other
3200,13,https://www.github.com/aosp-mirror/platform_packages_apps_settings,"onActivityResult(int, int, Intent)",,371,371,371,371,TODO (clchen): Add these extras to TextToSpeech.Engine,https://www.github.com/aosp-mirror/platform_packages_apps_settings/commit/c8298717bc3b,https://www.github.com/aosp-mirror/platform_packages_apps_settings/commit/510bc4a2c3470e3f47e6bbc5417051dd442e7664,src/com/android/settings/TextToSpeechSettings.java,"protected void onActivityResult(int requestCode, int resultCode, Intent data) {
if (requestCode == VOICE_DATA_INTEGRITY_CHECK) {
if (data == null){
// The CHECK_TTS_DATA activity for the plugin did not run properly;
// disable the preview and install controls and return.
mEnableDemo = false;
mVoicesMissing = false;
updateWidgetState();
return;
}
// TODO (clchen): Add these extras to TextToSpeech.Engine
ArrayList<String> available =
                    data.getStringArrayListExtra(""TextToSpeech.Engine.EXTRA_AVAILABLE_VOICES"");
ArrayList<String> unavailable =
                    data.getStringArrayListExtra(""TextToSpeech.Engine.EXTRA_UNAVAILABLE_VOICES"");
if ((available == null) || (unavailable == null)){
// The CHECK_TTS_DATA activity for the plugin did not run properly;
// disable the preview and install controls and return.
mEnableDemo = false;
mVoicesMissing = false;
updateWidgetState();
return;
}
if (available.size() > 0){
if (mTts == null) {
mTts = new TextToSpeech(this, this);
}
ListPreference ttsLanguagePref =
                        (ListPreference) findPreference(""tts_default_lang"");
CharSequence[] entries = new CharSequence[available.size()];
CharSequence[] entryValues = new CharSequence[available.size()];
for (int i=0; i<available.size(); i++){
String[] langCountryVariant = available.get(i).split(""-"");
Locale loc = null;
if (langCountryVariant.length == 1){
loc = new Locale(langCountryVariant[0]);
} else if (langCountryVariant.length == 2){
loc = new Locale(langCountryVariant[0], langCountryVariant[1]);
} else if (langCountryVariant.length == 3){
loc = new Locale(langCountryVariant[0], langCountryVariant[1],
                                         langCountryVariant[2]);
}
if (loc != null){
entries[i] = loc.getDisplayName();
entryValues[i] = available.get(i);
}
}
ttsLanguagePref.setEntries(entries);
ttsLanguagePref.setEntryValues(entryValues);
mEnableDemo = true;
// Make sure that the default language can be used.
int languageResult = mTts.setLanguage(
                        new Locale(mDefaultLanguage, mDefaultCountry, mDefaultLocVariant));
if (languageResult < TextToSpeech.LANG_AVAILABLE){
Locale currentLocale = Locale.getDefault();
mDefaultLanguage = currentLocale.getISO3Language();
mDefaultCountry = currentLocale.getISO3Country();
mDefaultLocVariant = currentLocale.getVariant();
languageResult = mTts.setLanguage(
                            new Locale(mDefaultLanguage, mDefaultCountry, mDefaultLocVariant));
// If the default Locale isn't supported, just choose the first available
// language so that there is at least something.
if (languageResult < TextToSpeech.LANG_AVAILABLE){
parseLocaleInfo(ttsLanguagePref.getEntryValues()[0].toString());
mTts.setLanguage(
                                new Locale(mDefaultLanguage, mDefaultCountry, mDefaultLocVariant));
}
ContentResolver resolver = getContentResolver();
Settings.Secure.putString(resolver, TTS_DEFAULT_LANG, mDefaultLanguage);
Settings.Secure.putString(resolver, TTS_DEFAULT_COUNTRY, mDefaultCountry);
Settings.Secure.putString(resolver, TTS_DEFAULT_VARIANT, mDefaultLocVariant);
}
} else {
mEnableDemo = false;
}
if (unavailable.size() > 0){
mVoicesMissing = true;
} else {
mVoicesMissing = false;
}
updateWidgetState();
} else if (requestCode == GET_SAMPLE_TEXT) {
if (resultCode == TextToSpeech.LANG_AVAILABLE) {
String sample = getString(R.string.tts_demo);
if ((data != null) && (data.getStringExtra(""sampleText"") != null)) {
sample = data.getStringExtra(""sampleText"");
}
if (mTts != null) {
mTts.speak(sample, TextToSpeech.QUEUE_FLUSH, null);
}
} else {
// TODO: Display an error here to the user.
Log.e(TAG, ""Did not have a sample string for the requested language"");
}
}
}","protected void onActivityResult(int requestCode, int resultCode, Intent data) {
if (requestCode == VOICE_DATA_INTEGRITY_CHECK) {
if (data == null){
// The CHECK_TTS_DATA activity for the plugin did not run properly;
// disable the preview and install controls and return.
mEnableDemo = false;
mVoicesMissing = false;
updateWidgetState();
return;
}
ArrayList<String> available =
                    data.getStringArrayListExtra(TextToSpeech.Engine.EXTRA_AVAILABLE_VOICES);
ArrayList<String> unavailable =
                    data.getStringArrayListExtra(TextToSpeech.Engine.EXTRA_UNAVAILABLE_VOICES);
if ((available == null) || (unavailable == null)){
// The CHECK_TTS_DATA activity for the plugin did not run properly;
// disable the preview and install controls and return.
mEnableDemo = false;
mVoicesMissing = false;
updateWidgetState();
return;
}
if (available.size() > 0){
if (mTts == null) {
mTts = new TextToSpeech(this, this);
}
ListPreference ttsLanguagePref =
                        (ListPreference) findPreference(""tts_default_lang"");
CharSequence[] entries = new CharSequence[available.size()];
CharSequence[] entryValues = new CharSequence[available.size()];
for (int i=0; i<available.size(); i++){
String[] langCountryVariant = available.get(i).split(""-"");
Locale loc = null;
if (langCountryVariant.length == 1){
loc = new Locale(langCountryVariant[0]);
} else if (langCountryVariant.length == 2){
loc = new Locale(langCountryVariant[0], langCountryVariant[1]);
} else if (langCountryVariant.length == 3){
loc = new Locale(langCountryVariant[0], langCountryVariant[1],
                                         langCountryVariant[2]);
}
if (loc != null){
entries[i] = loc.getDisplayName();
entryValues[i] = available.get(i);
}
}
ttsLanguagePref.setEntries(entries);
ttsLanguagePref.setEntryValues(entryValues);
mEnableDemo = true;
// Make sure that the default language can be used.
int languageResult = mTts.setLanguage(
                        new Locale(mDefaultLanguage, mDefaultCountry, mDefaultLocVariant));
if (languageResult < TextToSpeech.LANG_AVAILABLE){
Locale currentLocale = Locale.getDefault();
mDefaultLanguage = currentLocale.getISO3Language();
mDefaultCountry = currentLocale.getISO3Country();
mDefaultLocVariant = currentLocale.getVariant();
languageResult = mTts.setLanguage(
                            new Locale(mDefaultLanguage, mDefaultCountry, mDefaultLocVariant));
// If the default Locale isn't supported, just choose the first available
// language so that there is at least something.
if (languageResult < TextToSpeech.LANG_AVAILABLE){
parseLocaleInfo(ttsLanguagePref.getEntryValues()[0].toString());
mTts.setLanguage(
                                new Locale(mDefaultLanguage, mDefaultCountry, mDefaultLocVariant));
}
ContentResolver resolver = getContentResolver();
Settings.Secure.putString(resolver, TTS_DEFAULT_LANG, mDefaultLanguage);
Settings.Secure.putString(resolver, TTS_DEFAULT_COUNTRY, mDefaultCountry);
Settings.Secure.putString(resolver, TTS_DEFAULT_VARIANT, mDefaultLocVariant);
}
} else {
mEnableDemo = false;
}
if (unavailable.size() > 0){
mVoicesMissing = true;
} else {
mVoicesMissing = false;
}
updateWidgetState();
} else if (requestCode == GET_SAMPLE_TEXT) {
if (resultCode == TextToSpeech.LANG_AVAILABLE) {
String sample = getString(R.string.tts_demo);
if ((data != null) && (data.getStringExtra(""sampleText"") != null)) {
sample = data.getStringExtra(""sampleText"");
}
if (mTts != null) {
mTts.speak(sample, TextToSpeech.QUEUE_FLUSH, null);
}
} else {
// TODO: Display an error here to the user.
Log.e(TAG, ""Did not have a sample string for the requested language"");
}
}
}","protected void onActivityResult  ( int requestCode , int resultCode , Intent data ) { if ( requestCode == VOICE_DATA_INTEGRITY_CHECK ) { if ( data == null ) { // The CHECK_TTS_DATA activity for the plugin did not run properly; // disable the preview and install controls and return. mEnableDemo = false ; mVoicesMissing = false ; updateWidgetState ( ) ; return ; } // <SATD_START> TODO (clchen): Add these extras to TextToSpeech.Engine <SATD_END> ArrayList < String > available = data . getStringArrayListExtra ( "" TextToSpeech.Engine.EXTRA_AVAILABLE_VOICES "" ) ; ArrayList < String > unavailable = data . getStringArrayListExtra ( "" TextToSpeech.Engine.EXTRA_UNAVAILABLE_VOICES "" ) ; if ( ( available == null ) || ( unavailable == null ) ) { // The CHECK_TTS_DATA activity for the plugin did not run properly; // disable the preview and install controls and return. mEnableDemo = false ; mVoicesMissing = false ; updateWidgetState ( ) ; return ; } if ( available . size ( ) > 0 ) { if ( mTts == null ) { mTts = new TextToSpeech ( this , this ) ; } ListPreference ttsLanguagePref = ( ListPreference ) findPreference ( "" tts_default_lang "" ) ; CharSequence [ ] entries = new CharSequence [ available . size ( ) ] ; CharSequence [ ] entryValues = new CharSequence [ available . size ( ) ] ; for ( int i = 0 ; i < available . size ( ) ; i ++ ) { String [ ] langCountryVariant = available . get ( i ) . split ( "" - "" ) ; Locale loc = null ; if ( langCountryVariant . length == 1 ) { loc = new Locale ( langCountryVariant [ 0 ] ) ; } else if ( langCountryVariant . length == 2 ) { loc = new Locale ( langCountryVariant [ 0 ] , langCountryVariant [ 1 ] ) ; } else if ( langCountryVariant . length == 3 ) { loc = new Locale ( langCountryVariant [ 0 ] , langCountryVariant [ 1 ] , langCountryVariant [ 2 ] ) ; } if ( loc != null ) { entries [ i ] = loc . getDisplayName ( ) ; entryValues [ i ] = available . get ( i ) ; } } ttsLanguagePref . setEntries ( entries ) ; ttsLanguagePref . setEntryValues ( entryValues ) ; mEnableDemo = true ; // Make sure that the default language can be used. int languageResult = mTts . setLanguage ( new Locale ( mDefaultLanguage , mDefaultCountry , mDefaultLocVariant ) ) ; if ( languageResult < TextToSpeech . LANG_AVAILABLE ) { Locale currentLocale = Locale . getDefault ( ) ; mDefaultLanguage = currentLocale . getISO3Language ( ) ; mDefaultCountry = currentLocale . getISO3Country ( ) ; mDefaultLocVariant = currentLocale . getVariant ( ) ; languageResult = mTts . setLanguage ( new Locale ( mDefaultLanguage , mDefaultCountry , mDefaultLocVariant ) ) ; // If the default Locale isn't supported, just choose the first available // language so that there is at least something. if ( languageResult < TextToSpeech . LANG_AVAILABLE ) { parseLocaleInfo ( ttsLanguagePref . getEntryValues ( ) [ 0 ] . toString ( ) ) ; mTts . setLanguage ( new Locale ( mDefaultLanguage , mDefaultCountry , mDefaultLocVariant ) ) ; } ContentResolver resolver = getContentResolver ( ) ; Settings . Secure . putString ( resolver , TTS_DEFAULT_LANG , mDefaultLanguage ) ; Settings . Secure . putString ( resolver , TTS_DEFAULT_COUNTRY , mDefaultCountry ) ; Settings . Secure . putString ( resolver , TTS_DEFAULT_VARIANT , mDefaultLocVariant ) ; } } else { mEnableDemo = false ; } if ( unavailable . size ( ) > 0 ) { mVoicesMissing = true ; } else { mVoicesMissing = false ; } updateWidgetState ( ) ; } else if ( requestCode == GET_SAMPLE_TEXT ) { if ( resultCode == TextToSpeech . LANG_AVAILABLE ) { String sample = getString ( R . string . tts_demo ) ; if ( ( data != null ) && ( data . getStringExtra ( "" sampleText "" ) != null ) ) { sample = data . getStringExtra ( "" sampleText "" ) ; } if ( mTts != null ) { mTts . speak ( sample , TextToSpeech . QUEUE_FLUSH , null ) ; } } else { // TODO: Display an error here to the user. Log . e ( TAG , "" Did not have a sample string for the requested language "" ) ; } } }","protected void onActivityResult  ( int requestCode , int resultCode , Intent data ) { if ( requestCode == VOICE_DATA_INTEGRITY_CHECK ) { if ( data == null ) { // The CHECK_TTS_DATA activity for the plugin did not run properly; // disable the preview and install controls and return. mEnableDemo = false ; mVoicesMissing = false ; updateWidgetState ( ) ; return ; } ArrayList < String > available = data . getStringArrayListExtra ( TextToSpeech . Engine . EXTRA_AVAILABLE_VOICES ) ; ArrayList < String > unavailable = data . getStringArrayListExtra ( TextToSpeech . Engine . EXTRA_UNAVAILABLE_VOICES ) ; if ( ( available == null ) || ( unavailable == null ) ) { // The CHECK_TTS_DATA activity for the plugin did not run properly; // disable the preview and install controls and return. mEnableDemo = false ; mVoicesMissing = false ; updateWidgetState ( ) ; return ; } if ( available . size ( ) > 0 ) { if ( mTts == null ) { mTts = new TextToSpeech ( this , this ) ; } ListPreference ttsLanguagePref = ( ListPreference ) findPreference ( "" tts_default_lang "" ) ; CharSequence [ ] entries = new CharSequence [ available . size ( ) ] ; CharSequence [ ] entryValues = new CharSequence [ available . size ( ) ] ; for ( int i = 0 ; i < available . size ( ) ; i ++ ) { String [ ] langCountryVariant = available . get ( i ) . split ( "" - "" ) ; Locale loc = null ; if ( langCountryVariant . length == 1 ) { loc = new Locale ( langCountryVariant [ 0 ] ) ; } else if ( langCountryVariant . length == 2 ) { loc = new Locale ( langCountryVariant [ 0 ] , langCountryVariant [ 1 ] ) ; } else if ( langCountryVariant . length == 3 ) { loc = new Locale ( langCountryVariant [ 0 ] , langCountryVariant [ 1 ] , langCountryVariant [ 2 ] ) ; } if ( loc != null ) { entries [ i ] = loc . getDisplayName ( ) ; entryValues [ i ] = available . get ( i ) ; } } ttsLanguagePref . setEntries ( entries ) ; ttsLanguagePref . setEntryValues ( entryValues ) ; mEnableDemo = true ; // Make sure that the default language can be used. int languageResult = mTts . setLanguage ( new Locale ( mDefaultLanguage , mDefaultCountry , mDefaultLocVariant ) ) ; if ( languageResult < TextToSpeech . LANG_AVAILABLE ) { Locale currentLocale = Locale . getDefault ( ) ; mDefaultLanguage = currentLocale . getISO3Language ( ) ; mDefaultCountry = currentLocale . getISO3Country ( ) ; mDefaultLocVariant = currentLocale . getVariant ( ) ; languageResult = mTts . setLanguage ( new Locale ( mDefaultLanguage , mDefaultCountry , mDefaultLocVariant ) ) ; // If the default Locale isn't supported, just choose the first available // language so that there is at least something. if ( languageResult < TextToSpeech . LANG_AVAILABLE ) { parseLocaleInfo ( ttsLanguagePref . getEntryValues ( ) [ 0 ] . toString ( ) ) ; mTts . setLanguage ( new Locale ( mDefaultLanguage , mDefaultCountry , mDefaultLocVariant ) ) ; } ContentResolver resolver = getContentResolver ( ) ; Settings . Secure . putString ( resolver , TTS_DEFAULT_LANG , mDefaultLanguage ) ; Settings . Secure . putString ( resolver , TTS_DEFAULT_COUNTRY , mDefaultCountry ) ; Settings . Secure . putString ( resolver , TTS_DEFAULT_VARIANT , mDefaultLocVariant ) ; } } else { mEnableDemo = false ; } if ( unavailable . size ( ) > 0 ) { mVoicesMissing = true ; } else { mVoicesMissing = false ; } updateWidgetState ( ) ; } else if ( requestCode == GET_SAMPLE_TEXT ) { if ( resultCode == TextToSpeech . LANG_AVAILABLE ) { String sample = getString ( R . string . tts_demo ) ; if ( ( data != null ) && ( data . getStringExtra ( "" sampleText "" ) != null ) ) { sample = data . getStringExtra ( "" sampleText "" ) ; } if ( mTts != null ) { mTts . speak ( sample , TextToSpeech . QUEUE_FLUSH , null ) ; } } else { // TODO: Display an error here to the user. Log . e ( TAG , "" Did not have a sample string for the requested language "" ) ; } } }",2010/2/10 14:54,2010/4/7 17:41,2,Other
1196,34,https://www.github.com/aosp-mirror/platform_packages_providers_calendarprovider,handleMessage(Message),DESIGN,2794,2794,2794,2794,TODO remove this after ACCOUNT_NAME/TYPE get renamed.,https://www.github.com/aosp-mirror/platform_packages_providers_calendarprovider/commit/0739be04,https://www.github.com/aosp-mirror/platform_packages_providers_calendarprovider/commit/c8383567db3ade2aea28447ad3bd09ac3033bcd7,src/com/android/providers/calendar/CalendarProvider2.java,"private void verifyHasAccount(Uri uri, String selection, String[] selectionArgs) {
String accountName = QueryParameterUtils.getQueryParameter(uri, Calendars._SYNC_ACCOUNT);
String accountType = QueryParameterUtils.getQueryParameter(uri,
                Calendars._SYNC_ACCOUNT_TYPE);
if (TextUtils.isEmpty(accountName) || TextUtils.isEmpty(accountType)) {
// TODO remove this after ACCOUNT_NAME/TYPE get renamed.
accountName = QueryParameterUtils.getQueryParameter(uri,
                    Calendar.SyncState.ACCOUNT_NAME);
accountType = QueryParameterUtils.getQueryParameter(uri,
                    Calendar.SyncState.ACCOUNT_TYPE);
}
if (TextUtils.isEmpty(accountName) || TextUtils.isEmpty(accountType)) {
if (selection != null && selection.startsWith(ACCOUNT_SELECTION_PREFIX)) {
accountName = selectionArgs[0];
accountType = selectionArgs[1];
}
}
if (TextUtils.isEmpty(accountName) || TextUtils.isEmpty(accountType)) {
throw new IllegalArgumentException(
                    ""Sync adapters must specify an account and account type: "" + uri);
}
}","private void verifyHasAccount(Uri uri, String selection, String[] selectionArgs) {
String accountName = QueryParameterUtils.getQueryParameter(uri, Calendars.ACCOUNT_NAME);
String accountType = QueryParameterUtils.getQueryParameter(uri,
                Calendars.ACCOUNT_TYPE);
if (TextUtils.isEmpty(accountName) || TextUtils.isEmpty(accountType)) {
if (selection != null && selection.startsWith(ACCOUNT_SELECTION_PREFIX)) {
accountName = selectionArgs[0];
accountType = selectionArgs[1];
}
}
if (TextUtils.isEmpty(accountName) || TextUtils.isEmpty(accountType)) {
throw new IllegalArgumentException(
                    ""Sync adapters must specify an account and account type: "" + uri);
}
}","private void verifyHasAccount  ( Uri uri , String selection , String [ ] selectionArgs ) { String accountName = QueryParameterUtils . getQueryParameter ( uri , Calendars . _SYNC_ACCOUNT ) ; String accountType = QueryParameterUtils . getQueryParameter ( uri , Calendars . _SYNC_ACCOUNT_TYPE ) ; if ( TextUtils . isEmpty ( accountName ) || TextUtils . isEmpty ( accountType ) ) { // <SATD_START> TODO remove this after ACCOUNT_NAME/TYPE get renamed. <SATD_END> accountName = QueryParameterUtils . getQueryParameter ( uri , Calendar . SyncState . ACCOUNT_NAME ) ; accountType = QueryParameterUtils . getQueryParameter ( uri , Calendar . SyncState . ACCOUNT_TYPE ) ; } if ( TextUtils . isEmpty ( accountName ) || TextUtils . isEmpty ( accountType ) ) { if ( selection != null && selection . startsWith ( ACCOUNT_SELECTION_PREFIX ) ) { accountName = selectionArgs [ 0 ] ; accountType = selectionArgs [ 1 ] ; } } if ( TextUtils . isEmpty ( accountName ) || TextUtils . isEmpty ( accountType ) ) { throw new IllegalArgumentException ( "" Sync adapters must specify an account and account type:  "" + uri ) ; } }","private void verifyHasAccount  ( Uri uri , String selection , String [ ] selectionArgs ) { String accountName = QueryParameterUtils . getQueryParameter ( uri , Calendars . ACCOUNT_NAME ) ; String accountType = QueryParameterUtils . getQueryParameter ( uri , Calendars . ACCOUNT_TYPE ) ; if ( TextUtils . isEmpty ( accountName ) || TextUtils . isEmpty ( accountType ) ) { if ( selection != null && selection . startsWith ( ACCOUNT_SELECTION_PREFIX ) ) { accountName = selectionArgs [ 0 ] ; accountType = selectionArgs [ 1 ] ; } } if ( TextUtils . isEmpty ( accountName ) || TextUtils . isEmpty ( accountType ) ) { throw new IllegalArgumentException ( "" Sync adapters must specify an account and account type:  "" + uri ) ; } }",2011/5/5 10:34,2011/5/11 16:41,2,Other
848,134,https://www.github.com/franzinc/agraph-java-client,evaluate(RDFHandler),DESIGN,64,64,64,64,TODO: deal with the hard coded return format,https://www.github.com/franzinc/agraph-java-client/commit/574a0ba7,https://www.github.com/franzinc/agraph-java-client/commit/ea9264e9cd8eb6ecf0df75f87bc5e1a6eebdb043,src/com/franz/agraph/repository/AGGraphQuery.java,"public void evaluate(RDFHandler handler) throws QueryEvaluationException,
			RDFHandlerException {
// TODO: deal with the hard coded return format
evaluate(new AGRDFHandler(RDFFormat.NTRIPLES, handler, httpCon.getValueFactory(),httpCon.getHttpRepoClient().getAllowExternalBlankNodeIds()));
}","public void evaluate(RDFHandler handler) throws QueryEvaluationException,
			RDFHandlerException {
final RDFFormat format = httpCon.getHttpRepoClient().getPreferredRDFFormat();
evaluate(new AGRDFHandler(format, handler, httpCon.getValueFactory(),httpCon.getHttpRepoClient().getAllowExternalBlankNodeIds()));
}","public void evaluate  ( RDFHandler handler ) throws QueryEvaluationException , RDFHandlerException  { // <SATD_START> TODO: deal with the hard coded return format <SATD_END> evaluate ( new AGRDFHandler ( RDFFormat . NTRIPLES , handler , httpCon . getValueFactory ( ) , httpCon . getHttpRepoClient ( ) . getAllowExternalBlankNodeIds ( ) ) ) ; }","public void evaluate  ( RDFHandler handler ) throws QueryEvaluationException , RDFHandlerException { final RDFFormat format = httpCon . getHttpRepoClient ( ) . getPreferredRDFFormat ( ) ; evaluate ( new AGRDFHandler ( format , handler , httpCon . getValueFactory ( ) , httpCon . getHttpRepoClient ( ) . getAllowExternalBlankNodeIds ( ) ) ) ; }",2010/11/1 11:17,2016/10/13 13:26,70,Other
2019,207,https://www.github.com/cbeust/testng,"init(IConfiguration, ISuite, XmlTest, String, IAnnotationFinder, boolean, Collection<IInvokedMethodListener>, List<IClassListener>)",DESIGN,1173,1173,1173,1173,TODO a listener may be added many times if it implements many interfaces,https://www.github.com/cbeust/testng/commit/72f236861,https://www.github.com/cbeust/testng/commit/b937a1d0e95ee59174286add8bb59c3cf82b9ab7,testng-core/src/main/java/org/testng/TestRunner.java,"public void addListener(ITestNGListener listener) {
// TODO a listener may be added many times if it implements many interfaces
if (listener instanceof IMethodInterceptor) {
m_methodInterceptors.add((IMethodInterceptor) listener);
}
if (listener instanceof ITestListener) {
// At this point, the field m_testListeners has already been used in the creation
addTestListener((ITestListener) listener);
}
if (listener instanceof IClassListener) {
IClassListener classListener = (IClassListener) listener;
if (!m_classListeners.containsKey(classListener.getClass())) {
m_classListeners.put(classListener.getClass(), classListener);
}
}
if (listener instanceof IConfigurationListener) {
addConfigurationListener((IConfigurationListener) listener);
}
if (listener instanceof IConfigurable) {
m_configuration.setConfigurable((IConfigurable) listener);
}
if (listener instanceof IHookable) {
m_configuration.setHookable((IHookable) listener);
}
if (listener instanceof IExecutionListener) {
IExecutionListener iel = (IExecutionListener) listener;
if (m_configuration.addExecutionListenerIfAbsent(iel)) {
iel.onExecutionStart();
}
}
if (listener instanceof IDataProviderListener) {
IDataProviderListener dataProviderListener = (IDataProviderListener) listener;
holder.addListener(dataProviderListener);
}
if (listener instanceof IDataProviderInterceptor) {
IDataProviderInterceptor interceptor = (IDataProviderInterceptor) listener;
holder.addInterceptor(interceptor);
}
if (listener instanceof IExecutionVisualiser) {
IExecutionVisualiser l = (IExecutionVisualiser) listener;
visualisers.add(l);
}
m_suite.addListener(listener);
}","public void addListener(ITestNGListener listener) {
if (listener instanceof IMethodInterceptor) {
m_methodInterceptors.add((IMethodInterceptor) listener);
}
if (listener instanceof ITestListener) {
// At this point, the field m_testListeners has already been used in the creation
addTestListener((ITestListener) listener);
}
if (listener instanceof IClassListener) {
IClassListener classListener = (IClassListener) listener;
m_classListeners.putIfAbsent(classListener.getClass(), classListener);
}
if (listener instanceof IConfigurationListener) {
addConfigurationListener((IConfigurationListener) listener);
}
if (listener instanceof IConfigurable) {
m_configuration.setConfigurable((IConfigurable) listener);
}
if (listener instanceof IHookable) {
m_configuration.setHookable((IHookable) listener);
}
if (listener instanceof IExecutionListener) {
IExecutionListener iel = (IExecutionListener) listener;
if (m_configuration.addExecutionListenerIfAbsent(iel)) {
iel.onExecutionStart();
}
}
if (listener instanceof IDataProviderListener) {
IDataProviderListener dataProviderListener = (IDataProviderListener) listener;
holder.addListener(dataProviderListener);
}
if (listener instanceof IDataProviderInterceptor) {
IDataProviderInterceptor interceptor = (IDataProviderInterceptor) listener;
holder.addInterceptor(interceptor);
}
if (listener instanceof IExecutionVisualiser) {
IExecutionVisualiser l = (IExecutionVisualiser) listener;
visualisers.add(l);
}
m_suite.addListener(listener);
}","public void addListener  ( ITestNGListener listener ) { // <SATD_START> TODO a listener may be added many times if it implements many interfaces <SATD_END> if ( listener instanceof IMethodInterceptor ) { m_methodInterceptors . add ( ( IMethodInterceptor ) listener ) ; } if ( listener instanceof ITestListener ) { // At this point, the field m_testListeners has already been used in the creation addTestListener ( ( ITestListener ) listener ) ; } if ( listener instanceof IClassListener ) { IClassListener classListener = ( IClassListener ) listener ; if ( ! m_classListeners . containsKey ( classListener . getClass ( ) ) ) { m_classListeners . put ( classListener . getClass ( ) , classListener ) ; } } if ( listener instanceof IConfigurationListener ) { addConfigurationListener ( ( IConfigurationListener ) listener ) ; } if ( listener instanceof IConfigurable ) { m_configuration . setConfigurable ( ( IConfigurable ) listener ) ; } if ( listener instanceof IHookable ) { m_configuration . setHookable ( ( IHookable ) listener ) ; } if ( listener instanceof IExecutionListener ) { IExecutionListener iel = ( IExecutionListener ) listener ; if ( m_configuration . addExecutionListenerIfAbsent ( iel ) ) { iel . onExecutionStart ( ) ; } } if ( listener instanceof IDataProviderListener ) { IDataProviderListener dataProviderListener = ( IDataProviderListener ) listener ; holder . addListener ( dataProviderListener ) ; } if ( listener instanceof IDataProviderInterceptor ) { IDataProviderInterceptor interceptor = ( IDataProviderInterceptor ) listener ; holder . addInterceptor ( interceptor ) ; } if ( listener instanceof IExecutionVisualiser ) { IExecutionVisualiser l = ( IExecutionVisualiser ) listener ; visualisers . add ( l ) ; } m_suite . addListener ( listener ) ; }","public void addListener  ( ITestNGListener listener ) { if ( listener instanceof IMethodInterceptor ) { m_methodInterceptors . add ( ( IMethodInterceptor ) listener ) ; } if ( listener instanceof ITestListener ) { // At this point, the field m_testListeners has already been used in the creation addTestListener ( ( ITestListener ) listener ) ; } if ( listener instanceof IClassListener ) { IClassListener classListener = ( IClassListener ) listener ; m_classListeners . putIfAbsent ( classListener . getClass ( ) , classListener ) ; } if ( listener instanceof IConfigurationListener ) { addConfigurationListener ( ( IConfigurationListener ) listener ) ; } if ( listener instanceof IConfigurable ) { m_configuration . setConfigurable ( ( IConfigurable ) listener ) ; } if ( listener instanceof IHookable ) { m_configuration . setHookable ( ( IHookable ) listener ) ; } if ( listener instanceof IExecutionListener ) { IExecutionListener iel = ( IExecutionListener ) listener ; if ( m_configuration . addExecutionListenerIfAbsent ( iel ) ) { iel . onExecutionStart ( ) ; } } if ( listener instanceof IDataProviderListener ) { IDataProviderListener dataProviderListener = ( IDataProviderListener ) listener ; holder . addListener ( dataProviderListener ) ; } if ( listener instanceof IDataProviderInterceptor ) { IDataProviderInterceptor interceptor = ( IDataProviderInterceptor ) listener ; holder . addInterceptor ( interceptor ) ; } if ( listener instanceof IExecutionVisualiser ) { IExecutionVisualiser l = ( IExecutionVisualiser ) listener ; visualisers . add ( l ) ; } m_suite . addListener ( listener ) ; }",2016-05-24 17:34:59 +0200,2022-05-09 18:05:12 +0530,23,Exclamatory
342,780,https://www.github.com/jbosstm/narayana,postConstruct(),,51,51,51,51,FIXME this is ugly hack!! it seems that dependency names from jboss-beans.xml no longer work in AS7!?,https://www.github.com/jbosstm/narayana/commit/13027eaff3,https://www.github.com/jbosstm/narayana/commit/267335c20ffa875ceeb8429517f1e016d40729df,txbridge/src/test/java/org/jboss/jbossts/txbridge/tests/outbound/utility/TestRecoveryModule.java,"@PostConstruct
public void postConstruct() {
log.info(""TestRecoveryModule starting"");
//FIXME this is ugly hack!! it seems that dependency names from jboss-beans.xml no longer work in AS7!?
XTSATRecoveryManager xtsATRecoveryManager = null;
do {
xtsATRecoveryManager = XTSATRecoveryManager.getRecoveryManager();
log.info(""trying to get XTSATRecoverManager = "" + xtsATRecoveryManager);
try {
Thread.sleep(100);
} catch (InterruptedException e) {
// ignore
}
} while (xtsATRecoveryManager == null);
xtsATRecoveryManager.registerRecoveryModule(this);
}","@PostConstruct
public void postConstruct() {
log.info(""TestRecoveryModule starting"");
XTSATRecoveryManager.getRecoveryManager().registerRecoveryModule(this);
}","@ PostConstruct public void postConstruct  ( ) { log . info ( "" TestRecoveryModule starting "" ) ; //<SATD_START> FIXME this is ugly hack!! it seems that dependency names from jboss-beans.xml no longer work in AS7!? <SATD_END> XTSATRecoveryManager xtsATRecoveryManager = null ; do { xtsATRecoveryManager = XTSATRecoveryManager . getRecoveryManager ( ) ; log . info ( "" trying to get XTSATRecoverManager =  "" + xtsATRecoveryManager ) ; try { Thread . sleep ( 100 ) ; } catch ( InterruptedException e ) { // ignore } } while ( xtsATRecoveryManager == null ) ; xtsATRecoveryManager . registerRecoveryModule ( this ) ; }","@ PostConstruct public void postConstruct  ( ) { log . info ( "" TestRecoveryModule starting "" ) ; XTSATRecoveryManager . getRecoveryManager ( ) . registerRecoveryModule ( this ) ; }",2012-04-19 21:49:14 +0100,2013-09-30 15:00:30 +0100,4,Exclamatory
554,13,https://www.github.com/aosp-mirror/platform_packages_apps_settings,"onCreatePreferences(Bundle, String)",,97,97,97,97,TODO: Consider handling the error differently perhaps by showing default icons.,https://www.github.com/aosp-mirror/platform_packages_apps_settings/commit/567ebd68e1e0,https://www.github.com/aosp-mirror/platform_packages_apps_settings/commit/8cb387adae9ed52e57d077d4528a12509195a908,src/com/android/settings/inputmethod/VirtualKeyboardFragment.java,"private void updateInputMethodPreferenceViews() {
// Clear existing ""InputMethodPreference""s
mInputMethodPreferenceList.clear();
List<String> permittedList = mDpm.getPermittedInputMethodsForCurrentUser();
final Context context = getPrefContext();
final List<InputMethodInfo> imis = mImm.getEnabledInputMethodList();
final int N = (imis == null ? 0 : imis.size());
for (int i = 0; i < N; ++i) {
final InputMethodInfo imi = imis.get(i);
final boolean isAllowedByOrganization = permittedList == null
|| permittedList.contains(imi.getPackageName());
Drawable icon;
try {
// TODO: Consider other ways to retrieve an icon to show here.
icon = getActivity().getPackageManager().getApplicationIcon(imi.getPackageName());
} catch (Exception e) {
// TODO: Consider handling the error differently perhaps by showing default icons.
icon = NO_ICON;
}
final InputMethodPreference pref = new InputMethodPreference(
                    context,
                    imi,
                    false,  /* isImeEnabler */
isAllowedByOrganization,
                    null /* this can be null since isImeEnabler is false */);
pref.setIcon(icon);
mInputMethodPreferenceList.add(pref);
}
final Collator collator = Collator.getInstance();
mInputMethodPreferenceList.sort((lhs, rhs) -> lhs.compareTo(rhs, collator));
getPreferenceScreen().removeAll();
for (int i = 0; i < N; ++i) {
final InputMethodPreference pref = mInputMethodPreferenceList.get(i);
pref.setOrder(i);
getPreferenceScreen().addPreference(pref);
InputMethodAndSubtypeUtilCompat.removeUnnecessaryNonPersistentPreference(pref);
pref.updatePreferenceViews();
}
mAddVirtualKeyboardScreen.setIcon(R.drawable.ic_add_24dp);
mAddVirtualKeyboardScreen.setOrder(N);
getPreferenceScreen().addPreference(mAddVirtualKeyboardScreen);
}","private void updateInputMethodPreferenceViews() {
// Clear existing ""InputMethodPreference""s
mInputMethodPreferenceList.clear();
List<String> permittedList = mDpm.getPermittedInputMethodsForCurrentUser();
final Context context = getPrefContext();
final List<InputMethodInfo> imis = mImm.getEnabledInputMethodList();
final int N = (imis == null ? 0 : imis.size());
for (int i = 0; i < N; ++i) {
final InputMethodInfo imi = imis.get(i);
final boolean isAllowedByOrganization = permittedList == null
|| permittedList.contains(imi.getPackageName());
final Drawable icon = imi.loadIcon(context.getPackageManager());
final InputMethodPreference pref = new InputMethodPreference(
                    context,
                    imi,
                    false,  /* isImeEnabler */
isAllowedByOrganization,
                    null /* this can be null since isImeEnabler is false */);
pref.setIcon(icon);
mInputMethodPreferenceList.add(pref);
}
final Collator collator = Collator.getInstance();
mInputMethodPreferenceList.sort((lhs, rhs) -> lhs.compareTo(rhs, collator));
getPreferenceScreen().removeAll();
for (int i = 0; i < N; ++i) {
final InputMethodPreference pref = mInputMethodPreferenceList.get(i);
pref.setOrder(i);
getPreferenceScreen().addPreference(pref);
InputMethodAndSubtypeUtilCompat.removeUnnecessaryNonPersistentPreference(pref);
pref.updatePreferenceViews();
}
mAddVirtualKeyboardScreen.setIcon(R.drawable.ic_add_24dp);
mAddVirtualKeyboardScreen.setOrder(N);
getPreferenceScreen().addPreference(mAddVirtualKeyboardScreen);
}","private void updateInputMethodPreferenceViews  ( ) { // Clear existing ""InputMethodPreference""s mInputMethodPreferenceList . clear ( ) ; List < String > permittedList = mDpm . getPermittedInputMethodsForCurrentUser ( ) ; final Context context = getPrefContext ( ) ; final List < InputMethodInfo > imis = mImm . getEnabledInputMethodList ( ) ; final int N = ( imis == null ? 0 : imis . size ( ) ) ; for ( int i = 0 ; i < N ; ++ i ) { final InputMethodInfo imi = imis . get ( i ) ; final boolean isAllowedByOrganization = permittedList == null || permittedList . contains ( imi . getPackageName ( ) ) ; Drawable icon ; try { // TODO: Consider other ways to retrieve an icon to show here. icon = getActivity ( ) . getPackageManager ( ) . getApplicationIcon ( imi . getPackageName ( ) ) ; } catch ( Exception e ) { // <SATD_START> TODO: Consider handling the error differently perhaps by showing default icons. <SATD_END> icon = NO_ICON ; } final InputMethodPreference pref = new InputMethodPreference ( context , imi , false , /* isImeEnabler */ isAllowedByOrganization , null /* this can be null since isImeEnabler is false */ ) ; pref . setIcon ( icon ) ; mInputMethodPreferenceList . add ( pref ) ; } final Collator collator = Collator . getInstance ( ) ; mInputMethodPreferenceList . sort ( ( lhs , rhs ) -> lhs . compareTo ( rhs , collator ) ) ; getPreferenceScreen ( ) . removeAll ( ) ; for ( int i = 0 ; i < N ; ++ i ) { final InputMethodPreference pref = mInputMethodPreferenceList . get ( i ) ; pref . setOrder ( i ) ; getPreferenceScreen ( ) . addPreference ( pref ) ; InputMethodAndSubtypeUtilCompat . removeUnnecessaryNonPersistentPreference ( pref ) ; pref . updatePreferenceViews ( ) ; } mAddVirtualKeyboardScreen . setIcon ( R . drawable . ic_add_24dp ) ; mAddVirtualKeyboardScreen . setOrder ( N ) ; getPreferenceScreen ( ) . addPreference ( mAddVirtualKeyboardScreen ) ; }","private void updateInputMethodPreferenceViews  ( ) { // Clear existing ""InputMethodPreference""s mInputMethodPreferenceList . clear ( ) ; List < String > permittedList = mDpm . getPermittedInputMethodsForCurrentUser ( ) ; final Context context = getPrefContext ( ) ; final List < InputMethodInfo > imis = mImm . getEnabledInputMethodList ( ) ; final int N = ( imis == null ? 0 : imis . size ( ) ) ; for ( int i = 0 ; i < N ; ++ i ) { final InputMethodInfo imi = imis . get ( i ) ; final boolean isAllowedByOrganization = permittedList == null || permittedList . contains ( imi . getPackageName ( ) ) ; final Drawable icon = imi . loadIcon ( context . getPackageManager ( ) ) ; final InputMethodPreference pref = new InputMethodPreference ( context , imi , false , /* isImeEnabler */ isAllowedByOrganization , null /* this can be null since isImeEnabler is false */ ) ; pref . setIcon ( icon ) ; mInputMethodPreferenceList . add ( pref ) ; } final Collator collator = Collator . getInstance ( ) ; mInputMethodPreferenceList . sort ( ( lhs , rhs ) -> lhs . compareTo ( rhs , collator ) ) ; getPreferenceScreen ( ) . removeAll ( ) ; for ( int i = 0 ; i < N ; ++ i ) { final InputMethodPreference pref = mInputMethodPreferenceList . get ( i ) ; pref . setOrder ( i ) ; getPreferenceScreen ( ) . addPreference ( pref ) ; InputMethodAndSubtypeUtilCompat . removeUnnecessaryNonPersistentPreference ( pref ) ; pref . updatePreferenceViews ( ) ; } mAddVirtualKeyboardScreen . setIcon ( R . drawable . ic_add_24dp ) ; mAddVirtualKeyboardScreen . setOrder ( N ) ; getPreferenceScreen ( ) . addPreference ( mAddVirtualKeyboardScreen ) ; }",2016-01-25 22:19:23 +0000,2019/4/29 18:11,96,Exclamatory
1737,432,https://www.github.com/guardianproject/chatsecureandroid,transformSending(Message),DESIGN,229,229,229,229,TODO postpone this message until encryption negotiated,https://www.github.com/guardianproject/chatsecureandroid/commit/15da07715,https://www.github.com/guardianproject/chatsecureandroid/commit/a1076d8cb4bff3613008f58320964e0d5e797a22,src/info/guardianproject/otr/OtrChatManager.java,"public void transformSending(Message message) {
String localUserId = message.getFrom().getFullName();
String remoteUserId = message.getTo().getFullName();
String body = message.getBody();
SessionID sessionId = getSessionId(localUserId, remoteUserId);
if (mOtrEngine != null && sessionId != null) {
SessionStatus sessionStatus = mOtrEngine.getSessionStatus(sessionId);
OtrDebugLogger.log(""session status: "" + sessionStatus);
try {
OtrPolicy sessionPolicy = getSessionPolicy(sessionId);
if (sessionStatus != SessionStatus.PLAINTEXT) {
body = mOtrEngine.transformSending(sessionId, body);
message.setTo(mOtrEngineHost.appendSessionResource(sessionId, message.getTo()));
} else if (sessionPolicy.getRequireEncryption()) {
mOtrEngine.startSession(sessionId);
body = null;
// TODO postpone this message until encryption negotiated
} else if (sessionStatus == SessionStatus.PLAINTEXT && sessionPolicy.getAllowV2()
&& sessionPolicy.getSendWhitespaceTag()) {
// Work around asmack not sending whitespace tag for auto discovery
body += "" \t  \t\t\t\t \t \t \t   \t \t  \t   \t\t  \t "";
}
} catch (OtrException e) {
OtrDebugLogger.log(""error encrypting"", e);
}
}
message.setBody(body);
}","public void transformSending(Message message) {
String localUserId = message.getFrom().getFullName();
String remoteUserId = message.getTo().getFullName();
String body = message.getBody();
SessionID sessionId = getSessionId(localUserId, remoteUserId);
if (mOtrEngine != null && sessionId != null) {
SessionStatus sessionStatus = mOtrEngine.getSessionStatus(sessionId);
OtrDebugLogger.log(""session status: "" + sessionStatus);
try {
OtrPolicy sessionPolicy = getSessionPolicy(sessionId);
if (sessionStatus != SessionStatus.PLAINTEXT || sessionPolicy.getRequireEncryption()) {
body = mOtrEngine.transformSending(sessionId, body);
message.setTo(mOtrEngineHost.appendSessionResource(sessionId, message.getTo()));
} else if (sessionStatus == SessionStatus.PLAINTEXT && sessionPolicy.getAllowV2()
&& sessionPolicy.getSendWhitespaceTag()) {
// Work around asmack not sending whitespace tag for auto discovery
body += "" \t  \t\t\t\t \t \t \t   \t \t  \t   \t\t  \t "";
}
} catch (OtrException e) {
OtrDebugLogger.log(""error encrypting"", e);
}
}
message.setBody(body);
}","public void transformSending  ( Message message ) { String localUserId = message . getFrom ( ) . getFullName ( ) ; String remoteUserId = message . getTo ( ) . getFullName ( ) ; String body = message . getBody ( ) ; SessionID sessionId = getSessionId ( localUserId , remoteUserId ) ; if ( mOtrEngine != null && sessionId != null ) { SessionStatus sessionStatus = mOtrEngine . getSessionStatus ( sessionId ) ; OtrDebugLogger . log ( "" session status:  "" + sessionStatus ) ; try { OtrPolicy sessionPolicy = getSessionPolicy ( sessionId ) ; if ( sessionStatus != SessionStatus . PLAINTEXT ) { body = mOtrEngine . transformSending ( sessionId , body ) ; message . setTo ( mOtrEngineHost . appendSessionResource ( sessionId , message . getTo ( ) ) ) ; } else if ( sessionPolicy . getRequireEncryption ( ) ) { mOtrEngine . startSession ( sessionId ) ; body = null ; // <SATD_START> TODO postpone this message until encryption negotiated <SATD_END> } else if ( sessionStatus == SessionStatus . PLAINTEXT && sessionPolicy . getAllowV2 ( ) && sessionPolicy . getSendWhitespaceTag ( ) ) { // Work around asmack not sending whitespace tag for auto discovery body += ""   \t    \t \t \t \t   \t   \t   \t     \t   \t    \t     \t \t    \t   "" ; } } catch ( OtrException e ) { OtrDebugLogger . log ( "" error encrypting "" , e ) ; } } message . setBody ( body ) ; }","public void transformSending  ( Message message ) { String localUserId = message . getFrom ( ) . getFullName ( ) ; String remoteUserId = message . getTo ( ) . getFullName ( ) ; String body = message . getBody ( ) ; SessionID sessionId = getSessionId ( localUserId , remoteUserId ) ; if ( mOtrEngine != null && sessionId != null ) { SessionStatus sessionStatus = mOtrEngine . getSessionStatus ( sessionId ) ; OtrDebugLogger . log ( "" session status:  "" + sessionStatus ) ; try { OtrPolicy sessionPolicy = getSessionPolicy ( sessionId ) ; if ( sessionStatus != SessionStatus . PLAINTEXT || sessionPolicy . getRequireEncryption ( ) ) { body = mOtrEngine . transformSending ( sessionId , body ) ; message . setTo ( mOtrEngineHost . appendSessionResource ( sessionId , message . getTo ( ) ) ) ; } else if ( sessionStatus == SessionStatus . PLAINTEXT && sessionPolicy . getAllowV2 ( ) && sessionPolicy . getSendWhitespaceTag ( ) ) { // Work around asmack not sending whitespace tag for auto discovery body += ""   \t    \t \t \t \t   \t   \t   \t     \t   \t    \t     \t \t    \t   "" ; } } catch ( OtrException e ) { OtrDebugLogger . log ( "" error encrypting "" , e ) ; } } message . setBody ( body ) ; }",2012/6/2 17:02,2012/12/26 21:32,7,Other
2205,666,https://www.github.com/bwaldvogel/mongo-java-server,testSetOplogReplaceOneById(),DESIGN,137,137,137,137,Todo. Support replace one.,https://www.github.com/bwaldvogel/mongo-java-server/commit/5a60afca0,https://www.github.com/bwaldvogel/mongo-java-server/commit/d2a4a54d065a8d9663940ca3ce30bcf516ba75f8,test-common/src/main/java/de/bwaldvogel/mongo/backend/AbstractOplogTest.java,"@Test
@Disabled(""This test represents a missing feature"") //Todo. Support replace one.
public void testSetOplogReplaceOneById() {
collection.insertOne(json(""_id: 1, b: 6""));
collection.replaceOne(json(""_id: 1""), json(""a: 5, b: 7""));
List<Document> oplogDocuments = toArray(getOplogCollection().find().sort(json(""ts: 1"")));
Document updateOplogEntry = oplogDocuments.get(1);
assertThat(updateOplogEntry.get(""op"")).isEqualTo(OperationType.UPDATE.getCode());
assertThat(updateOplogEntry.get(""ns"")).isEqualTo(collection.getNamespace().toString());
assertThat(updateOplogEntry.get(""o"")).isEqualTo(json(""_id: 1, a: 5, b: 7""));
assertThat(updateOplogEntry.get(""o2"")).isEqualTo(json(""_id: 1""));
}","@Test
public void testSetOplogReplaceOneById() {
collection.insertOne(json(""_id: 1, b: 6""));
collection.replaceOne(json(""_id: 1""), json(""a: 5, b: 7""));
List<Document> oplogDocuments = toArray(getOplogCollection().find().sort(json(""ts: 1"")));
Document updateOplogEntry = oplogDocuments.get(1);
assertThat(updateOplogEntry.get(""op"")).isEqualTo(OperationType.UPDATE.getCode());
assertThat(updateOplogEntry.get(""ns"")).isEqualTo(collection.getNamespace().toString());
assertThat(updateOplogEntry.get(""o"")).isEqualTo(json(""_id: 1, a: 5, b: 7""));
assertThat(updateOplogEntry.get(""o2"")).isEqualTo(json(""_id: 1""));
}","@ Test @ Disabled ( "" This test represents a missing feature "" ) //<SATD_START> Todo. Support replace one. <SATD_END> public void testSetOplogReplaceOneById  ( ) { collection . insertOne ( json ( "" _id: 1, b: 6 "" ) ) ; collection . replaceOne ( json ( "" _id: 1 "" ) , json ( "" a: 5, b: 7 "" ) ) ; List < Document > oplogDocuments = toArray ( getOplogCollection ( ) . find ( ) . sort ( json ( "" ts: 1 "" ) ) ) ; Document updateOplogEntry = oplogDocuments . get ( 1 ) ; assertThat ( updateOplogEntry . get ( "" op "" ) ) . isEqualTo ( OperationType . UPDATE . getCode ( ) ) ; assertThat ( updateOplogEntry . get ( "" ns "" ) ) . isEqualTo ( collection . getNamespace ( ) . toString ( ) ) ; assertThat ( updateOplogEntry . get ( "" o "" ) ) . isEqualTo ( json ( "" _id: 1, a: 5, b: 7 "" ) ) ; assertThat ( updateOplogEntry . get ( "" o2 "" ) ) . isEqualTo ( json ( "" _id: 1 "" ) ) ; }","@ Test public void testSetOplogReplaceOneById  ( ) { collection . insertOne ( json ( "" _id: 1, b: 6 "" ) ) ; collection . replaceOne ( json ( "" _id: 1 "" ) , json ( "" a: 5, b: 7 "" ) ) ; List < Document > oplogDocuments = toArray ( getOplogCollection ( ) . find ( ) . sort ( json ( "" ts: 1 "" ) ) ) ; Document updateOplogEntry = oplogDocuments . get ( 1 ) ; assertThat ( updateOplogEntry . get ( "" op "" ) ) . isEqualTo ( OperationType . UPDATE . getCode ( ) ) ; assertThat ( updateOplogEntry . get ( "" ns "" ) ) . isEqualTo ( collection . getNamespace ( ) . toString ( ) ) ; assertThat ( updateOplogEntry . get ( "" o "" ) ) . isEqualTo ( json ( "" _id: 1, a: 5, b: 7 "" ) ) ; assertThat ( updateOplogEntry . get ( "" o2 "" ) ) . isEqualTo ( json ( "" _id: 1 "" ) ) ; }",2020-05-02 18:49:19 +0200,2020-07-29 14:55:30 +0100,7,Other
3446,303,https://www.github.com/d2rq/d2rq,addAliased(RelationBuilder),DESIGN,81,81,84,84,"FIXME should the order clauses be concatenated? however, this would still be not commutative",https://www.github.com/d2rq/d2rq/commit/64a07291,https://www.github.com/d2rq/d2rq/commit/ab2012211a1ca55b0a984ad1469836c66050bf41,src/de/fuberlin/wiwiss/d2rq/parser/RelationBuilder.java,"public void addAliased(RelationBuilder other) {
this.condition = this.condition.and(aliases().applyTo(other.condition));
this.joinConditions.addAll(aliases().applyToJoinSet(other.joinConditions));
this.projections.addAll(aliases().applyToProjectionSet(other.projections));
Collection<Alias> newAliases = new ArrayList<Alias>();
Collection<Alias> removedAliases = new ArrayList<Alias>();
for (Alias alias : (Collection<Alias>) this.aliases) {
Alias newAlias = other.aliases().originalOf(alias);
if (!alias.equals(newAlias)) {
removedAliases.add(alias);
}
newAliases.add(newAlias);
}
this.aliases.removeAll(removedAliases);
this.aliases.addAll(newAliases);
this.orderDesc = order==null?other.orderDesc:orderDesc;
// FIXME should the order clauses be concatenated? however, this would still be not commutative
this.order = order==null?other.order:order;
this.limit = Relation.combineLimits(limit, other.limit);
this.limitInverse = Relation.combineLimits(limitInverse, other.limitInverse);
}","public void addAliased(RelationBuilder other) {
this.condition = this.condition.and(aliases().applyTo(other.condition));
this.joinConditions.addAll(aliases().applyToJoinSet(other.joinConditions));
this.projections.addAll(aliases().applyToProjectionSet(other.projections));
Collection<Alias> newAliases = new ArrayList<Alias>();
Collection<Alias> removedAliases = new ArrayList<Alias>();
for (Alias alias : (Collection<Alias>) this.aliases) {
Alias newAlias = other.aliases().originalOf(alias);
if (!alias.equals(newAlias)) {
removedAliases.add(alias);
}
newAliases.add(newAlias);
}
this.aliases.removeAll(removedAliases);
this.aliases.addAll(newAliases);
if (!other.orderSpecs.isEmpty()) {
// Overwrite our ordering if the other builder is ordered 
this.orderSpecs = aliases().applyTo(other.orderSpecs);
}
this.limit = Relation.combineLimits(limit, other.limit);
this.limitInverse = Relation.combineLimits(limitInverse, other.limitInverse);
}","public void addAliased  ( RelationBuilder other ) { this . condition = this . condition . and ( aliases ( ) . applyTo ( other . condition ) ) ; this . joinConditions . addAll ( aliases ( ) . applyToJoinSet ( other . joinConditions ) ) ; this . projections . addAll ( aliases ( ) . applyToProjectionSet ( other . projections ) ) ; Collection < Alias > newAliases = new ArrayList < Alias > ( ) ; Collection < Alias > removedAliases = new ArrayList < Alias > ( ) ; for ( Alias alias : ( Collection < Alias > ) this . aliases ) { Alias newAlias = other . aliases ( ) . originalOf ( alias ) ; if ( ! alias . equals ( newAlias ) ) { removedAliases . add ( alias ) ; } newAliases . add ( newAlias ) ; } this . aliases . removeAll ( removedAliases ) ; this . aliases . addAll ( newAliases ) ; this . orderDesc = order == null ? other . orderDesc : orderDesc ; // <SATD_START> FIXME should the order clauses be concatenated? however, this would still be not commutative <SATD_END> this . order = order == null ? other . order : order ; this . limit = Relation . combineLimits ( limit , other . limit ) ; this . limitInverse = Relation . combineLimits ( limitInverse , other . limitInverse ) ; }","public void addAliased  ( RelationBuilder other ) { this . condition = this . condition . and ( aliases ( ) . applyTo ( other . condition ) ) ; this . joinConditions . addAll ( aliases ( ) . applyToJoinSet ( other . joinConditions ) ) ; this . projections . addAll ( aliases ( ) . applyToProjectionSet ( other . projections ) ) ; Collection < Alias > newAliases = new ArrayList < Alias > ( ) ; Collection < Alias > removedAliases = new ArrayList < Alias > ( ) ; for ( Alias alias : ( Collection < Alias > ) this . aliases ) { Alias newAlias = other . aliases ( ) . originalOf ( alias ) ; if ( ! alias . equals ( newAlias ) ) { removedAliases . add ( alias ) ; } newAliases . add ( newAlias ) ; } this . aliases . removeAll ( removedAliases ) ; this . aliases . addAll ( newAliases ) ; if ( ! other . orderSpecs . isEmpty ( ) ) { // Overwrite our ordering if the other builder is ordered  this . orderSpecs = aliases ( ) . applyTo ( other . orderSpecs ) ; } this . limit = Relation . combineLimits ( limit , other . limit ) ; this . limitInverse = Relation . combineLimits ( limitInverse , other . limitInverse ) ; }",2009-07-29 12:03:52 +0000,2012-03-29 21:37:35 +0100,3,Exclamatory
3003,131,https://www.github.com/sgothel/jogl,swapBuffersImpl(),,76,76,76,76,FIXME: clear out unreachable contexts,https://www.github.com/sgothel/jogl/commit/a959c53b7a,https://www.github.com/sgothel/jogl/commit/4433f2a68fa3ca500e258a6862b0e95461fc5083,src/jogl/classes/jogamp/opengl/macosx/cgl/MacOSXOnscreenCGLDrawable.java,"protected void swapBuffersImpl() {
for (Iterator iter = createdContexts.iterator(); iter.hasNext(); ) {
WeakReference ref = (WeakReference) iter.next();
MacOSXOnscreenCGLContext ctx = (MacOSXOnscreenCGLContext) ref.get();
// FIXME: clear out unreachable contexts
if (ctx != null) {
ctx.swapBuffers();
}
}
}","protected void swapBuffersImpl() {
synchronized (createdContexts) {
for (Iterator<WeakReference<MacOSXCGLContext>> iter = createdContexts.iterator(); iter.hasNext(); ) {
WeakReference<MacOSXCGLContext> ref = iter.next();
MacOSXCGLContext ctx = ref.get();
if (ctx != null) {
ctx.swapBuffers();
} else {
iter.remove();
}
}
}
}",protected void swapBuffersImpl  ( ) { for ( Iterator iter = createdContexts . iterator ( ) ; iter . hasNext ( ) ; ) { WeakReference ref = ( WeakReference ) iter . next ( ) ; MacOSXOnscreenCGLContext ctx = ( MacOSXOnscreenCGLContext ) ref . get ( ) ; // <SATD_START> FIXME: clear out unreachable contexts <SATD_END> if ( ctx != null ) { ctx . swapBuffers ( ) ; } } },protected void swapBuffersImpl  ( ) { synchronized ( createdContexts ) { for ( Iterator < WeakReference < MacOSXCGLContext > > iter = createdContexts . iterator ( ) ; iter . hasNext ( ) ; ) { WeakReference < MacOSXCGLContext > ref = iter . next ( ) ; MacOSXCGLContext ctx = ref . get ( ) ; if ( ctx != null ) { ctx . swapBuffers ( ) ; } else { iter . remove ( ) ; } } } },2009-06-15 22:57:38 +0000,2011-10-25 06:11:14 +0200,10,Other
2107,280,https://www.github.com/eclipse-ee4j/beanvalidation-tck,testCorrectNumberOfCallsToIsReachableAndIsCascadableForParameterValidation(),NOT_DESIGN,157,157,157,157,TODO needs spec assertion,https://www.github.com/eclipse-ee4j/beanvalidation-tck/commit/3c562fdae,https://www.github.com/eclipse-ee4j/beanvalidation-tck/commit/dc832a38443498e0f951b715aac296271fa99145,tests/src/main/java/org/hibernate/beanvalidation/tck/tests/traversableresolver/TraversableResolverTest.java,"@Test
// TODO needs spec assertion
public void testCorrectNumberOfCallsToIsReachableAndIsCascadableForParameterValidation() throws Exception {
Suit suit = new Suit();
suit.setTrousers( new Trousers() );
suit.setJacket( new Jacket() );
suit.setSize( 3333 );
suit.getTrousers().setLength( 32321 );
suit.getJacket().setWidth( 432432 );
Set<Call> expectedReachCalls = new HashSet<Call>();
Set<Call> expectedCascadeCalls = new HashSet<Call>();
expectedReachCalls.add(
				new Call(
						suit,
						""size"",
						Gentleman.class,
						ElementType.FIELD,
						new String[] { ""wearSuit"", ""arg0"" }
				)
		);
expectedReachCalls.add(
				new Call(
						suit,
						""trousers"",
						Gentleman.class,
						ElementType.FIELD,
						new String[] { ""wearSuit"", ""arg0"" }
				)
		);
expectedCascadeCalls.add(
				new Call(
						suit,
						""trousers"",
						Gentleman.class,
						ElementType.FIELD,
						new String[] { ""wearSuit"", ""arg0"" }
				)
		);
expectedReachCalls.add(
				new Call(
						suit.getTrousers(),
						""length"",
						Gentleman.class,
						ElementType.FIELD,
						new String[] { ""wearSuit"", ""arg0"", ""trousers"" }
				)
		);
expectedReachCalls.add(
				new Call(
						suit,
						""jacket"",
						Gentleman.class,
						ElementType.METHOD,
						new String[] { ""wearSuit"", ""arg0"" }
				)
		);
expectedCascadeCalls.add(
				new Call(
						suit,
						""jacket"",
						Gentleman.class,
						ElementType.METHOD,
						new String[] { ""wearSuit"", ""arg0"" }
				)
		);
expectedReachCalls.add(
				new Call(
						suit.getJacket(),
						""width"",
						Gentleman.class,
						ElementType.METHOD,
						new String[] { ""wearSuit"", ""arg0"", ""jacket"" }
				)
		);
SnifferTraversableResolver resolver = new SnifferTraversableResolver(
				expectedReachCalls,
				expectedCascadeCalls
		);
Configuration<?> config = TestUtil.getConfigurationUnderTest().traversableResolver( resolver );
ValidatorFactory factory = config.buildValidatorFactory();
ExecutableValidator executableValidator = factory.getValidator().forExecutables();
Object gentleman = new Gentleman();
Method method = Gentleman.class.getMethod( ""wearSuit"", Suit.class );
Object[] parameterValues = new Object[] { suit };
executableValidator.validateParameters(
				gentleman,
				method,
				parameterValues
		);
assertEquals( resolver.getReachableCallCount(), 5 );
assertEquals( resolver.getCascadableCallCount(), 2 );
}","@Test
@SpecAssertion(section = ""4.6.3"", id = ""i"")
public void testCorrectNumberOfCallsToIsReachableAndIsCascadableForParameterValidation() throws Exception {
Suit suit = new Suit();
suit.setTrousers( new Trousers() );
suit.setJacket( new Jacket() );
suit.setSize( 3333 );
suit.getTrousers().setLength( 32321 );
suit.getJacket().setWidth( 432432 );
Set<Call> expectedReachCalls = new HashSet<Call>();
Set<Call> expectedCascadeCalls = new HashSet<Call>();
expectedReachCalls.add(
				new Call(
						suit,
						""size"",
						Gentleman.class,
						ElementType.FIELD,
						new String[] { ""wearSuit"", ""arg0"" }
				)
		);
expectedReachCalls.add(
				new Call(
						suit,
						""trousers"",
						Gentleman.class,
						ElementType.FIELD,
						new String[] { ""wearSuit"", ""arg0"" }
				)
		);
expectedCascadeCalls.add(
				new Call(
						suit,
						""trousers"",
						Gentleman.class,
						ElementType.FIELD,
						new String[] { ""wearSuit"", ""arg0"" }
				)
		);
expectedReachCalls.add(
				new Call(
						suit.getTrousers(),
						""length"",
						Gentleman.class,
						ElementType.FIELD,
						new String[] { ""wearSuit"", ""arg0"", ""trousers"" }
				)
		);
expectedReachCalls.add(
				new Call(
						suit,
						""jacket"",
						Gentleman.class,
						ElementType.METHOD,
						new String[] { ""wearSuit"", ""arg0"" }
				)
		);
expectedCascadeCalls.add(
				new Call(
						suit,
						""jacket"",
						Gentleman.class,
						ElementType.METHOD,
						new String[] { ""wearSuit"", ""arg0"" }
				)
		);
expectedReachCalls.add(
				new Call(
						suit.getJacket(),
						""width"",
						Gentleman.class,
						ElementType.METHOD,
						new String[] { ""wearSuit"", ""arg0"", ""jacket"" }
				)
		);
SnifferTraversableResolver resolver = new SnifferTraversableResolver(
				expectedReachCalls,
				expectedCascadeCalls
		);
Configuration<?> config = TestUtil.getConfigurationUnderTest().traversableResolver( resolver );
ValidatorFactory factory = config.buildValidatorFactory();
ExecutableValidator executableValidator = factory.getValidator().forExecutables();
Object gentleman = new Gentleman();
Method method = Gentleman.class.getMethod( ""wearSuit"", Suit.class );
Object[] parameterValues = new Object[] { suit };
executableValidator.validateParameters(
				gentleman,
				method,
				parameterValues
		);
assertEquals( resolver.getReachableCallCount(), 5 );
assertEquals( resolver.getCascadableCallCount(), 2 );
}","@ Test // <SATD_START> TODO needs spec assertion <SATD_END> public void testCorrectNumberOfCallsToIsReachableAndIsCascadableForParameterValidation  ( ) throws Exception  { Suit suit = new Suit ( ) ; suit . setTrousers ( new Trousers ( ) ) ; suit . setJacket ( new Jacket ( ) ) ; suit . setSize ( 3333 ) ; suit . getTrousers ( ) . setLength ( 32321 ) ; suit . getJacket ( ) . setWidth ( 432432 ) ; Set < Call > expectedReachCalls = new HashSet < Call > ( ) ; Set < Call > expectedCascadeCalls = new HashSet < Call > ( ) ; expectedReachCalls . add ( new Call ( suit , "" size "" , Gentleman . class , ElementType . FIELD , new String [ ] { "" wearSuit "" , "" arg0 "" } ) ) ; expectedReachCalls . add ( new Call ( suit , "" trousers "" , Gentleman . class , ElementType . FIELD , new String [ ] { "" wearSuit "" , "" arg0 "" } ) ) ; expectedCascadeCalls . add ( new Call ( suit , "" trousers "" , Gentleman . class , ElementType . FIELD , new String [ ] { "" wearSuit "" , "" arg0 "" } ) ) ; expectedReachCalls . add ( new Call ( suit . getTrousers ( ) , "" length "" , Gentleman . class , ElementType . FIELD , new String [ ] { "" wearSuit "" , "" arg0 "" , "" trousers "" } ) ) ; expectedReachCalls . add ( new Call ( suit , "" jacket "" , Gentleman . class , ElementType . METHOD , new String [ ] { "" wearSuit "" , "" arg0 "" } ) ) ; expectedCascadeCalls . add ( new Call ( suit , "" jacket "" , Gentleman . class , ElementType . METHOD , new String [ ] { "" wearSuit "" , "" arg0 "" } ) ) ; expectedReachCalls . add ( new Call ( suit . getJacket ( ) , "" width "" , Gentleman . class , ElementType . METHOD , new String [ ] { "" wearSuit "" , "" arg0 "" , "" jacket "" } ) ) ; SnifferTraversableResolver resolver = new SnifferTraversableResolver ( expectedReachCalls , expectedCascadeCalls ) ; Configuration < ? > config = TestUtil . getConfigurationUnderTest ( ) . traversableResolver ( resolver ) ; ValidatorFactory factory = config . buildValidatorFactory ( ) ; ExecutableValidator executableValidator = factory . getValidator ( ) . forExecutables ( ) ; Object gentleman = new Gentleman ( ) ; Method method = Gentleman . class . getMethod ( "" wearSuit "" , Suit . class ) ; Object [ ] parameterValues = new Object [ ] { suit } ; executableValidator . validateParameters ( gentleman , method , parameterValues ) ; assertEquals ( resolver . getReachableCallCount ( ) , 5 ) ; assertEquals ( resolver . getCascadableCallCount ( ) , 2 ) ; }","@ Test @ SpecAssertion ( section = "" 4.6.3 "" , id = "" i "" ) public void testCorrectNumberOfCallsToIsReachableAndIsCascadableForParameterValidation  ( ) throws Exception  { Suit suit = new Suit ( ) ; suit . setTrousers ( new Trousers ( ) ) ; suit . setJacket ( new Jacket ( ) ) ; suit . setSize ( 3333 ) ; suit . getTrousers ( ) . setLength ( 32321 ) ; suit . getJacket ( ) . setWidth ( 432432 ) ; Set < Call > expectedReachCalls = new HashSet < Call > ( ) ; Set < Call > expectedCascadeCalls = new HashSet < Call > ( ) ; expectedReachCalls . add ( new Call ( suit , "" size "" , Gentleman . class , ElementType . FIELD , new String [ ] { "" wearSuit "" , "" arg0 "" } ) ) ; expectedReachCalls . add ( new Call ( suit , "" trousers "" , Gentleman . class , ElementType . FIELD , new String [ ] { "" wearSuit "" , "" arg0 "" } ) ) ; expectedCascadeCalls . add ( new Call ( suit , "" trousers "" , Gentleman . class , ElementType . FIELD , new String [ ] { "" wearSuit "" , "" arg0 "" } ) ) ; expectedReachCalls . add ( new Call ( suit . getTrousers ( ) , "" length "" , Gentleman . class , ElementType . FIELD , new String [ ] { "" wearSuit "" , "" arg0 "" , "" trousers "" } ) ) ; expectedReachCalls . add ( new Call ( suit , "" jacket "" , Gentleman . class , ElementType . METHOD , new String [ ] { "" wearSuit "" , "" arg0 "" } ) ) ; expectedCascadeCalls . add ( new Call ( suit , "" jacket "" , Gentleman . class , ElementType . METHOD , new String [ ] { "" wearSuit "" , "" arg0 "" } ) ) ; expectedReachCalls . add ( new Call ( suit . getJacket ( ) , "" width "" , Gentleman . class , ElementType . METHOD , new String [ ] { "" wearSuit "" , "" arg0 "" , "" jacket "" } ) ) ; SnifferTraversableResolver resolver = new SnifferTraversableResolver ( expectedReachCalls , expectedCascadeCalls ) ; Configuration < ? > config = TestUtil . getConfigurationUnderTest ( ) . traversableResolver ( resolver ) ; ValidatorFactory factory = config . buildValidatorFactory ( ) ; ExecutableValidator executableValidator = factory . getValidator ( ) . forExecutables ( ) ; Object gentleman = new Gentleman ( ) ; Method method = Gentleman . class . getMethod ( "" wearSuit "" , Suit . class ) ; Object [ ] parameterValues = new Object [ ] { suit } ; executableValidator . validateParameters ( gentleman , method , parameterValues ) ; assertEquals ( resolver . getReachableCallCount ( ) , 5 ) ; assertEquals ( resolver . getCascadableCallCount ( ) , 2 ) ; }",2013-02-06 10:18:40 +0100,2013-02-14 23:55:28 +0100,1,Other
460,13,https://www.github.com/aosp-mirror/platform_packages_apps_settings,onCreate(Bundle),,373,373,373,373,TODO: find out a proper way to handle this. Delete these keys?,https://www.github.com/aosp-mirror/platform_packages_apps_settings/commit/413b171159ce,https://www.github.com/aosp-mirror/platform_packages_apps_settings/commit/94cc1bbf3218a020548a90032ec34f608f4cefdb,src/com/android/settings/vpn2/VpnSettings.java,"private void connect(VpnProfile profile) throws Exception {
// Get the default interface and the default gateway.
String[] network = getDefaultNetwork();
String interfaze = network[0];
String gateway = network[1];
// Load certificates.
String privateKey = """";
String userCert = """";
String caCert = """";
String serverCert = """";
if (!profile.ipsecUserCert.isEmpty()) {
byte[] value = mKeyStore.get(Credentials.USER_PRIVATE_KEY + profile.ipsecUserCert);
privateKey = (value == null) ? null : new String(value, Charsets.UTF_8);
value = mKeyStore.get(Credentials.USER_CERTIFICATE + profile.ipsecUserCert);
userCert = (value == null) ? null : new String(value, Charsets.UTF_8);
}
if (!profile.ipsecCaCert.isEmpty()) {
byte[] value = mKeyStore.get(Credentials.CA_CERTIFICATE + profile.ipsecCaCert);
caCert = (value == null) ? null : new String(value, Charsets.UTF_8);
}
if (!profile.ipsecServerCert.isEmpty()) {
byte[] value = mKeyStore.get(Credentials.USER_CERTIFICATE + profile.ipsecServerCert);
serverCert = (value == null) ? null : new String(value, Charsets.UTF_8);
}
if (privateKey == null || userCert == null || caCert == null || serverCert == null) {
// TODO: find out a proper way to handle this. Delete these keys?
throw new IllegalStateException(""Cannot load credentials"");
}
// Prepare arguments for racoon.
String[] racoon = null;
switch (profile.type) {
case VpnProfile.TYPE_L2TP_IPSEC_PSK:
racoon = new String[] {
                    interfaze, profile.server, ""udppsk"", profile.ipsecIdentifier,
                    profile.ipsecSecret, ""1701"",
                };
break;
case VpnProfile.TYPE_L2TP_IPSEC_RSA:
racoon = new String[] {
                    interfaze, profile.server, ""udprsa"", privateKey, userCert,
                    caCert, serverCert, ""1701"",
                };
break;
case VpnProfile.TYPE_IPSEC_XAUTH_PSK:
racoon = new String[] {
                    interfaze, profile.server, ""xauthpsk"", profile.ipsecIdentifier,
                    profile.ipsecSecret, profile.username, profile.password, """", gateway,
                };
break;
case VpnProfile.TYPE_IPSEC_XAUTH_RSA:
racoon = new String[] {
                    interfaze, profile.server, ""xauthrsa"", privateKey, userCert,
                    caCert, serverCert, profile.username, profile.password, """", gateway,
                };
break;
case VpnProfile.TYPE_IPSEC_HYBRID_RSA:
racoon = new String[] {
                    interfaze, profile.server, ""hybridrsa"",
                    caCert, serverCert, profile.username, profile.password, """", gateway,
                };
break;
}
// Prepare arguments for mtpd.
String[] mtpd = null;
switch (profile.type) {
case VpnProfile.TYPE_PPTP:
mtpd = new String[] {
                    interfaze, ""pptp"", profile.server, ""1723"",
                    ""name"", profile.username, ""password"", profile.password,
                    ""linkname"", ""vpn"", ""refuse-eap"", ""nodefaultroute"",
                    ""usepeerdns"", ""idle"", ""1800"", ""mtu"", ""1400"", ""mru"", ""1400"",
                    (profile.mppe ? ""+mppe"" : ""nomppe""),
                };
break;
case VpnProfile.TYPE_L2TP_IPSEC_PSK:
case VpnProfile.TYPE_L2TP_IPSEC_RSA:
mtpd = new String[] {
                    interfaze, ""l2tp"", profile.server, ""1701"", profile.l2tpSecret,
                    ""name"", profile.username, ""password"", profile.password,
                    ""linkname"", ""vpn"", ""refuse-eap"", ""nodefaultroute"",
                    ""usepeerdns"", ""idle"", ""1800"", ""mtu"", ""1400"", ""mru"", ""1400"",
                };
break;
}
VpnConfig config = new VpnConfig();
config.user = profile.key;
config.interfaze = interfaze;
config.session = profile.name;
config.routes = profile.routes;
if (!profile.dnsServers.isEmpty()) {
config.dnsServers = Arrays.asList(profile.dnsServers.split("" +""));
}
if (!profile.searchDomains.isEmpty()) {
config.searchDomains = Arrays.asList(profile.searchDomains.split("" +""));
}
mService.startLegacyVpn(config, racoon, mtpd);
}","private void connect(VpnProfile profile) throws Exception {
// Get the default interface and the default gateway.
String[] network = getDefaultNetwork();
String interfaze = network[0];
String gateway = network[1];
// Load certificates.
String privateKey = """";
String userCert = """";
String caCert = """";
String serverCert = """";
if (!profile.ipsecUserCert.isEmpty()) {
byte[] value = mKeyStore.get(Credentials.USER_PRIVATE_KEY + profile.ipsecUserCert);
privateKey = (value == null) ? null : new String(value, Charsets.UTF_8);
value = mKeyStore.get(Credentials.USER_CERTIFICATE + profile.ipsecUserCert);
userCert = (value == null) ? null : new String(value, Charsets.UTF_8);
}
if (!profile.ipsecCaCert.isEmpty()) {
byte[] value = mKeyStore.get(Credentials.CA_CERTIFICATE + profile.ipsecCaCert);
caCert = (value == null) ? null : new String(value, Charsets.UTF_8);
}
if (!profile.ipsecServerCert.isEmpty()) {
byte[] value = mKeyStore.get(Credentials.USER_CERTIFICATE + profile.ipsecServerCert);
serverCert = (value == null) ? null : new String(value, Charsets.UTF_8);
}
if (privateKey == null || userCert == null || caCert == null || serverCert == null) {
Toast.makeText(getActivity(), R.string.vpn_missing_cert, Toast.LENGTH_LONG).show();
throw new IllegalStateException(""Cannot load credentials"");
}
// Prepare arguments for racoon.
String[] racoon = null;
switch (profile.type) {
case VpnProfile.TYPE_L2TP_IPSEC_PSK:
racoon = new String[] {
                    interfaze, profile.server, ""udppsk"", profile.ipsecIdentifier,
                    profile.ipsecSecret, ""1701"",
                };
break;
case VpnProfile.TYPE_L2TP_IPSEC_RSA:
racoon = new String[] {
                    interfaze, profile.server, ""udprsa"", privateKey, userCert,
                    caCert, serverCert, ""1701"",
                };
break;
case VpnProfile.TYPE_IPSEC_XAUTH_PSK:
racoon = new String[] {
                    interfaze, profile.server, ""xauthpsk"", profile.ipsecIdentifier,
                    profile.ipsecSecret, profile.username, profile.password, """", gateway,
                };
break;
case VpnProfile.TYPE_IPSEC_XAUTH_RSA:
racoon = new String[] {
                    interfaze, profile.server, ""xauthrsa"", privateKey, userCert,
                    caCert, serverCert, profile.username, profile.password, """", gateway,
                };
break;
case VpnProfile.TYPE_IPSEC_HYBRID_RSA:
racoon = new String[] {
                    interfaze, profile.server, ""hybridrsa"",
                    caCert, serverCert, profile.username, profile.password, """", gateway,
                };
break;
}
// Prepare arguments for mtpd.
String[] mtpd = null;
switch (profile.type) {
case VpnProfile.TYPE_PPTP:
mtpd = new String[] {
                    interfaze, ""pptp"", profile.server, ""1723"",
                    ""name"", profile.username, ""password"", profile.password,
                    ""linkname"", ""vpn"", ""refuse-eap"", ""nodefaultroute"",
                    ""usepeerdns"", ""idle"", ""1800"", ""mtu"", ""1400"", ""mru"", ""1400"",
                    (profile.mppe ? ""+mppe"" : ""nomppe""),
                };
break;
case VpnProfile.TYPE_L2TP_IPSEC_PSK:
case VpnProfile.TYPE_L2TP_IPSEC_RSA:
mtpd = new String[] {
                    interfaze, ""l2tp"", profile.server, ""1701"", profile.l2tpSecret,
                    ""name"", profile.username, ""password"", profile.password,
                    ""linkname"", ""vpn"", ""refuse-eap"", ""nodefaultroute"",
                    ""usepeerdns"", ""idle"", ""1800"", ""mtu"", ""1400"", ""mru"", ""1400"",
                };
break;
}
VpnConfig config = new VpnConfig();
config.user = profile.key;
config.interfaze = interfaze;
config.session = profile.name;
config.routes = profile.routes;
if (!profile.dnsServers.isEmpty()) {
config.dnsServers = Arrays.asList(profile.dnsServers.split("" +""));
}
if (!profile.searchDomains.isEmpty()) {
config.searchDomains = Arrays.asList(profile.searchDomains.split("" +""));
}
mService.startLegacyVpn(config, racoon, mtpd);
}","private void connect  ( VpnProfile profile ) throws Exception { // Get the default interface and the default gateway. String [ ] network = getDefaultNetwork ( ) ; String interfaze = network [ 0 ] ; String gateway = network [ 1 ] ; // Load certificates. String privateKey = "" "" ; String userCert = "" "" ; String caCert = "" "" ; String serverCert = "" "" ; if ( ! profile . ipsecUserCert . isEmpty ( ) ) { byte [ ] value = mKeyStore . get ( Credentials . USER_PRIVATE_KEY + profile . ipsecUserCert ) ; privateKey = ( value == null ) ? null : new String ( value , Charsets . UTF_8 ) ; value = mKeyStore . get ( Credentials . USER_CERTIFICATE + profile . ipsecUserCert ) ; userCert = ( value == null ) ? null : new String ( value , Charsets . UTF_8 ) ; } if ( ! profile . ipsecCaCert . isEmpty ( ) ) { byte [ ] value = mKeyStore . get ( Credentials . CA_CERTIFICATE + profile . ipsecCaCert ) ; caCert = ( value == null ) ? null : new String ( value , Charsets . UTF_8 ) ; } if ( ! profile . ipsecServerCert . isEmpty ( ) ) { byte [ ] value = mKeyStore . get ( Credentials . USER_CERTIFICATE + profile . ipsecServerCert ) ; serverCert = ( value == null ) ? null : new String ( value , Charsets . UTF_8 ) ; } if ( privateKey == null || userCert == null || caCert == null || serverCert == null ) { // <SATD_START> TODO: find out a proper way to handle this. Delete these keys? <SATD_END> throw new IllegalStateException ( "" Cannot load credentials "" ) ; } // Prepare arguments for racoon. String [ ] racoon = null ; switch ( profile . type ) { case VpnProfile . TYPE_L2TP_IPSEC_PSK : racoon = new String [ ] { interfaze , profile . server , "" udppsk "" , profile . ipsecIdentifier , profile . ipsecSecret , "" 1701 "" , } ; break ; case VpnProfile . TYPE_L2TP_IPSEC_RSA : racoon = new String [ ] { interfaze , profile . server , "" udprsa "" , privateKey , userCert , caCert , serverCert , "" 1701 "" , } ; break ; case VpnProfile . TYPE_IPSEC_XAUTH_PSK : racoon = new String [ ] { interfaze , profile . server , "" xauthpsk "" , profile . ipsecIdentifier , profile . ipsecSecret , profile . username , profile . password , "" "" , gateway , } ; break ; case VpnProfile . TYPE_IPSEC_XAUTH_RSA : racoon = new String [ ] { interfaze , profile . server , "" xauthrsa "" , privateKey , userCert , caCert , serverCert , profile . username , profile . password , "" "" , gateway , } ; break ; case VpnProfile . TYPE_IPSEC_HYBRID_RSA : racoon = new String [ ] { interfaze , profile . server , "" hybridrsa "" , caCert , serverCert , profile . username , profile . password , "" "" , gateway , } ; break ; } // Prepare arguments for mtpd. String [ ] mtpd = null ; switch ( profile . type ) { case VpnProfile . TYPE_PPTP : mtpd = new String [ ] { interfaze , "" pptp "" , profile . server , "" 1723 "" , "" name "" , profile . username , "" password "" , profile . password , "" linkname "" , "" vpn "" , "" refuse-eap "" , "" nodefaultroute "" , "" usepeerdns "" , "" idle "" , "" 1800 "" , "" mtu "" , "" 1400 "" , "" mru "" , "" 1400 "" , ( profile . mppe ? "" +mppe "" : "" nomppe "" ) , } ; break ; case VpnProfile . TYPE_L2TP_IPSEC_PSK : case VpnProfile . TYPE_L2TP_IPSEC_RSA : mtpd = new String [ ] { interfaze , "" l2tp "" , profile . server , "" 1701 "" , profile . l2tpSecret , "" name "" , profile . username , "" password "" , profile . password , "" linkname "" , "" vpn "" , "" refuse-eap "" , "" nodefaultroute "" , "" usepeerdns "" , "" idle "" , "" 1800 "" , "" mtu "" , "" 1400 "" , "" mru "" , "" 1400 "" , } ; break ; } VpnConfig config = new VpnConfig ( ) ; config . user = profile . key ; config . interfaze = interfaze ; config . session = profile . name ; config . routes = profile . routes ; if ( ! profile . dnsServers . isEmpty ( ) ) { config . dnsServers = Arrays . asList ( profile . dnsServers . split ( ""  + "" ) ) ; } if ( ! profile . searchDomains . isEmpty ( ) ) { config . searchDomains = Arrays . asList ( profile . searchDomains . split ( ""  + "" ) ) ; } mService . startLegacyVpn ( config , racoon , mtpd ) ; }","private void connect  ( VpnProfile profile ) throws Exception { // Get the default interface and the default gateway. String [ ] network = getDefaultNetwork ( ) ; String interfaze = network [ 0 ] ; String gateway = network [ 1 ] ; // Load certificates. String privateKey = "" "" ; String userCert = "" "" ; String caCert = "" "" ; String serverCert = "" "" ; if ( ! profile . ipsecUserCert . isEmpty ( ) ) { byte [ ] value = mKeyStore . get ( Credentials . USER_PRIVATE_KEY + profile . ipsecUserCert ) ; privateKey = ( value == null ) ? null : new String ( value , Charsets . UTF_8 ) ; value = mKeyStore . get ( Credentials . USER_CERTIFICATE + profile . ipsecUserCert ) ; userCert = ( value == null ) ? null : new String ( value , Charsets . UTF_8 ) ; } if ( ! profile . ipsecCaCert . isEmpty ( ) ) { byte [ ] value = mKeyStore . get ( Credentials . CA_CERTIFICATE + profile . ipsecCaCert ) ; caCert = ( value == null ) ? null : new String ( value , Charsets . UTF_8 ) ; } if ( ! profile . ipsecServerCert . isEmpty ( ) ) { byte [ ] value = mKeyStore . get ( Credentials . USER_CERTIFICATE + profile . ipsecServerCert ) ; serverCert = ( value == null ) ? null : new String ( value , Charsets . UTF_8 ) ; } if ( privateKey == null || userCert == null || caCert == null || serverCert == null ) { Toast . makeText ( getActivity ( ) , R . string . vpn_missing_cert , Toast . LENGTH_LONG ) . show ( ) ; throw new IllegalStateException ( "" Cannot load credentials "" ) ; } // Prepare arguments for racoon. String [ ] racoon = null ; switch ( profile . type ) { case VpnProfile . TYPE_L2TP_IPSEC_PSK : racoon = new String [ ] { interfaze , profile . server , "" udppsk "" , profile . ipsecIdentifier , profile . ipsecSecret , "" 1701 "" , } ; break ; case VpnProfile . TYPE_L2TP_IPSEC_RSA : racoon = new String [ ] { interfaze , profile . server , "" udprsa "" , privateKey , userCert , caCert , serverCert , "" 1701 "" , } ; break ; case VpnProfile . TYPE_IPSEC_XAUTH_PSK : racoon = new String [ ] { interfaze , profile . server , "" xauthpsk "" , profile . ipsecIdentifier , profile . ipsecSecret , profile . username , profile . password , "" "" , gateway , } ; break ; case VpnProfile . TYPE_IPSEC_XAUTH_RSA : racoon = new String [ ] { interfaze , profile . server , "" xauthrsa "" , privateKey , userCert , caCert , serverCert , profile . username , profile . password , "" "" , gateway , } ; break ; case VpnProfile . TYPE_IPSEC_HYBRID_RSA : racoon = new String [ ] { interfaze , profile . server , "" hybridrsa "" , caCert , serverCert , profile . username , profile . password , "" "" , gateway , } ; break ; } // Prepare arguments for mtpd. String [ ] mtpd = null ; switch ( profile . type ) { case VpnProfile . TYPE_PPTP : mtpd = new String [ ] { interfaze , "" pptp "" , profile . server , "" 1723 "" , "" name "" , profile . username , "" password "" , profile . password , "" linkname "" , "" vpn "" , "" refuse-eap "" , "" nodefaultroute "" , "" usepeerdns "" , "" idle "" , "" 1800 "" , "" mtu "" , "" 1400 "" , "" mru "" , "" 1400 "" , ( profile . mppe ? "" +mppe "" : "" nomppe "" ) , } ; break ; case VpnProfile . TYPE_L2TP_IPSEC_PSK : case VpnProfile . TYPE_L2TP_IPSEC_RSA : mtpd = new String [ ] { interfaze , "" l2tp "" , profile . server , "" 1701 "" , profile . l2tpSecret , "" name "" , profile . username , "" password "" , profile . password , "" linkname "" , "" vpn "" , "" refuse-eap "" , "" nodefaultroute "" , "" usepeerdns "" , "" idle "" , "" 1800 "" , "" mtu "" , "" 1400 "" , "" mru "" , "" 1400 "" , } ; break ; } VpnConfig config = new VpnConfig ( ) ; config . user = profile . key ; config . interfaze = interfaze ; config . session = profile . name ; config . routes = profile . routes ; if ( ! profile . dnsServers . isEmpty ( ) ) { config . dnsServers = Arrays . asList ( profile . dnsServers . split ( ""  + "" ) ) ; } if ( ! profile . searchDomains . isEmpty ( ) ) { config . searchDomains = Arrays . asList ( profile . searchDomains . split ( ""  + "" ) ) ; } mService . startLegacyVpn ( config , racoon , mtpd ) ; }",2011/7/7 14:23,2012/2/29 16:12,19,Exclamatory
3485,263,https://www.github.com/rabbitmq/rabbitmq-java-client,tryBasicReturn(),DESIGN,462,462,462,462,%%% FIXME: 312 and 313 should be replaced with symbolic constants when we move to >=0-9,https://www.github.com/rabbitmq/rabbitmq-java-client/commit/393c5fa76,https://www.github.com/rabbitmq/rabbitmq-java-client/commit/a3f352428990fcf18e51d624d21c04012612459f,test/src/com/rabbitmq/examples/TestMain.java,"public void tryBasicReturn() throws IOException {
log(""About to try mandatory/immediate publications"");
String mx = ""mandatoryTestExchange"";
_ch1.exchangeDeclare(mx, ""fanout"", false, false, null);
returnCell = new BlockingCell<Object>();
_ch1.basicPublish(mx, """", true, false, null, ""one"".getBytes());
// %%% FIXME: 312 and 313 should be replaced with symbolic constants when we move to >=0-9
doBasicReturn(returnCell, 312);
returnCell = new BlockingCell<Object>();
_ch1.basicPublish(mx, """", true, true, null, ""two"".getBytes());
doBasicReturn(returnCell, 312);
returnCell = new BlockingCell<Object>();
_ch1.basicPublish(mx, """", false, true, null, ""three"".getBytes());
doBasicReturn(returnCell, 313);
String mq = ""mandatoryTestQueue"";
_ch1.queueDeclare(mq, false, false, false, true, null);
_ch1.queueBind(mq, mx, """");
returnCell = new BlockingCell<Object>();
_ch1.basicPublish(mx, """", true, true, null, ""four"".getBytes());
doBasicReturn(returnCell, 313);
returnCell = new BlockingCell<Object>();
_ch1.basicPublish(mx, """", true, false, null, ""five"".getBytes());
drain(1, mq, true);
_ch1.queueDelete(mq, true, true);
_ch1.exchangeDelete(mx);
log(""Completed basic.return testing."");
}","public void tryBasicReturn() throws IOException {
log(""About to try mandatory/immediate publications"");
String mx = ""mandatoryTestExchange"";
_ch1.exchangeDeclare(mx, ""fanout"", false, false, null);
returnCell = new BlockingCell<Object>();
_ch1.basicPublish(mx, """", true, false, null, ""one"".getBytes());
doBasicReturn(returnCell, AMQP.NO_ROUTE);
returnCell = new BlockingCell<Object>();
_ch1.basicPublish(mx, """", true, true, null, ""two"".getBytes());
doBasicReturn(returnCell, AMQP.NO_ROUTE);
returnCell = new BlockingCell<Object>();
_ch1.basicPublish(mx, """", false, true, null, ""three"".getBytes());
doBasicReturn(returnCell, AMQP.NO_CONSUMERS);
String mq = ""mandatoryTestQueue"";
_ch1.queueDeclare(mq, false, false, false, true, null);
_ch1.queueBind(mq, mx, """");
returnCell = new BlockingCell<Object>();
_ch1.basicPublish(mx, """", true, true, null, ""four"".getBytes());
doBasicReturn(returnCell, AMQP.NO_CONSUMERS);
returnCell = new BlockingCell<Object>();
_ch1.basicPublish(mx, """", true, false, null, ""five"".getBytes());
drain(1, mq, true);
_ch1.queueDelete(mq, true, true);
_ch1.exchangeDelete(mx);
log(""Completed basic.return testing."");
}","public void tryBasicReturn  ( ) throws IOException  { log ( "" About to try mandatory/immediate publications "" ) ; String mx = "" mandatoryTestExchange "" ; _ch1 . exchangeDeclare ( mx , "" fanout "" , false , false , null ) ; returnCell = new BlockingCell < Object > ( ) ; _ch1 . basicPublish ( mx , "" "" , true , false , null , "" one "" . getBytes ( ) ) ; // <SATD_START> %%% FIXME: 312 and 313 should be replaced with symbolic constants when we move to >=0-9 <SATD_END> doBasicReturn ( returnCell , 312 ) ; returnCell = new BlockingCell < Object > ( ) ; _ch1 . basicPublish ( mx , "" "" , true , true , null , "" two "" . getBytes ( ) ) ; doBasicReturn ( returnCell , 312 ) ; returnCell = new BlockingCell < Object > ( ) ; _ch1 . basicPublish ( mx , "" "" , false , true , null , "" three "" . getBytes ( ) ) ; doBasicReturn ( returnCell , 313 ) ; String mq = "" mandatoryTestQueue "" ; _ch1 . queueDeclare ( mq , false , false , false , true , null ) ; _ch1 . queueBind ( mq , mx , "" "" ) ; returnCell = new BlockingCell < Object > ( ) ; _ch1 . basicPublish ( mx , "" "" , true , true , null , "" four "" . getBytes ( ) ) ; doBasicReturn ( returnCell , 313 ) ; returnCell = new BlockingCell < Object > ( ) ; _ch1 . basicPublish ( mx , "" "" , true , false , null , "" five "" . getBytes ( ) ) ; drain ( 1 , mq , true ) ; _ch1 . queueDelete ( mq , true , true ) ; _ch1 . exchangeDelete ( mx ) ; log ( "" Completed basic.return testing. "" ) ; }","public void tryBasicReturn  ( ) throws IOException  { log ( "" About to try mandatory/immediate publications "" ) ; String mx = "" mandatoryTestExchange "" ; _ch1 . exchangeDeclare ( mx , "" fanout "" , false , false , null ) ; returnCell = new BlockingCell < Object > ( ) ; _ch1 . basicPublish ( mx , "" "" , true , false , null , "" one "" . getBytes ( ) ) ; doBasicReturn ( returnCell , AMQP . NO_ROUTE ) ; returnCell = new BlockingCell < Object > ( ) ; _ch1 . basicPublish ( mx , "" "" , true , true , null , "" two "" . getBytes ( ) ) ; doBasicReturn ( returnCell , AMQP . NO_ROUTE ) ; returnCell = new BlockingCell < Object > ( ) ; _ch1 . basicPublish ( mx , "" "" , false , true , null , "" three "" . getBytes ( ) ) ; doBasicReturn ( returnCell , AMQP . NO_CONSUMERS ) ; String mq = "" mandatoryTestQueue "" ; _ch1 . queueDeclare ( mq , false , false , false , true , null ) ; _ch1 . queueBind ( mq , mx , "" "" ) ; returnCell = new BlockingCell < Object > ( ) ; _ch1 . basicPublish ( mx , "" "" , true , true , null , "" four "" . getBytes ( ) ) ; doBasicReturn ( returnCell , AMQP . NO_CONSUMERS ) ; returnCell = new BlockingCell < Object > ( ) ; _ch1 . basicPublish ( mx , "" "" , true , false , null , "" five "" . getBytes ( ) ) ; drain ( 1 , mq , true ) ; _ch1 . queueDelete ( mq , true , true ) ; _ch1 . exchangeDelete ( mx ) ; log ( "" Completed basic.return testing. "" ) ; }",2008-07-03 13:50:48 +0100,2009/4/13 14:06,6,Exclamatory
2291,591,https://www.github.com/jenkinsci/remoting,wrap(OutputStream),DESIGN,1446,1446,1446,1446,TODO: Synchronize when Hashtable gets replaced by a modern collection.,https://www.github.com/jenkinsci/remoting/commit/49c67eef8,https://www.github.com/jenkinsci/remoting/commit/f767654728b076666aea35520fffc651e342ed43,src/main/java/hudson/remoting/Channel.java,"@Restricted(NoExternalUse.class)
public void dumpDiagnostics(@Nonnull PrintWriter w) throws IOException {
w.printf(""Channel %s%n"",name);
w.printf(""  Created=%s%n"", new Date(createdAt));
w.printf(""  Commands sent=%d%n"", commandsSent);
w.printf(""  Commands received=%d%n"", commandsReceived);
w.printf(""  Last command sent=%s%n"", new Date(lastCommandSentAt));
w.printf(""  Last command received=%s%n"", new Date(lastCommandReceivedAt));
// TODO: Synchronize when Hashtable gets replaced by a modern collection.
w.printf(""  Pending calls=%d%n"", pendingCalls.size());
}","@Restricted(NoExternalUse.class)
public void dumpDiagnostics(@Nonnull PrintWriter w) throws IOException {
w.printf(""Channel %s%n"",name);
w.printf(""  Created=%s%n"", new Date(createdAt));
w.printf(""  Commands sent=%d%n"", commandsSent.get());
w.printf(""  Commands received=%d%n"", commandsReceived.get());
w.printf(""  Last command sent=%s%n"", new Date(lastCommandSentAt.get()));
w.printf(""  Last command received=%s%n"", new Date(lastCommandReceivedAt.get()));
synchronized (pendingCalls) {
w.printf(""  Pending calls=%d%n"", pendingCalls.size());
}
}","@ Restricted ( NoExternalUse . class ) public void dumpDiagnostics  ( @ Nonnull PrintWriter w ) throws IOException { w . printf ( "" Channel %s%n "" , name ) ; w . printf ( ""   Created=%s%n "" , new Date ( createdAt ) ) ; w . printf ( ""   Commands sent=%d%n "" , commandsSent ) ; w . printf ( ""   Commands received=%d%n "" , commandsReceived ) ; w . printf ( ""   Last command sent=%s%n "" , new Date ( lastCommandSentAt ) ) ; w . printf ( ""   Last command received=%s%n "" , new Date ( lastCommandReceivedAt ) ) ; // <SATD_START> TODO: Synchronize when Hashtable gets replaced by a modern collection. <SATD_END> w . printf ( ""   Pending calls=%d%n "" , pendingCalls . size ( ) ) ; }","@ Restricted ( NoExternalUse . class ) public void dumpDiagnostics  ( @ Nonnull PrintWriter w ) throws IOException { w . printf ( "" Channel %s%n "" , name ) ; w . printf ( ""   Created=%s%n "" , new Date ( createdAt ) ) ; w . printf ( ""   Commands sent=%d%n "" , commandsSent . get ( ) ) ; w . printf ( ""   Commands received=%d%n "" , commandsReceived . get ( ) ) ; w . printf ( ""   Last command sent=%s%n "" , new Date ( lastCommandSentAt . get ( ) ) ) ; w . printf ( ""   Last command received=%s%n "" , new Date ( lastCommandReceivedAt . get ( ) ) ) ; synchronized ( pendingCalls ) { w . printf ( ""   Pending calls=%d%n "" , pendingCalls . size ( ) ) ; } }",2017-11-08 18:24:30 +0100,2021/5/6 19:33,37,Other
757,13,https://www.github.com/aosp-mirror/platform_packages_apps_settings,onCreate(Bundle),,196,196,196,196,TODO(b/188847063): replace with real flag when ready,https://www.github.com/aosp-mirror/platform_packages_apps_settings/commit/a8808f73688d,https://www.github.com/aosp-mirror/platform_packages_apps_settings/commit/c702e1bfba0ae4f1fd4fa9bbf4fa27c189ef82e1,src/com/android/settings/biometrics/BiometricEnrollActivity.java,"@Override
public void onCreate(@Nullable Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
if (this instanceof InternalActivity) {
mUserId = getIntent().getIntExtra(Intent.EXTRA_USER_ID, UserHandle.myUserId());
if (BiometricUtils.containsGatekeeperPasswordHandle(getIntent())) {
mGkPwHandle = BiometricUtils.getGatekeeperPasswordHandle(getIntent());
}
}
if (savedInstanceState != null) {
mConfirmingCredentials = savedInstanceState.getBoolean(
                    SAVED_STATE_CONFIRMING_CREDENTIALS, false);
mIsEnrollActionLogged = savedInstanceState.getBoolean(
                    SAVED_STATE_ENROLL_ACTION_LOGGED, false);
mParentalOptions = savedInstanceState.getBundle(SAVED_STATE_PARENTAL_OPTIONS);
if (savedInstanceState.containsKey(SAVED_STATE_GK_PW_HANDLE)) {
mGkPwHandle = savedInstanceState.getLong(SAVED_STATE_GK_PW_HANDLE);
}
}
// Log a framework stats event if this activity was launched via intent action.
final Intent intent = getIntent();
if (!mIsEnrollActionLogged && ACTION_BIOMETRIC_ENROLL.equals(intent.getAction())) {
mIsEnrollActionLogged = true;
// Get the current status for each authenticator type.
@BiometricError final int strongBiometricStatus;
@BiometricError final int weakBiometricStatus;
@BiometricError final int deviceCredentialStatus;
final BiometricManager bm = getSystemService(BiometricManager.class);
if (bm != null) {
strongBiometricStatus = bm.canAuthenticate(Authenticators.BIOMETRIC_STRONG);
weakBiometricStatus = bm.canAuthenticate(Authenticators.BIOMETRIC_WEAK);
deviceCredentialStatus = bm.canAuthenticate(Authenticators.DEVICE_CREDENTIAL);
} else {
strongBiometricStatus = BiometricManager.BIOMETRIC_ERROR_NO_HARDWARE;
weakBiometricStatus = BiometricManager.BIOMETRIC_ERROR_NO_HARDWARE;
deviceCredentialStatus = BiometricManager.BIOMETRIC_ERROR_NO_HARDWARE;
}
FrameworkStatsLog.write(FrameworkStatsLog.AUTH_ENROLL_ACTION_INVOKED,
                    strongBiometricStatus == BiometricManager.BIOMETRIC_SUCCESS,
                    weakBiometricStatus == BiometricManager.BIOMETRIC_SUCCESS,
                    deviceCredentialStatus == BiometricManager.BIOMETRIC_SUCCESS,
                    intent.hasExtra(EXTRA_BIOMETRIC_AUTHENTICATORS_ALLOWED),
                    intent.getIntExtra(EXTRA_BIOMETRIC_AUTHENTICATORS_ALLOWED, 0));
}
// Put the theme in the intent so it gets propagated to other activities in the flow
if (intent.getStringExtra(WizardManagerHelper.EXTRA_THEME) == null) {
intent.putExtra(
                    WizardManagerHelper.EXTRA_THEME,
                    SetupWizardUtils.getThemeString(intent));
}
final PackageManager pm = getApplicationContext().getPackageManager();
mHasFeatureFingerprint = pm.hasSystemFeature(PackageManager.FEATURE_FINGERPRINT);
mHasFeatureFace = pm.hasSystemFeature(PackageManager.FEATURE_FACE);
// determine what can be enrolled
final boolean isSetupWizard = WizardManagerHelper.isAnySetupWizard(getIntent());
if (mHasFeatureFace) {
final FaceManager faceManager = getSystemService(FaceManager.class);
final List<FaceSensorPropertiesInternal> faceProperties =
                    faceManager.getSensorPropertiesInternal();
if (!faceProperties.isEmpty()) {
final int maxEnrolls =
                        isSetupWizard ? 1 : faceProperties.get(0).maxEnrollmentsPerUser;
mIsFaceEnrollable =
faceManager.getEnrolledFaces(mUserId).size() < maxEnrolls;
}
}
if (mHasFeatureFingerprint) {
final FingerprintManager fpManager = getSystemService(FingerprintManager.class);
final List<FingerprintSensorPropertiesInternal> fpProperties =
                    fpManager.getSensorPropertiesInternal();
if (!fpProperties.isEmpty()) {
final int maxEnrolls =
                        isSetupWizard ? 1 : fpProperties.get(0).maxEnrollmentsPerUser;
mIsFingerprintEnrollable =
fpManager.getEnrolledFingerprints(mUserId).size() < maxEnrolls;
}
}
// TODO(b/188847063): replace with real flag when ready
mParentalOptionsRequired = intent.getBooleanExtra(
                BiometricEnrollActivity.EXTRA_REQUIRE_PARENTAL_CONSENT, false);
if (mParentalOptionsRequired && mParentalOptions == null) {
mParentalConsentHelper = new ParentalConsentHelper(
                    mIsFaceEnrollable, mIsFingerprintEnrollable, mGkPwHandle);
setOrConfirmCredentialsNow();
} else {
startEnroll();
}
}","@Override
public void onCreate(@Nullable Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
if (this instanceof InternalActivity) {
mUserId = getIntent().getIntExtra(Intent.EXTRA_USER_ID, UserHandle.myUserId());
if (BiometricUtils.containsGatekeeperPasswordHandle(getIntent())) {
mGkPwHandle = BiometricUtils.getGatekeeperPasswordHandle(getIntent());
}
}
if (savedInstanceState != null) {
mConfirmingCredentials = savedInstanceState.getBoolean(
                    SAVED_STATE_CONFIRMING_CREDENTIALS, false);
mIsEnrollActionLogged = savedInstanceState.getBoolean(
                    SAVED_STATE_ENROLL_ACTION_LOGGED, false);
mParentalOptions = savedInstanceState.getBundle(SAVED_STATE_PARENTAL_OPTIONS);
if (savedInstanceState.containsKey(SAVED_STATE_GK_PW_HANDLE)) {
mGkPwHandle = savedInstanceState.getLong(SAVED_STATE_GK_PW_HANDLE);
}
}
// Log a framework stats event if this activity was launched via intent action.
final Intent intent = getIntent();
if (!mIsEnrollActionLogged && ACTION_BIOMETRIC_ENROLL.equals(intent.getAction())) {
mIsEnrollActionLogged = true;
// Get the current status for each authenticator type.
@BiometricError final int strongBiometricStatus;
@BiometricError final int weakBiometricStatus;
@BiometricError final int deviceCredentialStatus;
final BiometricManager bm = getSystemService(BiometricManager.class);
if (bm != null) {
strongBiometricStatus = bm.canAuthenticate(Authenticators.BIOMETRIC_STRONG);
weakBiometricStatus = bm.canAuthenticate(Authenticators.BIOMETRIC_WEAK);
deviceCredentialStatus = bm.canAuthenticate(Authenticators.DEVICE_CREDENTIAL);
} else {
strongBiometricStatus = BiometricManager.BIOMETRIC_ERROR_NO_HARDWARE;
weakBiometricStatus = BiometricManager.BIOMETRIC_ERROR_NO_HARDWARE;
deviceCredentialStatus = BiometricManager.BIOMETRIC_ERROR_NO_HARDWARE;
}
FrameworkStatsLog.write(FrameworkStatsLog.AUTH_ENROLL_ACTION_INVOKED,
                    strongBiometricStatus == BiometricManager.BIOMETRIC_SUCCESS,
                    weakBiometricStatus == BiometricManager.BIOMETRIC_SUCCESS,
                    deviceCredentialStatus == BiometricManager.BIOMETRIC_SUCCESS,
                    intent.hasExtra(EXTRA_BIOMETRIC_AUTHENTICATORS_ALLOWED),
                    intent.getIntExtra(EXTRA_BIOMETRIC_AUTHENTICATORS_ALLOWED, 0));
}
// Put the theme in the intent so it gets propagated to other activities in the flow
if (intent.getStringExtra(WizardManagerHelper.EXTRA_THEME) == null) {
intent.putExtra(
                    WizardManagerHelper.EXTRA_THEME,
                    SetupWizardUtils.getThemeString(intent));
}
final PackageManager pm = getApplicationContext().getPackageManager();
mHasFeatureFingerprint = pm.hasSystemFeature(PackageManager.FEATURE_FINGERPRINT);
mHasFeatureFace = pm.hasSystemFeature(PackageManager.FEATURE_FACE);
// determine what can be enrolled
final boolean isSetupWizard = WizardManagerHelper.isAnySetupWizard(getIntent());
if (mHasFeatureFace) {
final FaceManager faceManager = getSystemService(FaceManager.class);
final List<FaceSensorPropertiesInternal> faceProperties =
                    faceManager.getSensorPropertiesInternal();
if (!faceProperties.isEmpty()) {
final int maxEnrolls =
                        isSetupWizard ? 1 : faceProperties.get(0).maxEnrollmentsPerUser;
mIsFaceEnrollable =
faceManager.getEnrolledFaces(mUserId).size() < maxEnrolls;
}
}
if (mHasFeatureFingerprint) {
final FingerprintManager fpManager = getSystemService(FingerprintManager.class);
final List<FingerprintSensorPropertiesInternal> fpProperties =
                    fpManager.getSensorPropertiesInternal();
if (!fpProperties.isEmpty()) {
final int maxEnrolls =
                        isSetupWizard ? 1 : fpProperties.get(0).maxEnrollmentsPerUser;
mIsFingerprintEnrollable =
fpManager.getEnrolledFingerprints(mUserId).size() < maxEnrolls;
}
}
mParentalOptionsRequired = intent.getBooleanExtra(EXTRA_REQUIRE_PARENTAL_CONSENT, false);
mSkipReturnToParent = intent.getBooleanExtra(EXTRA_SKIP_RETURN_TO_PARENT, false);
Log.d(TAG, ""parentalOptionsRequired: "" + mParentalOptionsRequired
+ "", skipReturnToParent: "" + mSkipReturnToParent);
if (mParentalOptionsRequired && mParentalOptions == null) {
mParentalConsentHelper = new ParentalConsentHelper(
                    mIsFaceEnrollable, mIsFingerprintEnrollable, mGkPwHandle);
setOrConfirmCredentialsNow();
} else {
startEnroll();
}
}","@ Override public void onCreate  ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; if ( this instanceof InternalActivity ) { mUserId = getIntent ( ) . getIntExtra ( Intent . EXTRA_USER_ID , UserHandle . myUserId ( ) ) ; if ( BiometricUtils . containsGatekeeperPasswordHandle ( getIntent ( ) ) ) { mGkPwHandle = BiometricUtils . getGatekeeperPasswordHandle ( getIntent ( ) ) ; } } if ( savedInstanceState != null ) { mConfirmingCredentials = savedInstanceState . getBoolean ( SAVED_STATE_CONFIRMING_CREDENTIALS , false ) ; mIsEnrollActionLogged = savedInstanceState . getBoolean ( SAVED_STATE_ENROLL_ACTION_LOGGED , false ) ; mParentalOptions = savedInstanceState . getBundle ( SAVED_STATE_PARENTAL_OPTIONS ) ; if ( savedInstanceState . containsKey ( SAVED_STATE_GK_PW_HANDLE ) ) { mGkPwHandle = savedInstanceState . getLong ( SAVED_STATE_GK_PW_HANDLE ) ; } } // Log a framework stats event if this activity was launched via intent action. final Intent intent = getIntent ( ) ; if ( ! mIsEnrollActionLogged && ACTION_BIOMETRIC_ENROLL . equals ( intent . getAction ( ) ) ) { mIsEnrollActionLogged = true ; // Get the current status for each authenticator type. @ BiometricError final int strongBiometricStatus ; @ BiometricError final int weakBiometricStatus ; @ BiometricError final int deviceCredentialStatus ; final BiometricManager bm = getSystemService ( BiometricManager . class ) ; if ( bm != null ) { strongBiometricStatus = bm . canAuthenticate ( Authenticators . BIOMETRIC_STRONG ) ; weakBiometricStatus = bm . canAuthenticate ( Authenticators . BIOMETRIC_WEAK ) ; deviceCredentialStatus = bm . canAuthenticate ( Authenticators . DEVICE_CREDENTIAL ) ; } else { strongBiometricStatus = BiometricManager . BIOMETRIC_ERROR_NO_HARDWARE ; weakBiometricStatus = BiometricManager . BIOMETRIC_ERROR_NO_HARDWARE ; deviceCredentialStatus = BiometricManager . BIOMETRIC_ERROR_NO_HARDWARE ; } FrameworkStatsLog . write ( FrameworkStatsLog . AUTH_ENROLL_ACTION_INVOKED , strongBiometricStatus == BiometricManager . BIOMETRIC_SUCCESS , weakBiometricStatus == BiometricManager . BIOMETRIC_SUCCESS , deviceCredentialStatus == BiometricManager . BIOMETRIC_SUCCESS , intent . hasExtra ( EXTRA_BIOMETRIC_AUTHENTICATORS_ALLOWED ) , intent . getIntExtra ( EXTRA_BIOMETRIC_AUTHENTICATORS_ALLOWED , 0 ) ) ; } // Put the theme in the intent so it gets propagated to other activities in the flow if ( intent . getStringExtra ( WizardManagerHelper . EXTRA_THEME ) == null ) { intent . putExtra ( WizardManagerHelper . EXTRA_THEME , SetupWizardUtils . getThemeString ( intent ) ) ; } final PackageManager pm = getApplicationContext ( ) . getPackageManager ( ) ; mHasFeatureFingerprint = pm . hasSystemFeature ( PackageManager . FEATURE_FINGERPRINT ) ; mHasFeatureFace = pm . hasSystemFeature ( PackageManager . FEATURE_FACE ) ; // determine what can be enrolled final boolean isSetupWizard = WizardManagerHelper . isAnySetupWizard ( getIntent ( ) ) ; if ( mHasFeatureFace ) { final FaceManager faceManager = getSystemService ( FaceManager . class ) ; final List < FaceSensorPropertiesInternal > faceProperties = faceManager . getSensorPropertiesInternal ( ) ; if ( ! faceProperties . isEmpty ( ) ) { final int maxEnrolls = isSetupWizard ? 1 : faceProperties . get ( 0 ) . maxEnrollmentsPerUser ; mIsFaceEnrollable = faceManager . getEnrolledFaces ( mUserId ) . size ( ) < maxEnrolls ; } } if ( mHasFeatureFingerprint ) { final FingerprintManager fpManager = getSystemService ( FingerprintManager . class ) ; final List < FingerprintSensorPropertiesInternal > fpProperties = fpManager . getSensorPropertiesInternal ( ) ; if ( ! fpProperties . isEmpty ( ) ) { final int maxEnrolls = isSetupWizard ? 1 : fpProperties . get ( 0 ) . maxEnrollmentsPerUser ; mIsFingerprintEnrollable = fpManager . getEnrolledFingerprints ( mUserId ) . size ( ) < maxEnrolls ; } } // <SATD_START> TODO(b/188847063): replace with real flag when ready <SATD_END> mParentalOptionsRequired = intent . getBooleanExtra ( BiometricEnrollActivity . EXTRA_REQUIRE_PARENTAL_CONSENT , false ) ; if ( mParentalOptionsRequired && mParentalOptions == null ) { mParentalConsentHelper = new ParentalConsentHelper ( mIsFaceEnrollable , mIsFingerprintEnrollable , mGkPwHandle ) ; setOrConfirmCredentialsNow ( ) ; } else { startEnroll ( ) ; } }","@ Override public void onCreate  ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; if ( this instanceof InternalActivity ) { mUserId = getIntent ( ) . getIntExtra ( Intent . EXTRA_USER_ID , UserHandle . myUserId ( ) ) ; if ( BiometricUtils . containsGatekeeperPasswordHandle ( getIntent ( ) ) ) { mGkPwHandle = BiometricUtils . getGatekeeperPasswordHandle ( getIntent ( ) ) ; } } if ( savedInstanceState != null ) { mConfirmingCredentials = savedInstanceState . getBoolean ( SAVED_STATE_CONFIRMING_CREDENTIALS , false ) ; mIsEnrollActionLogged = savedInstanceState . getBoolean ( SAVED_STATE_ENROLL_ACTION_LOGGED , false ) ; mParentalOptions = savedInstanceState . getBundle ( SAVED_STATE_PARENTAL_OPTIONS ) ; if ( savedInstanceState . containsKey ( SAVED_STATE_GK_PW_HANDLE ) ) { mGkPwHandle = savedInstanceState . getLong ( SAVED_STATE_GK_PW_HANDLE ) ; } } // Log a framework stats event if this activity was launched via intent action. final Intent intent = getIntent ( ) ; if ( ! mIsEnrollActionLogged && ACTION_BIOMETRIC_ENROLL . equals ( intent . getAction ( ) ) ) { mIsEnrollActionLogged = true ; // Get the current status for each authenticator type. @ BiometricError final int strongBiometricStatus ; @ BiometricError final int weakBiometricStatus ; @ BiometricError final int deviceCredentialStatus ; final BiometricManager bm = getSystemService ( BiometricManager . class ) ; if ( bm != null ) { strongBiometricStatus = bm . canAuthenticate ( Authenticators . BIOMETRIC_STRONG ) ; weakBiometricStatus = bm . canAuthenticate ( Authenticators . BIOMETRIC_WEAK ) ; deviceCredentialStatus = bm . canAuthenticate ( Authenticators . DEVICE_CREDENTIAL ) ; } else { strongBiometricStatus = BiometricManager . BIOMETRIC_ERROR_NO_HARDWARE ; weakBiometricStatus = BiometricManager . BIOMETRIC_ERROR_NO_HARDWARE ; deviceCredentialStatus = BiometricManager . BIOMETRIC_ERROR_NO_HARDWARE ; } FrameworkStatsLog . write ( FrameworkStatsLog . AUTH_ENROLL_ACTION_INVOKED , strongBiometricStatus == BiometricManager . BIOMETRIC_SUCCESS , weakBiometricStatus == BiometricManager . BIOMETRIC_SUCCESS , deviceCredentialStatus == BiometricManager . BIOMETRIC_SUCCESS , intent . hasExtra ( EXTRA_BIOMETRIC_AUTHENTICATORS_ALLOWED ) , intent . getIntExtra ( EXTRA_BIOMETRIC_AUTHENTICATORS_ALLOWED , 0 ) ) ; } // Put the theme in the intent so it gets propagated to other activities in the flow if ( intent . getStringExtra ( WizardManagerHelper . EXTRA_THEME ) == null ) { intent . putExtra ( WizardManagerHelper . EXTRA_THEME , SetupWizardUtils . getThemeString ( intent ) ) ; } final PackageManager pm = getApplicationContext ( ) . getPackageManager ( ) ; mHasFeatureFingerprint = pm . hasSystemFeature ( PackageManager . FEATURE_FINGERPRINT ) ; mHasFeatureFace = pm . hasSystemFeature ( PackageManager . FEATURE_FACE ) ; // determine what can be enrolled final boolean isSetupWizard = WizardManagerHelper . isAnySetupWizard ( getIntent ( ) ) ; if ( mHasFeatureFace ) { final FaceManager faceManager = getSystemService ( FaceManager . class ) ; final List < FaceSensorPropertiesInternal > faceProperties = faceManager . getSensorPropertiesInternal ( ) ; if ( ! faceProperties . isEmpty ( ) ) { final int maxEnrolls = isSetupWizard ? 1 : faceProperties . get ( 0 ) . maxEnrollmentsPerUser ; mIsFaceEnrollable = faceManager . getEnrolledFaces ( mUserId ) . size ( ) < maxEnrolls ; } } if ( mHasFeatureFingerprint ) { final FingerprintManager fpManager = getSystemService ( FingerprintManager . class ) ; final List < FingerprintSensorPropertiesInternal > fpProperties = fpManager . getSensorPropertiesInternal ( ) ; if ( ! fpProperties . isEmpty ( ) ) { final int maxEnrolls = isSetupWizard ? 1 : fpProperties . get ( 0 ) . maxEnrollmentsPerUser ; mIsFingerprintEnrollable = fpManager . getEnrolledFingerprints ( mUserId ) . size ( ) < maxEnrolls ; } } mParentalOptionsRequired = intent . getBooleanExtra ( EXTRA_REQUIRE_PARENTAL_CONSENT , false ) ; mSkipReturnToParent = intent . getBooleanExtra ( EXTRA_SKIP_RETURN_TO_PARENT , false ) ; Log . d ( TAG , "" parentalOptionsRequired:  "" + mParentalOptionsRequired + "" , skipReturnToParent:  "" + mSkipReturnToParent ) ; if ( mParentalOptionsRequired && mParentalOptions == null ) { mParentalConsentHelper = new ParentalConsentHelper ( mIsFaceEnrollable , mIsFingerprintEnrollable , mGkPwHandle ) ; setOrConfirmCredentialsNow ( ) ; } else { startEnroll ( ) ; } }",2021/6/16 9:58,2021/7/2 12:04,1,Other
613,76,https://www.github.com/ushahidi/ushahidi_android,onCreate(Bundle),DESIGN,303,303,311,311,TODO look into how to user xml R.string for that,https://www.github.com/ushahidi/ushahidi_android/commit/e5deae0ae,https://www.github.com/ushahidi/ushahidi_android/commit/728a268ed1413728eea687cdd2e86400885d4f4c,src/org/addhen/ushahidi/AddIncident.java,"private void initComponents(){
btnPicture = (Button) findViewById(R.id.btnPicture);
btnAddCategory = (Button) findViewById(R.id.add_category);
incidentTitle = (EditText) findViewById(R.id.incident_title);
incidentLocation = (EditText) findViewById(R.id.incident_location);
incidentDesc = (EditText) findViewById(R.id.incident_desc);
btnSend = (Button) findViewById(R.id.incident_add_btn);
btnCancel = (Button) findViewById(R.id.incident_add_cancel);
incidentDate = (TextView) findViewById(R.id.lbl_date);
pickDate = (Button) findViewById(R.id.pick_date);
pickTime = (Button) findViewById(R.id.pick_time);
addLocation = (Button) findViewById(R.id.location);
bundle = new Bundle();
extras = this.getIntent().getExtras();
if( extras != null ) {
bundle = extras.getBundle(""locations"");
incidentLocation.setText( bundle.getString(""location""));
AddIncident.latitude = bundle.getDouble(""latitude"");
AddIncident.longitude = bundle.getDouble(""longitude"");
}
//open location map window
addLocation.setOnClickListener( new View.OnClickListener(){
			public void onClick( View v ) {
Intent intent = new Intent( AddIncident.this,LocationMap.class);
startActivityForResult(intent,VIEW_MAP);
setResult( RESULT_OK, intent );
}
		});
btnSend.setOnClickListener(new View.OnClickListener() {
			public void onClick(View v){
//TODO send http post with data
if( TextUtils.isEmpty(incidentTitle.getText())) {
//TODO look into how to use xml R.string for that
errorMessage =""* Enter a title for the incident.\n"";
error = true;
}
if( TextUtils.isEmpty(incidentDesc.getText())) {
//TODO look into how to use xml R.string for that
errorMessage += ""* Enter a description for the incident.\n"";
error = true;
}
if( TextUtils.isEmpty(incidentLocation.getText())) {
//TODO look into how to use xml R.string for that
errorMessage += ""* Enter a location for the incident.\n"";
error = true;
}
if(!categoryClicked) {
//TODO look into how to user xml R.string for that
errorMessage += ""* Select at least one category.\n"";
error = true;
}
if( !error ) {
if( Util.isConnected(AddIncident.this) ){
if( !postToOnline() ) {
mHandler.post(mSentIncidentFail);
}else {
mHandler.post(mSentIncidentSuccess);
clearFields();
//after a successful upload, delete the file
File f = new File(UshahidiService.savePath + UshahidiService.fileName);
if(f.exists()){
f.delete();
}
}
}else {
final Thread tr = new Thread() {
						@Override
public void run() {
running = true;
try {
mHandler.post(mSentIncidentOffline);
} finally {
running = false;
}
}
					};
tr.start();
}
}else{
final Toast t = Toast.makeText(AddIncident.this,
							""Error!\n\n""+ errorMessage,
							Toast.LENGTH_LONG);
t.show();
errorMessage = """";
}
}
			});
btnPicture.setOnClickListener(new View.OnClickListener() {
			public void onClick(View v) {
showDialog(DIALOG_CHOOSE_IMAGE_METHOD);
}
		});
btnCancel.setOnClickListener( new View.OnClickListener() {
			public void onClick(View v) {
clearFields();
Intent intent = new Intent( AddIncident.this,Ushahidi.class);
startActivityForResult( intent, GOTOHOME );
setResult(RESULT_OK);
finish();
}
		});
btnAddCategory.setOnClickListener(new View.OnClickListener() {
			public void onClick(View v) {
showDialog(DIALOG_MULTIPLE_CATEGORY);
counter++;
}
		});
pickDate.setOnClickListener(new View.OnClickListener() {

            public void onClick(View v) {
showDialog(DATE_DIALOG_ID);
}
        });
pickTime.setOnClickListener(new View.OnClickListener() {

            public void onClick(View v) {
showDialog(TIME_DIALOG_ID);
}
        });
final Calendar c = Calendar.getInstance();
mYear = c.get(Calendar.YEAR);
mMonth = c.get(Calendar.MONTH);
mDay = c.get(Calendar.DAY_OF_MONTH);
mHour = c.get(Calendar.HOUR_OF_DAY);
mMinute = c.get(Calendar.MINUTE);
mAmPm = c.get(Calendar.AM_PM);
updateDisplay();
}","private void initComponents(){
btnPicture = (Button) findViewById(R.id.btnPicture);
btnAddCategory = (Button) findViewById(R.id.add_category);
incidentTitle = (EditText) findViewById(R.id.incident_title);
incidentLocation = (EditText) findViewById(R.id.incident_location);
incidentDesc = (EditText) findViewById(R.id.incident_desc);
btnSend = (Button) findViewById(R.id.incident_add_btn);
btnCancel = (Button) findViewById(R.id.incident_add_cancel);
incidentDate = (TextView) findViewById(R.id.lbl_date);
pickDate = (Button) findViewById(R.id.pick_date);
pickTime = (Button) findViewById(R.id.pick_time);
addLocation = (Button) findViewById(R.id.location);
bundle = new Bundle();
extras = this.getIntent().getExtras();
if( extras != null ) {
bundle = extras.getBundle(""locations"");
incidentLocation.setText( bundle.getString(""location""));
AddIncident.latitude = bundle.getDouble(""latitude"");
AddIncident.longitude = bundle.getDouble(""longitude"");
}
//open location map window
addLocation.setOnClickListener( new View.OnClickListener(){
			public void onClick( View v ) {
Intent intent = new Intent( AddIncident.this,LocationMap.class);
startActivityForResult(intent,VIEW_MAP);
setResult( RESULT_OK, intent );
}
		});
btnSend.setOnClickListener(new View.OnClickListener() {
			public void onClick(View v){
//Dipo Fix
error = false;
if( TextUtils.isEmpty(incidentTitle.getText())) {
//TODO look into how to use xml R.string for that
errorMessage =""* Enter a title for the incident.\n"";
error = true;
}
if( TextUtils.isEmpty(incidentDesc.getText())) {
//TODO look into how to use xml R.string for that
errorMessage += ""* Enter a description for the incident.\n"";
error = true;
}
if( TextUtils.isEmpty(incidentLocation.getText())) {
//TODO look into how to use xml R.string for that
errorMessage += ""* Enter a location for the incident.\n"";
error = true;
}
//Dipo Fix
if(vectorCategories.size() == 0) {
//TODO look into how to use xml R.string for that
errorMessage += ""* Select at least one category.\n"";
error = true;
}
if( !error ) {
if( Util.isConnected(AddIncident.this) ){
if( !postToOnline() ) {
mHandler.post(mSentIncidentFail);
}else {
mHandler.post(mSentIncidentSuccess);
clearFields();
//after a successful upload, delete the file
File f = new File(UshahidiService.savePath + UshahidiService.fileName);
if(f.exists()){
f.delete();
}
}
}else {
final Thread tr = new Thread() {
						@Override
public void run() {
running = true;
try {
mHandler.post(mSentIncidentOffline);
} finally {
running = false;
}
}
					};
tr.start();
}
}else{
final Toast t = Toast.makeText(AddIncident.this,
							""Error!\n\n""+ errorMessage,
							Toast.LENGTH_LONG);
t.show();
errorMessage = """";
}
}
			});
btnPicture.setOnClickListener(new View.OnClickListener() {
			public void onClick(View v) {
showDialog(DIALOG_CHOOSE_IMAGE_METHOD);
}
		});
btnCancel.setOnClickListener( new View.OnClickListener() {
			public void onClick(View v) {
clearFields();
Intent intent = new Intent( AddIncident.this,Ushahidi.class);
startActivityForResult( intent, GOTOHOME );
setResult(RESULT_OK);
finish();
}
		});
btnAddCategory.setOnClickListener(new View.OnClickListener() {
			public void onClick(View v) {
showDialog(DIALOG_MULTIPLE_CATEGORY);
counter++;
}
		});
pickDate.setOnClickListener(new View.OnClickListener() {

            public void onClick(View v) {
showDialog(DATE_DIALOG_ID);
}
        });
pickTime.setOnClickListener(new View.OnClickListener() {

            public void onClick(View v) {
showDialog(TIME_DIALOG_ID);
}
        });
final Calendar c = Calendar.getInstance();
mYear = c.get(Calendar.YEAR);
mMonth = c.get(Calendar.MONTH);
mDay = c.get(Calendar.DAY_OF_MONTH);
mHour = c.get(Calendar.HOUR_OF_DAY);
mMinute = c.get(Calendar.MINUTE);
mAmPm = c.get(Calendar.AM_PM);
updateDisplay();
}","private void initComponents  ( ) { btnPicture = ( Button ) findViewById ( R . id . btnPicture ) ; btnAddCategory = ( Button ) findViewById ( R . id . add_category ) ; incidentTitle = ( EditText ) findViewById ( R . id . incident_title ) ; incidentLocation = ( EditText ) findViewById ( R . id . incident_location ) ; incidentDesc = ( EditText ) findViewById ( R . id . incident_desc ) ; btnSend = ( Button ) findViewById ( R . id . incident_add_btn ) ; btnCancel = ( Button ) findViewById ( R . id . incident_add_cancel ) ; incidentDate = ( TextView ) findViewById ( R . id . lbl_date ) ; pickDate = ( Button ) findViewById ( R . id . pick_date ) ; pickTime = ( Button ) findViewById ( R . id . pick_time ) ; addLocation = ( Button ) findViewById ( R . id . location ) ; bundle = new Bundle ( ) ; extras = this . getIntent ( ) . getExtras ( ) ; if ( extras != null ) { bundle = extras . getBundle ( "" locations "" ) ; incidentLocation . setText ( bundle . getString ( "" location "" ) ) ; AddIncident . latitude = bundle . getDouble ( "" latitude "" ) ; AddIncident . longitude = bundle . getDouble ( "" longitude "" ) ; } //open location map window addLocation . setOnClickListener ( new View . OnClickListener ( ) { public void onClick ( View v ) { Intent intent = new Intent ( AddIncident . this , LocationMap . class ) ; startActivityForResult ( intent , VIEW_MAP ) ; setResult ( RESULT_OK , intent ) ; } } ) ; btnSend . setOnClickListener ( new View . OnClickListener ( ) { public void onClick ( View v ) { //TODO send http post with data if ( TextUtils . isEmpty ( incidentTitle . getText ( ) ) ) { //TODO look into how to use xml R.string for that errorMessage = "" * Enter a title for the incident. \n "" ; error = true ; } if ( TextUtils . isEmpty ( incidentDesc . getText ( ) ) ) { //TODO look into how to use xml R.string for that errorMessage += "" * Enter a description for the incident. \n "" ; error = true ; } if ( TextUtils . isEmpty ( incidentLocation . getText ( ) ) ) { //TODO look into how to use xml R.string for that errorMessage += "" * Enter a location for the incident. \n "" ; error = true ; } if ( ! categoryClicked ) { //<SATD_START> TODO look into how to user xml R.string for that <SATD_END> errorMessage += "" * Select at least one category. \n "" ; error = true ; } if ( ! error ) { if ( Util . isConnected ( AddIncident . this ) ) { if ( ! postToOnline ( ) ) { mHandler . post ( mSentIncidentFail ) ; } else { mHandler . post ( mSentIncidentSuccess ) ; clearFields ( ) ; //after a successful upload, delete the file File f = new File ( UshahidiService . savePath + UshahidiService . fileName ) ; if ( f . exists ( ) ) { f . delete ( ) ; } } } else { final Thread tr = new Thread ( ) { @ Override public void run ( ) { running = true ; try { mHandler . post ( mSentIncidentOffline ) ; } finally { running = false ; } } } ; tr . start ( ) ; } } else { final Toast t = Toast . makeText ( AddIncident . this , "" Error! \n \n "" + errorMessage , Toast . LENGTH_LONG ) ; t . show ( ) ; errorMessage = "" "" ; } } } ) ; btnPicture . setOnClickListener ( new View . OnClickListener ( ) { public void onClick ( View v ) { showDialog ( DIALOG_CHOOSE_IMAGE_METHOD ) ; } } ) ; btnCancel . setOnClickListener ( new View . OnClickListener ( ) { public void onClick ( View v ) { clearFields ( ) ; Intent intent = new Intent ( AddIncident . this , Ushahidi . class ) ; startActivityForResult ( intent , GOTOHOME ) ; setResult ( RESULT_OK ) ; finish ( ) ; } } ) ; btnAddCategory . setOnClickListener ( new View . OnClickListener ( ) { public void onClick ( View v ) { showDialog ( DIALOG_MULTIPLE_CATEGORY ) ; counter ++ ; } } ) ; pickDate . setOnClickListener ( new View . OnClickListener ( ) { public void onClick ( View v ) { showDialog ( DATE_DIALOG_ID ) ; } } ) ; pickTime . setOnClickListener ( new View . OnClickListener ( ) { public void onClick ( View v ) { showDialog ( TIME_DIALOG_ID ) ; } } ) ; final Calendar c = Calendar . getInstance ( ) ; mYear = c . get ( Calendar . YEAR ) ; mMonth = c . get ( Calendar . MONTH ) ; mDay = c . get ( Calendar . DAY_OF_MONTH ) ; mHour = c . get ( Calendar . HOUR_OF_DAY ) ; mMinute = c . get ( Calendar . MINUTE ) ; mAmPm = c . get ( Calendar . AM_PM ) ; updateDisplay ( ) ; }","private void initComponents  ( ) { btnPicture = ( Button ) findViewById ( R . id . btnPicture ) ; btnAddCategory = ( Button ) findViewById ( R . id . add_category ) ; incidentTitle = ( EditText ) findViewById ( R . id . incident_title ) ; incidentLocation = ( EditText ) findViewById ( R . id . incident_location ) ; incidentDesc = ( EditText ) findViewById ( R . id . incident_desc ) ; btnSend = ( Button ) findViewById ( R . id . incident_add_btn ) ; btnCancel = ( Button ) findViewById ( R . id . incident_add_cancel ) ; incidentDate = ( TextView ) findViewById ( R . id . lbl_date ) ; pickDate = ( Button ) findViewById ( R . id . pick_date ) ; pickTime = ( Button ) findViewById ( R . id . pick_time ) ; addLocation = ( Button ) findViewById ( R . id . location ) ; bundle = new Bundle ( ) ; extras = this . getIntent ( ) . getExtras ( ) ; if ( extras != null ) { bundle = extras . getBundle ( "" locations "" ) ; incidentLocation . setText ( bundle . getString ( "" location "" ) ) ; AddIncident . latitude = bundle . getDouble ( "" latitude "" ) ; AddIncident . longitude = bundle . getDouble ( "" longitude "" ) ; } //open location map window addLocation . setOnClickListener ( new View . OnClickListener ( ) { public void onClick ( View v ) { Intent intent = new Intent ( AddIncident . this , LocationMap . class ) ; startActivityForResult ( intent , VIEW_MAP ) ; setResult ( RESULT_OK , intent ) ; } } ) ; btnSend . setOnClickListener ( new View . OnClickListener ( ) { public void onClick ( View v ) { //Dipo Fix error = false ; if ( TextUtils . isEmpty ( incidentTitle . getText ( ) ) ) { //TODO look into how to use xml R.string for that errorMessage = "" * Enter a title for the incident. \n "" ; error = true ; } if ( TextUtils . isEmpty ( incidentDesc . getText ( ) ) ) { //TODO look into how to use xml R.string for that errorMessage += "" * Enter a description for the incident. \n "" ; error = true ; } if ( TextUtils . isEmpty ( incidentLocation . getText ( ) ) ) { //TODO look into how to use xml R.string for that errorMessage += "" * Enter a location for the incident. \n "" ; error = true ; } //Dipo Fix if ( vectorCategories . size ( ) == 0 ) { //TODO look into how to use xml R.string for that errorMessage += "" * Select at least one category. \n "" ; error = true ; } if ( ! error ) { if ( Util . isConnected ( AddIncident . this ) ) { if ( ! postToOnline ( ) ) { mHandler . post ( mSentIncidentFail ) ; } else { mHandler . post ( mSentIncidentSuccess ) ; clearFields ( ) ; //after a successful upload, delete the file File f = new File ( UshahidiService . savePath + UshahidiService . fileName ) ; if ( f . exists ( ) ) { f . delete ( ) ; } } } else { final Thread tr = new Thread ( ) { @ Override public void run ( ) { running = true ; try { mHandler . post ( mSentIncidentOffline ) ; } finally { running = false ; } } } ; tr . start ( ) ; } } else { final Toast t = Toast . makeText ( AddIncident . this , "" Error! \n \n "" + errorMessage , Toast . LENGTH_LONG ) ; t . show ( ) ; errorMessage = "" "" ; } } } ) ; btnPicture . setOnClickListener ( new View . OnClickListener ( ) { public void onClick ( View v ) { showDialog ( DIALOG_CHOOSE_IMAGE_METHOD ) ; } } ) ; btnCancel . setOnClickListener ( new View . OnClickListener ( ) { public void onClick ( View v ) { clearFields ( ) ; Intent intent = new Intent ( AddIncident . this , Ushahidi . class ) ; startActivityForResult ( intent , GOTOHOME ) ; setResult ( RESULT_OK ) ; finish ( ) ; } } ) ; btnAddCategory . setOnClickListener ( new View . OnClickListener ( ) { public void onClick ( View v ) { showDialog ( DIALOG_MULTIPLE_CATEGORY ) ; counter ++ ; } } ) ; pickDate . setOnClickListener ( new View . OnClickListener ( ) { public void onClick ( View v ) { showDialog ( DATE_DIALOG_ID ) ; } } ) ; pickTime . setOnClickListener ( new View . OnClickListener ( ) { public void onClick ( View v ) { showDialog ( TIME_DIALOG_ID ) ; } } ) ; final Calendar c = Calendar . getInstance ( ) ; mYear = c . get ( Calendar . YEAR ) ; mMonth = c . get ( Calendar . MONTH ) ; mDay = c . get ( Calendar . DAY_OF_MONTH ) ; mHour = c . get ( Calendar . HOUR_OF_DAY ) ; mMinute = c . get ( Calendar . MINUTE ) ; mAmPm = c . get ( Calendar . AM_PM ) ; updateDisplay ( ) ; }",2009-05-25 03:15:45 +0000,2010-04-04 17:45:54 +0000,1,Other
396,736,https://www.github.com/chocoteam/choco-solver,HK_Pascals(),,201,201,203,203,TODO remettre ou pas?,https://www.github.com/chocoteam/choco-solver/commit/9036189fff,https://www.github.com/chocoteam/choco-solver/commit/31ddf3ce6e36bbb1f561c6544626b48d236e28b8,solver/src/main/java/solver/constraints/propagators/gary/tsp/directed/relaxationHeldKarp/PropHeldKarp.java,"protected void HK_Pascals() throws ContradictionException {
double hkb;
double alpha = 2;
double beta = 0.5;
double bestHKB;
boolean improved;
int count = 2;
bestHKB = 0;
HKfilter.computeMST(costs,g.getEnvelopGraph());
hkb = HKfilter.getBound()-totalPenalities;
bestHKB = hkb;
mst = HKfilter.getMST();
if(hkb-Math.floor(hkb)<0.001){
hkb = Math.floor(hkb);
}
obj.updateLowerBound((int)Math.ceil(hkb), this);
HKfilter.performPruning((double) (obj.getUB()) + totalPenalities + 0.001);
for(int iter=5;iter>0;iter--){
improved = false;
for(int i=nbSprints;i>0;i--){
HK.computeMST(costs,g.getEnvelopGraph());
hkb = HK.getBound()-totalPenalities;
if(hkb>bestHKB+1){
bestHKB = hkb;
improved = true;
}
mst = HK.getMST();
if(hkb-Math.floor(hkb)<0.001){
hkb = Math.floor(hkb);
}
obj.updateLowerBound((int)Math.ceil(hkb), this);
//	DO NOT FILTER HERE TO FASTEN CONVERGENCE (not always true)
//				HK.performPruning((double) (obj.getUB()) + totalPenalities + 0.001);
updateStep(hkb,alpha);
HKPenalities();
updateCostMatrix();
}
HKfilter.computeMST(costs,g.getEnvelopGraph());
hkb = HKfilter.getBound()-totalPenalities;
if(hkb>bestHKB+1){
bestHKB = hkb;
improved = true;
}
mst = HKfilter.getMST();
if(hkb-Math.floor(hkb)<0.001){
hkb = Math.floor(hkb);
}
obj.updateLowerBound((int)Math.ceil(hkb), this);
//			if(tourFound()){// TODO attention si contraintes autres que TSP ca devient faux
//				forceTourInstantiation();
//				return;
//			}
HKfilter.performPruning((double) (obj.getUB()) + totalPenalities + 0.001);
updateStep(hkb,alpha);
HKPenalities();
updateCostMatrix();
if(!improved){
count--;
if(count==0){
return;
}
}
alpha *= beta;
beta /= 2; // TODO remettre ou pas?
}
}","protected void HK_Pascals() throws ContradictionException {
double hkb;
double alpha = 2;
double beta = 0.5;
double bestHKB;
boolean improved;
int count = 2;
bestHKB = 0;
HKfilter.computeMST(costs,g.getEnvelopGraph());
hkb = HKfilter.getBound()-totalPenalities;
bestHKB = hkb;
mst = HKfilter.getMST();
if(hkb-Math.floor(hkb)<0.001){
hkb = Math.floor(hkb);
}
obj.updateLowerBound((int)Math.ceil(hkb), this);
HKfilter.performPruning((double) (obj.getUB()) + totalPenalities + 0.001);
for(int iter=5;iter>0;iter--){
improved = false;
for(int i=nbSprints;i>0;i--){
HK.computeMST(costs,g.getEnvelopGraph());
hkb = HK.getBound()-totalPenalities;
if(hkb>bestHKB+1){
bestHKB = hkb;
improved = true;
}
mst = HK.getMST();
if(hkb-Math.floor(hkb)<0.001){
hkb = Math.floor(hkb);
}
obj.updateLowerBound((int)Math.ceil(hkb), this);
//	DO NOT FILTER HERE TO FASTEN CONVERGENCE (not always true)
//				HK.performPruning((double) (obj.getUB()) + totalPenalities + 0.001);
updateStep(hkb,alpha);
HKPenalities();
updateCostMatrix();
}
HKfilter.computeMST(costs,g.getEnvelopGraph());
hkb = HKfilter.getBound()-totalPenalities;
if(hkb>bestHKB+1){
bestHKB = hkb;
improved = true;
}
mst = HKfilter.getMST();
if(hkb-Math.floor(hkb)<0.001){
hkb = Math.floor(hkb);
}
obj.updateLowerBound((int)Math.ceil(hkb), this);
//			if(tourFound()){// TODO attention si contraintes autres que TSP ca devient faux
//				forceTourInstantiation();
//				return;
//			}
HKfilter.performPruning((double) (obj.getUB()) + totalPenalities + 0.001);
updateStep(hkb,alpha);
HKPenalities();
updateCostMatrix();
if(!improved){
count--;
if(count==0){
return;
}
}
alpha *= beta;
beta /= 2;
if(sccOf!=null)return;// not too heavy approach
}
}","protected void HK_Pascals  ( ) throws ContradictionException { double hkb ; double alpha = 2 ; double beta = 0.5 ; double bestHKB ; boolean improved ; int count = 2 ; bestHKB = 0 ; HKfilter . computeMST ( costs , g . getEnvelopGraph ( ) ) ; hkb = HKfilter . getBound ( ) - totalPenalities ; bestHKB = hkb ; mst = HKfilter . getMST ( ) ; if ( hkb - Math . floor ( hkb ) < 0.001 ) { hkb = Math . floor ( hkb ) ; } obj . updateLowerBound ( ( int ) Math . ceil ( hkb ) , this ) ; HKfilter . performPruning ( ( double ) ( obj . getUB ( ) ) + totalPenalities + 0.001 ) ; for ( int iter = 5 ; iter > 0 ; iter -- ) { improved = false ; for ( int i = nbSprints ; i > 0 ; i -- ) { HK . computeMST ( costs , g . getEnvelopGraph ( ) ) ; hkb = HK . getBound ( ) - totalPenalities ; if ( hkb > bestHKB + 1 ) { bestHKB = hkb ; improved = true ; } mst = HK . getMST ( ) ; if ( hkb - Math . floor ( hkb ) < 0.001 ) { hkb = Math . floor ( hkb ) ; } obj . updateLowerBound ( ( int ) Math . ceil ( hkb ) , this ) ; //	DO NOT FILTER HERE TO FASTEN CONVERGENCE (not always true) //				HK.performPruning((double) (obj.getUB()) + totalPenalities + 0.001); updateStep ( hkb , alpha ) ; HKPenalities ( ) ; updateCostMatrix ( ) ; } HKfilter . computeMST ( costs , g . getEnvelopGraph ( ) ) ; hkb = HKfilter . getBound ( ) - totalPenalities ; if ( hkb > bestHKB + 1 ) { bestHKB = hkb ; improved = true ; } mst = HKfilter . getMST ( ) ; if ( hkb - Math . floor ( hkb ) < 0.001 ) { hkb = Math . floor ( hkb ) ; } obj . updateLowerBound ( ( int ) Math . ceil ( hkb ) , this ) ; //			if(tourFound()){// TODO attention si contraintes autres que TSP ca devient faux //				forceTourInstantiation(); //				return; //			} HKfilter . performPruning ( ( double ) ( obj . getUB ( ) ) + totalPenalities + 0.001 ) ; updateStep ( hkb , alpha ) ; HKPenalities ( ) ; updateCostMatrix ( ) ; if ( ! improved ) { count -- ; if ( count == 0 ) { return ; } } alpha *= beta ; beta /= 2 ; // <SATD_START> TODO remettre ou pas? <SATD_END> } }","protected void HK_Pascals  ( ) throws ContradictionException { double hkb ; double alpha = 2 ; double beta = 0.5 ; double bestHKB ; boolean improved ; int count = 2 ; bestHKB = 0 ; HKfilter . computeMST ( costs , g . getEnvelopGraph ( ) ) ; hkb = HKfilter . getBound ( ) - totalPenalities ; bestHKB = hkb ; mst = HKfilter . getMST ( ) ; if ( hkb - Math . floor ( hkb ) < 0.001 ) { hkb = Math . floor ( hkb ) ; } obj . updateLowerBound ( ( int ) Math . ceil ( hkb ) , this ) ; HKfilter . performPruning ( ( double ) ( obj . getUB ( ) ) + totalPenalities + 0.001 ) ; for ( int iter = 5 ; iter > 0 ; iter -- ) { improved = false ; for ( int i = nbSprints ; i > 0 ; i -- ) { HK . computeMST ( costs , g . getEnvelopGraph ( ) ) ; hkb = HK . getBound ( ) - totalPenalities ; if ( hkb > bestHKB + 1 ) { bestHKB = hkb ; improved = true ; } mst = HK . getMST ( ) ; if ( hkb - Math . floor ( hkb ) < 0.001 ) { hkb = Math . floor ( hkb ) ; } obj . updateLowerBound ( ( int ) Math . ceil ( hkb ) , this ) ; //	DO NOT FILTER HERE TO FASTEN CONVERGENCE (not always true) //				HK.performPruning((double) (obj.getUB()) + totalPenalities + 0.001); updateStep ( hkb , alpha ) ; HKPenalities ( ) ; updateCostMatrix ( ) ; } HKfilter . computeMST ( costs , g . getEnvelopGraph ( ) ) ; hkb = HKfilter . getBound ( ) - totalPenalities ; if ( hkb > bestHKB + 1 ) { bestHKB = hkb ; improved = true ; } mst = HKfilter . getMST ( ) ; if ( hkb - Math . floor ( hkb ) < 0.001 ) { hkb = Math . floor ( hkb ) ; } obj . updateLowerBound ( ( int ) Math . ceil ( hkb ) , this ) ; //			if(tourFound()){// TODO attention si contraintes autres que TSP ca devient faux //				forceTourInstantiation(); //				return; //			} HKfilter . performPruning ( ( double ) ( obj . getUB ( ) ) + totalPenalities + 0.001 ) ; updateStep ( hkb , alpha ) ; HKPenalities ( ) ; updateCostMatrix ( ) ; if ( ! improved ) { count -- ; if ( count == 0 ) { return ; } } alpha *= beta ; beta /= 2 ; if ( sccOf != null ) return ; // not too heavy approach } }",2012-04-12 13:05:11 +0200,2012-06-12 17:39:02 +0200,1,Interrogative
3817,238,https://www.github.com/sreichholf/dreamdroid,init(),NOT_DESIGN,82,82,82,82,TODO Do not trust all hosts without asking the user,https://www.github.com/sreichholf/dreamdroid/commit/fec94b098,https://www.github.com/sreichholf/dreamdroid/commit/9ca37f5b62fdf40fcfac93100d7fe085ef8b4a62,app/src/net/reichholf/dreamdroid/helpers/SimpleHttpClient.java,"private void init() {
//TODO Do not trust all hosts without asking the user
HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {
			public boolean verify(String hostname, SSLSession session) {
return true;
}
		});
applyConfig();
}","private void init() {
applyConfig();
}","private void init  ( ) { //<SATD_START> TODO Do not trust all hosts without asking the user <SATD_END> HttpsURLConnection . setDefaultHostnameVerifier ( new HostnameVerifier ( ) { public boolean verify ( String hostname , SSLSession session ) { return true ; } } ) ; applyConfig ( ) ; }",private void init  ( ) { applyConfig ( ) ; },2013-11-07 01:44:50 +0100,2016-12-01 14:34:19 +0100,9,Other
2988,735,https://www.github.com/alibaba/druid,isAllowComment(),,210,210,210,210,QS_TODO id may start from digit,https://www.github.com/alibaba/druid/commit/f0eba13df8,https://www.github.com/alibaba/druid/commit/0492b77082c972c50e2e9050d91e07171a373190,src/main/java/com/alibaba/druid/sql/parser/Lexer.java,"public final void nextToken() {
sp = 0;
for (;;) {
tokenPos = bp;
if (isWhitespace(ch)) {
scanChar();
continue;
}// QS_TODO skip comment
// QS_TODO id may start from digit
if (isFirstIdentifierChar(ch)) {
if (ch == 'N') {
if (buf[bp + 1] == '\'') {
++bp;
ch = '\'';
scanString();
token = Token.LITERAL_NCHARS;
return;
}
}
scanIdentifier();
return;
}
switch (ch) {
case '0':
if (buf[bp + 1] == 'x') {
scanChar();
scanChar();
scanHexaDecimal();
} else {
scanNumber();
}
return;
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
scanNumber();
return;
case ',':
scanChar();
token = COMMA;
return;
case '(':
scanChar();
token = LPAREN;
return;
case ')':
scanChar();
token = RPAREN;
return;
case '[':
scanChar();
token = LBRACKET;
return;
case ']':
scanChar();
token = RBRACKET;
return;
case '{':
scanChar();
token = LBRACE;
return;
case '}':
scanChar();
token = RBRACE;
return;
case ':':
scanChar();
if (ch == '=') {
scanChar();
token = COLONEQ;
} else {
if (isDigit(ch)) {
unscan();
scanVariable();
} else {
unscan();
scanVariable();
}
}
return;
case '#':
scanVariable();
return;
case '.':
scanChar();
if (isDigit(ch)) {
unscan();
scanNumber();
return;
} else if (ch == '.') {
scanChar();
if (ch == '.') {
scanChar();
token = Token.DOTDOTDOT;
} else {
token = Token.DOTDOT;
}
} else {
token = Token.DOT;
}
return;
case '\'':
scanString();
return;
case '\""':
scanAlias();
return;
case '*':
scanChar();
token = Token.STAR;
return;
case '?':
scanChar();
token = Token.QUES;
return;
case ';':
scanChar();
token = Token.SEMI;
return;
case '`':
throw new SQLParseException(""TODO""); // TODO
case '@':
scanVariable();
return;
case '-':
int subNextChar = buf[bp + 1];
if (subNextChar == '-') {
scanComment();
if ((token() == Token.LINE_COMMENT || token() == Token.MULTI_LINE_COMMENT) && skipComment) {
sp = 0;
continue;
}
} else {
scanOperator();
}
return;
case '/':
int nextChar = buf[bp + 1];
if (nextChar == '/' || nextChar == '*') {
scanComment();
if ((token() == Token.LINE_COMMENT || token() == Token.MULTI_LINE_COMMENT) && skipComment) {
sp = 0;
continue;
}
} else {
token = Token.SLASH;
scanChar();
}
return;
default:
if (Character.isLetter(ch)) {
scanIdentifier();
return;
}
if (isOperator(ch)) {
scanOperator();
return;
}
// QS_TODO ?
if (bp == buflen || ch == EOI && bp + 1 == buflen) { // JLS
token = EOF;
tokenPos = bp = eofPos;
} else {
lexError(""illegal.char"", String.valueOf((int) ch));
scanChar();
}
return;
}
}
}","public final void nextToken() {
sp = 0;
for (;;) {
tokenPos = bp;
if (isWhitespace(ch)) {
scanChar();
continue;
}
if (ch == '$' && buf[bp + 1] == '{') {
scanVariable();
return;
}
if (isFirstIdentifierChar(ch)) {
if (ch == 'N') {
if (buf[bp + 1] == '\'') {
++bp;
ch = '\'';
scanString();
token = Token.LITERAL_NCHARS;
return;
}
}
scanIdentifier();
return;
}
switch (ch) {
case '0':
if (buf[bp + 1] == 'x') {
scanChar();
scanChar();
scanHexaDecimal();
} else {
scanNumber();
}
return;
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
scanNumber();
return;
case ',':
scanChar();
token = COMMA;
return;
case '(':
scanChar();
token = LPAREN;
return;
case ')':
scanChar();
token = RPAREN;
return;
case '[':
scanChar();
token = LBRACKET;
return;
case ']':
scanChar();
token = RBRACKET;
return;
case '{':
scanChar();
token = LBRACE;
return;
case '}':
scanChar();
token = RBRACE;
return;
case ':':
scanChar();
if (ch == '=') {
scanChar();
token = COLONEQ;
} else {
if (isDigit(ch)) {
unscan();
scanVariable();
} else {
unscan();
scanVariable();
}
}
return;
case '#':
scanVariable();
return;
case '.':
scanChar();
if (isDigit(ch)) {
unscan();
scanNumber();
return;
} else if (ch == '.') {
scanChar();
if (ch == '.') {
scanChar();
token = Token.DOTDOTDOT;
} else {
token = Token.DOTDOT;
}
} else {
token = Token.DOT;
}
return;
case '\'':
scanString();
return;
case '\""':
scanAlias();
return;
case '*':
scanChar();
token = Token.STAR;
return;
case '?':
scanChar();
token = Token.QUES;
return;
case ';':
scanChar();
token = Token.SEMI;
return;
case '`':
throw new SQLParseException(""TODO""); // TODO
case '@':
scanVariable();
return;
case '-':
int subNextChar = buf[bp + 1];
if (subNextChar == '-') {
scanComment();
if ((token() == Token.LINE_COMMENT || token() == Token.MULTI_LINE_COMMENT) && skipComment) {
sp = 0;
continue;
}
} else {
scanOperator();
}
return;
case '/':
int nextChar = buf[bp + 1];
if (nextChar == '/' || nextChar == '*') {
scanComment();
if ((token() == Token.LINE_COMMENT || token() == Token.MULTI_LINE_COMMENT) && skipComment) {
sp = 0;
continue;
}
} else {
token = Token.SLASH;
scanChar();
}
return;
default:
if (Character.isLetter(ch)) {
scanIdentifier();
return;
}
if (isOperator(ch)) {
scanOperator();
return;
}
// QS_TODO ?
if (bp == buflen || ch == EOI && bp + 1 == buflen) { // JLS
token = EOF;
tokenPos = bp = eofPos;
} else {
lexError(""illegal.char"", String.valueOf((int) ch));
scanChar();
}
return;
}
}
}","public final void nextToken  ( ) { sp = 0 ; for ( ; ; ) { tokenPos = bp ; if ( isWhitespace ( ch ) ) { scanChar ( ) ; continue ; } // QS_TODO skip comment // <SATD_START> QS_TODO id may start from digit <SATD_END> if ( isFirstIdentifierChar ( ch ) ) { if ( ch == 'N' ) { if ( buf [ bp + 1 ] == '\'' ) { ++ bp ; ch = '\'' ; scanString ( ) ; token = Token . LITERAL_NCHARS ; return ; } } scanIdentifier ( ) ; return ; } switch ( ch ) { case '0' : if ( buf [ bp + 1 ] == 'x' ) { scanChar ( ) ; scanChar ( ) ; scanHexaDecimal ( ) ; } else { scanNumber ( ) ; } return ; case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : scanNumber ( ) ; return ; case ',' : scanChar ( ) ; token = COMMA ; return ; case '(' : scanChar ( ) ; token = LPAREN ; return ; case ')' : scanChar ( ) ; token = RPAREN ; return ; case '[' : scanChar ( ) ; token = LBRACKET ; return ; case ']' : scanChar ( ) ; token = RBRACKET ; return ; case '{' : scanChar ( ) ; token = LBRACE ; return ; case '}' : scanChar ( ) ; token = RBRACE ; return ; case ':' : scanChar ( ) ; if ( ch == '=' ) { scanChar ( ) ; token = COLONEQ ; } else { if ( isDigit ( ch ) ) { unscan ( ) ; scanVariable ( ) ; } else { unscan ( ) ; scanVariable ( ) ; } } return ; case '#' : scanVariable ( ) ; return ; case '.' : scanChar ( ) ; if ( isDigit ( ch ) ) { unscan ( ) ; scanNumber ( ) ; return ; } else if ( ch == '.' ) { scanChar ( ) ; if ( ch == '.' ) { scanChar ( ) ; token = Token . DOTDOTDOT ; } else { token = Token . DOTDOT ; } } else { token = Token . DOT ; } return ; case '\'' : scanString ( ) ; return ; case '\""' : scanAlias ( ) ; return ; case '*' : scanChar ( ) ; token = Token . STAR ; return ; case '?' : scanChar ( ) ; token = Token . QUES ; return ; case ';' : scanChar ( ) ; token = Token . SEMI ; return ; case '`' : throw new SQLParseException ( "" TODO "" ) ; // TODO case '@' : scanVariable ( ) ; return ; case '-' : int subNextChar = buf [ bp + 1 ] ; if ( subNextChar == '-' ) { scanComment ( ) ; if ( ( token ( ) == Token . LINE_COMMENT || token ( ) == Token . MULTI_LINE_COMMENT ) && skipComment ) { sp = 0 ; continue ; } } else { scanOperator ( ) ; } return ; case '/' : int nextChar = buf [ bp + 1 ] ; if ( nextChar == '/' || nextChar == '*' ) { scanComment ( ) ; if ( ( token ( ) == Token . LINE_COMMENT || token ( ) == Token . MULTI_LINE_COMMENT ) && skipComment ) { sp = 0 ; continue ; } } else { token = Token . SLASH ; scanChar ( ) ; } return ; default : if ( Character . isLetter ( ch ) ) { scanIdentifier ( ) ; return ; } if ( isOperator ( ch ) ) { scanOperator ( ) ; return ; } // QS_TODO ? if ( bp == buflen || ch == EOI && bp + 1 == buflen ) { // JLS token = EOF ; tokenPos = bp = eofPos ; } else { lexError ( "" illegal.char "" , String . valueOf ( ( int ) ch ) ) ; scanChar ( ) ; } return ; } } }","public final void nextToken  ( ) { sp = 0 ; for ( ; ; ) { tokenPos = bp ; if ( isWhitespace ( ch ) ) { scanChar ( ) ; continue ; } if ( ch == '$' && buf [ bp + 1 ] == '{' ) { scanVariable ( ) ; return ; } if ( isFirstIdentifierChar ( ch ) ) { if ( ch == 'N' ) { if ( buf [ bp + 1 ] == '\'' ) { ++ bp ; ch = '\'' ; scanString ( ) ; token = Token . LITERAL_NCHARS ; return ; } } scanIdentifier ( ) ; return ; } switch ( ch ) { case '0' : if ( buf [ bp + 1 ] == 'x' ) { scanChar ( ) ; scanChar ( ) ; scanHexaDecimal ( ) ; } else { scanNumber ( ) ; } return ; case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : scanNumber ( ) ; return ; case ',' : scanChar ( ) ; token = COMMA ; return ; case '(' : scanChar ( ) ; token = LPAREN ; return ; case ')' : scanChar ( ) ; token = RPAREN ; return ; case '[' : scanChar ( ) ; token = LBRACKET ; return ; case ']' : scanChar ( ) ; token = RBRACKET ; return ; case '{' : scanChar ( ) ; token = LBRACE ; return ; case '}' : scanChar ( ) ; token = RBRACE ; return ; case ':' : scanChar ( ) ; if ( ch == '=' ) { scanChar ( ) ; token = COLONEQ ; } else { if ( isDigit ( ch ) ) { unscan ( ) ; scanVariable ( ) ; } else { unscan ( ) ; scanVariable ( ) ; } } return ; case '#' : scanVariable ( ) ; return ; case '.' : scanChar ( ) ; if ( isDigit ( ch ) ) { unscan ( ) ; scanNumber ( ) ; return ; } else if ( ch == '.' ) { scanChar ( ) ; if ( ch == '.' ) { scanChar ( ) ; token = Token . DOTDOTDOT ; } else { token = Token . DOTDOT ; } } else { token = Token . DOT ; } return ; case '\'' : scanString ( ) ; return ; case '\""' : scanAlias ( ) ; return ; case '*' : scanChar ( ) ; token = Token . STAR ; return ; case '?' : scanChar ( ) ; token = Token . QUES ; return ; case ';' : scanChar ( ) ; token = Token . SEMI ; return ; case '`' : throw new SQLParseException ( "" TODO "" ) ; // TODO case '@' : scanVariable ( ) ; return ; case '-' : int subNextChar = buf [ bp + 1 ] ; if ( subNextChar == '-' ) { scanComment ( ) ; if ( ( token ( ) == Token . LINE_COMMENT || token ( ) == Token . MULTI_LINE_COMMENT ) && skipComment ) { sp = 0 ; continue ; } } else { scanOperator ( ) ; } return ; case '/' : int nextChar = buf [ bp + 1 ] ; if ( nextChar == '/' || nextChar == '*' ) { scanComment ( ) ; if ( ( token ( ) == Token . LINE_COMMENT || token ( ) == Token . MULTI_LINE_COMMENT ) && skipComment ) { sp = 0 ; continue ; } } else { token = Token . SLASH ; scanChar ( ) ; } return ; default : if ( Character . isLetter ( ch ) ) { scanIdentifier ( ) ; return ; } if ( isOperator ( ch ) ) { scanOperator ( ) ; return ; } // QS_TODO ? if ( bp == buflen || ch == EOI && bp + 1 == buflen ) { // JLS token = EOF ; tokenPos = bp = eofPos ; } else { lexError ( "" illegal.char "" , String . valueOf ( ( int ) ch ) ) ; scanChar ( ) ; } return ; } } }",2012-03-18 22:57:34 +0800,2012-07-17 17:33:31 +0800,3,Other
568,144,https://www.github.com/tootallnate/java-websocket,"createWebSocket(WebSocketAdapter, Draft, Socket)",,490,490,490,490,TODO handle InterruptedException,https://www.github.com/tootallnate/java-websocket/commit/48cc2d30,https://www.github.com/tootallnate/java-websocket/commit/5bba0cc70698003326f7ce9aa4acdb05ee25924d,src/main/java/org/java_websocket/server/WebSocketServer.java,"@Override
public final void onWebsocketClose( WebSocket conn, int code, String reason, boolean remote ) {
oqueue.add( (WebSocketImpl) conn );// because the ostream will close the channel
selector.wakeup();
try {
synchronized ( connections ) {
if( this.connections.remove( conn ) ) {
onClose( conn, code, reason, remote );
}
}
} finally {
try {
releaseBuffers( conn );
} catch ( InterruptedException e ) {
e.printStackTrace();
// TODO handle InterruptedException
}
}
}","@Override
public final void onWebsocketClose( WebSocket conn, int code, String reason, boolean remote ) {
oqueue.add( (WebSocketImpl) conn );// because the ostream will close the channel
selector.wakeup();
try {
synchronized ( connections ) {
if( this.connections.remove( conn ) ) {
onClose( conn, code, reason, remote );
}
}
} finally {
try {
releaseBuffers( conn );
} catch ( InterruptedException e ) {
Thread.currentThread().interrupt();
}
}
}","@ Override public final void onWebsocketClose  ( WebSocket conn , int code , String reason , boolean remote ) { oqueue . add ( ( WebSocketImpl ) conn ) ; // because the ostream will close the channel selector . wakeup ( ) ; try { synchronized ( connections ) { if ( this . connections . remove ( conn ) ) { onClose ( conn , code , reason , remote ) ; } } } finally { try { releaseBuffers ( conn ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; // <SATD_START> TODO handle InterruptedException <SATD_END> } } }","@ Override public final void onWebsocketClose  ( WebSocket conn , int code , String reason , boolean remote ) { oqueue . add ( ( WebSocketImpl ) conn ) ; // because the ostream will close the channel selector . wakeup ( ) ; try { synchronized ( connections ) { if ( this . connections . remove ( conn ) ) { onClose ( conn , code , reason , remote ) ; } } } finally { try { releaseBuffers ( conn ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } } }",2012-05-19 02:54:00 +0200,2012-11-05 22:25:46 +0100,1,Other
2018,651,https://www.github.com/wildfly/jboss-ejb-client,"createOpenListener(Function<RemoteServer, Association>)",NOT_DESIGN,231,231,231,231,TODO: transaction messages should proxy to transaction server handler,https://www.github.com/wildfly/jboss-ejb-client/commit/2541342cc,https://www.github.com/wildfly/jboss-ejb-client/commit/669f43ee345f0d224404a5c71cbecd0f7301dcb5,src/main/java/org/jboss/ejb/protocol/remote/RemoteServer.java,"public void handleMessage(final Channel channel, final MessageInputStream message) {
try {
final int code = message.readUnsignedByte();
switch (code) {
case Protocol.COMPRESSED_INVOCATION_MESSAGE:
case Protocol.INVOCATION_REQUEST: {
final int invId = message.readUnsignedShort();
final InvocationInformation invocationInformation = new InvocationInformation(channel.getConnection().getPeerAddress().toString(),invId);
// now if we get an error, we can respond.
try (InputStream input = code == Protocol.COMPRESSED_INVOCATION_MESSAGE ? new InflaterInputStream(message) : message) {
handleInvocationRequest(invocationInformation, input);
} catch (IOException | ClassNotFoundException e) {
// write response back to client
writeFailedResponse(invId, e);
}
break;
}
case Protocol.OPEN_SESSION_REQUEST: {
final int invId = message.readUnsignedShort();
try {
final InvocationInformation invocationInformation = new InvocationInformation(channel.getConnection().getPeerAddress().toString(), invId);
handleSessionOpenRequest(invocationInformation, message);
} catch (IOException e) {
// write response back to client
writeFailedResponse(invId, e);
}
break;
}
case Protocol.CANCEL_REQUEST: {
final int invId = message.readUnsignedShort();
try {
handleCancelRequest(invId, message);
} catch (IOException e) {
// ignored
}
break;
}
// TODO: transaction messages should proxy to transaction server handler
default: {
// unrecognized
Logs.REMOTING.invalidMessageReceived(code);
break;
}
}
} catch (IOException e) {
// nothing we can do.
} finally {
safeClose(message);
channel.receiveMessage(this);
}
}","public void handleMessage(final Channel channel, final MessageInputStream message) {
try {
final int code = message.readUnsignedByte();
switch (code) {
case Protocol.COMPRESSED_INVOCATION_MESSAGE:
case Protocol.INVOCATION_REQUEST: {
final int invId = message.readUnsignedShort();
final InvocationInformation invocationInformation = new InvocationInformation(channel.getConnection().getPeerAddress().toString(),invId);
// now if we get an error, we can respond.
try (InputStream input = code == Protocol.COMPRESSED_INVOCATION_MESSAGE ? new InflaterInputStream(message) : message) {
handleInvocationRequest(invocationInformation, input);
} catch (IOException | ClassNotFoundException e) {
// write response back to client
writeFailedResponse(invId, e);
}
break;
}
case Protocol.OPEN_SESSION_REQUEST: {
final int invId = message.readUnsignedShort();
try {
final InvocationInformation invocationInformation = new InvocationInformation(channel.getConnection().getPeerAddress().toString(), invId);
handleSessionOpenRequest(invocationInformation, message);
} catch (IOException e) {
// write response back to client
writeFailedResponse(invId, e);
}
break;
}
case Protocol.CANCEL_REQUEST: {
final int invId = message.readUnsignedShort();
try {
handleCancelRequest(invId, message);
} catch (IOException e) {
// ignored
}
break;
}
case Protocol.TXN_COMMIT_REQUEST:
case Protocol.TXN_ROLLBACK_REQUEST:
case Protocol.TXN_PREPARE_REQUEST:
case Protocol.TXN_FORGET_REQUEST:
case Protocol.TXN_BEFORE_COMPLETION_REQUEST: {
final int invId = message.readUnsignedShort();
try {
handleTxnRequest(code, invId, message);
} catch (IOException e) {
// ignored
}
break;
}
case Protocol.TXN_RECOVERY_REQUEST: {
final int invId = message.readUnsignedShort();
try {
handleTxnRecoverRequest(invId, message);
} catch (IOException e) {
// ignored
}
break;
}
default: {
// unrecognized
Logs.REMOTING.invalidMessageReceived(code);
break;
}
}
} catch (IOException e) {
// nothing we can do.
} finally {
safeClose(message);
channel.receiveMessage(this);
}
}","public void handleMessage  ( final Channel channel , final MessageInputStream message ) { try { final int code = message . readUnsignedByte ( ) ; switch ( code ) { case Protocol . COMPRESSED_INVOCATION_MESSAGE : case Protocol . INVOCATION_REQUEST : { final int invId = message . readUnsignedShort ( ) ; final InvocationInformation invocationInformation = new InvocationInformation ( channel . getConnection ( ) . getPeerAddress ( ) . toString ( ) , invId ) ; // now if we get an error, we can respond. try ( InputStream input = code == Protocol . COMPRESSED_INVOCATION_MESSAGE ? new InflaterInputStream ( message ) : message ) { handleInvocationRequest ( invocationInformation , input ) ; } catch ( IOException | ClassNotFoundException e ) { // write response back to client writeFailedResponse ( invId , e ) ; } break ; } case Protocol . OPEN_SESSION_REQUEST : { final int invId = message . readUnsignedShort ( ) ; try { final InvocationInformation invocationInformation = new InvocationInformation ( channel . getConnection ( ) . getPeerAddress ( ) . toString ( ) , invId ) ; handleSessionOpenRequest ( invocationInformation , message ) ; } catch ( IOException e ) { // write response back to client writeFailedResponse ( invId , e ) ; } break ; } case Protocol . CANCEL_REQUEST : { final int invId = message . readUnsignedShort ( ) ; try { handleCancelRequest ( invId , message ) ; } catch ( IOException e ) { // ignored } break ; } // <SATD_START> TODO: transaction messages should proxy to transaction server handler <SATD_END> default : { // unrecognized Logs . REMOTING . invalidMessageReceived ( code ) ; break ; } } } catch ( IOException e ) { // nothing we can do. } finally { safeClose ( message ) ; channel . receiveMessage ( this ) ; } }","public void handleMessage  ( final Channel channel , final MessageInputStream message ) { try { final int code = message . readUnsignedByte ( ) ; switch ( code ) { case Protocol . COMPRESSED_INVOCATION_MESSAGE : case Protocol . INVOCATION_REQUEST : { final int invId = message . readUnsignedShort ( ) ; final InvocationInformation invocationInformation = new InvocationInformation ( channel . getConnection ( ) . getPeerAddress ( ) . toString ( ) , invId ) ; // now if we get an error, we can respond. try ( InputStream input = code == Protocol . COMPRESSED_INVOCATION_MESSAGE ? new InflaterInputStream ( message ) : message ) { handleInvocationRequest ( invocationInformation , input ) ; } catch ( IOException | ClassNotFoundException e ) { // write response back to client writeFailedResponse ( invId , e ) ; } break ; } case Protocol . OPEN_SESSION_REQUEST : { final int invId = message . readUnsignedShort ( ) ; try { final InvocationInformation invocationInformation = new InvocationInformation ( channel . getConnection ( ) . getPeerAddress ( ) . toString ( ) , invId ) ; handleSessionOpenRequest ( invocationInformation , message ) ; } catch ( IOException e ) { // write response back to client writeFailedResponse ( invId , e ) ; } break ; } case Protocol . CANCEL_REQUEST : { final int invId = message . readUnsignedShort ( ) ; try { handleCancelRequest ( invId , message ) ; } catch ( IOException e ) { // ignored } break ; } case Protocol . TXN_COMMIT_REQUEST : case Protocol . TXN_ROLLBACK_REQUEST : case Protocol . TXN_PREPARE_REQUEST : case Protocol . TXN_FORGET_REQUEST : case Protocol . TXN_BEFORE_COMPLETION_REQUEST : { final int invId = message . readUnsignedShort ( ) ; try { handleTxnRequest ( code , invId , message ) ; } catch ( IOException e ) { // ignored } break ; } case Protocol . TXN_RECOVERY_REQUEST : { final int invId = message . readUnsignedShort ( ) ; try { handleTxnRecoverRequest ( invId , message ) ; } catch ( IOException e ) { // ignored } break ; } default : { // unrecognized Logs . REMOTING . invalidMessageReceived ( code ) ; break ; } } } catch ( IOException e ) { // nothing we can do. } finally { safeClose ( message ) ; channel . receiveMessage ( this ) ; } }",2016/6/7 11:09,2017/1/10 6:40,4,Other
1786,439,https://www.github.com/awful/awful.apk,"setDataOnThreadListItem(View, AwfulPreferences, Cursor, AwfulFragment)",DESIGN,392,392,392,392,TODO: 03/06/2017 what's this about?,https://www.github.com/awful/awful.apk/commit/efc8d4de8,https://www.github.com/awful/awful.apk/commit/98399eb0682c15a49919a98b47550ca36acb759b,Awful.apk/src/main/java/com/ferg/awfulapp/thread/AwfulThread.java,"@SuppressWarnings(""deprecation"")
public static void setDataOnThreadListItem(View item, AwfulPreferences prefs, Cursor data, AwfulFragment parent) {
AwfulThread thread = fromCursorRow(data);
if (thread == null) {
Timber.w(""setDataOnThreadView: unable to get data for thread!"");
return;
}
Resources resources = item.getResources();
Context context = item.getContext();
// get the forum ID for getting themed resources
Integer forumId = null;
if (parent instanceof ForumDisplayFragment) {
forumId = ((ForumDisplayFragment) parent).getForumId();
}
// thread title
TextView title = item.findViewById(R.id.title);
title.setText(thread.title != null ? thread.title : ""UNKNOWN"");
title.setTextColor(ColorProvider.PRIMARY_TEXT.getColor(forumId));
// main thread tag
final ImageView threadTag = item.findViewById(R.id.thread_tag);
threadTag.setVisibility(GONE);
if (prefs.threadInfo_Tag) {
if (!TextUtils.isEmpty(thread.tagCacheFile)) {
threadTag.setVisibility(VISIBLE);
String url = thread.tagUrl;
String localFileName = ""@drawable/""+url.substring(url.lastIndexOf('/') + 1,url.lastIndexOf('.')).replace('-','_').toLowerCase();
int imageID = resources.getIdentifier(localFileName, null, context.getPackageName());
if (imageID == 0) {
NetworkUtils.getImageLoader().get(url, new ImageLoader.ImageListener() {
                        @Override
public void onResponse(ImageLoader.ImageContainer response, boolean isImmediate) {
Drawable classicTag = AwfulPostIcon.getClassicIconDrawable(response.getBitmap(), threadTag.getContext());
threadTag.setImageDrawable(classicTag);
}
@Override
public void onErrorResponse(VolleyError error) {
threadTag.setImageResource(R.drawable.empty_thread_tag);
}
                    });
} else {
threadTag.setImageResource(imageID);
}
}
}
// tag overlay (secondary tags etc)
ImageView forumTagOverlay = item.findViewById(R.id.thread_tag_overlay);
ImageView inlineForumTagOverlay = item.findViewById(R.id.thread_tag_overlay_optional);
forumTagOverlay.setVisibility(GONE);
inlineForumTagOverlay.setVisibility(GONE);
if (ExtraTags.getType(thread.tagExtra) != ExtraTags.TYPE_NO_TAG) {
Drawable tagIcon = ExtraTags.getDrawable(thread.tagExtra, resources);
if (tagIcon != null) {
if(prefs.threadInfo_Tag) {
showImage(forumTagOverlay, tagIcon);
}else {
showImage(inlineForumTagOverlay, tagIcon);
}
}
}
// page count / author / last poster info line
TextView info = item.findViewById(R.id.thread_info);
info.setVisibility(VISIBLE);
String tmp = String.format(Locale.US, ""%d pgs | %s: %s"",
                thread.getPageCount(prefs.postPerPage),
                thread.hasBeenViewed ? ""Last"" : ""OP"",
                NetworkUtils.unencodeHtml(thread.hasBeenViewed ? thread.lastPoster : thread.author));
info.setText(tmp.trim());
info.setTextColor(ColorProvider.ALT_TEXT.getColor(forumId));
// ratings
ImageView threadRating = item.findViewById(R.id.thread_rating);
ImageView inlineThreadRating = item.findViewById(R.id.thread_rating_optional);
threadRating.setVisibility(GONE);
inlineThreadRating.setVisibility(GONE);
// if we're showing ratings...
if (prefs.threadInfo_Rating) {
Drawable ratingIcon = AwfulRatings.getDrawable(thread.rating, resources);
// Film Dump replaces the actual thread tag, instead of using the separate rating view
if (AwfulRatings.getType(thread.rating) == AwfulRatings.TYPE_FILM_DUMP) {
showImage(threadTag, ratingIcon);
} else {
showImage(prefs.threadInfo_Tag ? threadRating : inlineThreadRating, ratingIcon);
}
}
// locked and sticky status
ImageView threadLocked = item.findViewById(R.id.thread_locked);
ImageView threadSticky = item.findViewById(R.id.thread_sticky);
threadSticky.setVisibility(thread.isSticky ? VISIBLE : GONE);
threadLocked.setVisibility(thread.isLocked && !thread.isSticky ? VISIBLE : GONE);
if (thread.isLocked && !thread.isSticky) {
// TODO: 03/06/2017 what's this about?
item.setBackgroundColor(ColorProvider.BACKGROUND.getColor(forumId));
}
// unread counter
TextView unread = item.findViewById(R.id.unread_count);
unread.setVisibility(GONE);
if(thread.hasBeenViewed) {
unread.setVisibility(VISIBLE);
unread.setTextColor(ColorProvider.UNREAD_TEXT.getColor(forumId));
unread.setText(Integer.toString(thread.unreadCount));
GradientDrawable counter = (GradientDrawable) resources.getDrawable(R.drawable.unread_counter);
if (counter != null) {
counter.mutate();
boolean dim = !thread.hasNewPosts();
if (thread.bookmarkType > 0 && prefs.coloredBookmarks) {
counter.setColor(ColorProvider.getBookmarkColor(thread.bookmarkType, dim));
} else {
ColorProvider colorAttr = dim ? ColorProvider.UNREAD_BACKGROUND_DIM : ColorProvider.UNREAD_BACKGROUND;
counter.setColor(colorAttr.getColor(forumId));
}
unread.setBackgroundDrawable(counter);
}
}
}","@SuppressWarnings(""deprecation"")
public static void setDataOnThreadListItem(View item, AwfulPreferences prefs, Cursor data, AwfulFragment parent) {
AwfulThread thread = fromCursorRow(data);
if (thread == null) {
Timber.w(""setDataOnThreadView: unable to get data for thread!"");
return;
}
Resources resources = item.getResources();
Context context = item.getContext();
// get the forum ID for getting themed resources
Integer forumId = null;
if (parent instanceof ForumDisplayFragment) {
forumId = ((ForumDisplayFragment) parent).getForumId();
}
// thread title
TextView title = item.findViewById(R.id.title);
title.setText(thread.title != null ? thread.title : ""UNKNOWN"");
title.setTextColor(ColorProvider.PRIMARY_TEXT.getColor(forumId));
// main thread tag
final ImageView threadTag = item.findViewById(R.id.thread_tag);
threadTag.setVisibility(GONE);
if (prefs.threadInfo_Tag) {
if (!TextUtils.isEmpty(thread.tagCacheFile)) {
threadTag.setVisibility(VISIBLE);
String url = thread.tagUrl;
String localFileName = ""@drawable/""+url.substring(url.lastIndexOf('/') + 1,url.lastIndexOf('.')).replace('-','_').toLowerCase();
int imageID = resources.getIdentifier(localFileName, null, context.getPackageName());
if (imageID == 0) {
NetworkUtils.getImageLoader().get(url, new ImageLoader.ImageListener() {
                        @Override
public void onResponse(ImageLoader.ImageContainer response, boolean isImmediate) {
Drawable classicTag = AwfulPostIcon.getClassicIconDrawable(response.getBitmap(), threadTag.getContext());
threadTag.setImageDrawable(classicTag);
}
@Override
public void onErrorResponse(VolleyError error) {
threadTag.setImageResource(R.drawable.empty_thread_tag);
}
                    });
} else {
threadTag.setImageResource(imageID);
}
}
}
// tag overlay (secondary tags etc)
ImageView forumTagOverlay = item.findViewById(R.id.thread_tag_overlay);
ImageView inlineForumTagOverlay = item.findViewById(R.id.thread_tag_overlay_optional);
forumTagOverlay.setVisibility(GONE);
inlineForumTagOverlay.setVisibility(GONE);
if (ExtraTags.getType(thread.tagExtra) != ExtraTags.TYPE_NO_TAG) {
Drawable tagIcon = ExtraTags.getDrawable(thread.tagExtra, resources);
if (tagIcon != null) {
if(prefs.threadInfo_Tag) {
showImage(forumTagOverlay, tagIcon);
}else {
showImage(inlineForumTagOverlay, tagIcon);
}
}
}
// page count / author / last poster info line
TextView info = item.findViewById(R.id.thread_info);
info.setVisibility(VISIBLE);
String tmp = String.format(Locale.US, ""%d pgs | %s: %s"",
                thread.getPageCount(prefs.postPerPage),
                thread.hasBeenViewed ? ""Last"" : ""OP"",
                NetworkUtils.unencodeHtml(thread.hasBeenViewed ? thread.lastPoster : thread.author));
info.setText(tmp.trim());
info.setTextColor(ColorProvider.ALT_TEXT.getColor(forumId));
// ratings
ImageView threadRating = item.findViewById(R.id.thread_rating);
ImageView inlineThreadRating = item.findViewById(R.id.thread_rating_optional);
threadRating.setVisibility(GONE);
inlineThreadRating.setVisibility(GONE);
// if we're showing ratings...
if (prefs.threadInfo_Rating) {
Drawable ratingIcon = AwfulRatings.getDrawable(thread.rating, resources);
// Film Dump replaces the actual thread tag, instead of using the separate rating view
if (AwfulRatings.getType(thread.rating) == AwfulRatings.TYPE_FILM_DUMP) {
showImage(threadTag, ratingIcon);
} else {
showImage(prefs.threadInfo_Tag ? threadRating : inlineThreadRating, ratingIcon);
}
}
// locked and sticky status
ImageView threadLocked = item.findViewById(R.id.thread_locked);
ImageView threadSticky = item.findViewById(R.id.thread_sticky);
threadSticky.setVisibility(thread.isSticky ? VISIBLE : GONE);
threadLocked.setVisibility(thread.isLocked && !thread.isSticky ? VISIBLE : GONE);
// unread counter
TextView unread = item.findViewById(R.id.unread_count);
unread.setVisibility(GONE);
if(thread.hasBeenViewed) {
unread.setVisibility(VISIBLE);
unread.setTextColor(ColorProvider.UNREAD_TEXT.getColor(forumId));
unread.setText(Integer.toString(thread.unreadCount));
GradientDrawable counter = (GradientDrawable) resources.getDrawable(R.drawable.unread_counter);
if (counter != null) {
counter.mutate();
boolean dim = !thread.hasNewPosts();
if (thread.bookmarkType > 0 && prefs.coloredBookmarks) {
counter.setColor(ColorProvider.getBookmarkColor(thread.bookmarkType, dim));
} else {
ColorProvider colorAttr = dim ? ColorProvider.UNREAD_BACKGROUND_DIM : ColorProvider.UNREAD_BACKGROUND;
counter.setColor(colorAttr.getColor(forumId));
}
unread.setBackgroundDrawable(counter);
}
}
}","@ SuppressWarnings ( "" deprecation "" ) public static void setDataOnThreadListItem  ( View item , AwfulPreferences prefs , Cursor data , AwfulFragment parent ) { AwfulThread thread = fromCursorRow ( data ) ; if ( thread == null ) { Timber . w ( "" setDataOnThreadView: unable to get data for thread! "" ) ; return ; } Resources resources = item . getResources ( ) ; Context context = item . getContext ( ) ; // get the forum ID for getting themed resources Integer forumId = null ; if ( parent instanceof ForumDisplayFragment ) { forumId = ( ( ForumDisplayFragment ) parent ) . getForumId ( ) ; } // thread title TextView title = item . findViewById ( R . id . title ) ; title . setText ( thread . title != null ? thread . title : "" UNKNOWN "" ) ; title . setTextColor ( ColorProvider . PRIMARY_TEXT . getColor ( forumId ) ) ; // main thread tag final ImageView threadTag = item . findViewById ( R . id . thread_tag ) ; threadTag . setVisibility ( GONE ) ; if ( prefs . threadInfo_Tag ) { if ( ! TextUtils . isEmpty ( thread . tagCacheFile ) ) { threadTag . setVisibility ( VISIBLE ) ; String url = thread . tagUrl ; String localFileName = "" @drawable/ "" + url . substring ( url . lastIndexOf ( '/' ) + 1 , url . lastIndexOf ( '.' ) ) . replace ( '-' , '_' ) . toLowerCase ( ) ; int imageID = resources . getIdentifier ( localFileName , null , context . getPackageName ( ) ) ; if ( imageID == 0 ) { NetworkUtils . getImageLoader ( ) . get ( url , new ImageLoader . ImageListener ( ) { @ Override public void onResponse ( ImageLoader . ImageContainer response , boolean isImmediate ) { Drawable classicTag = AwfulPostIcon . getClassicIconDrawable ( response . getBitmap ( ) , threadTag . getContext ( ) ) ; threadTag . setImageDrawable ( classicTag ) ; } @ Override public void onErrorResponse ( VolleyError error ) { threadTag . setImageResource ( R . drawable . empty_thread_tag ) ; } } ) ; } else { threadTag . setImageResource ( imageID ) ; } } } // tag overlay (secondary tags etc) ImageView forumTagOverlay = item . findViewById ( R . id . thread_tag_overlay ) ; ImageView inlineForumTagOverlay = item . findViewById ( R . id . thread_tag_overlay_optional ) ; forumTagOverlay . setVisibility ( GONE ) ; inlineForumTagOverlay . setVisibility ( GONE ) ; if ( ExtraTags . getType ( thread . tagExtra ) != ExtraTags . TYPE_NO_TAG ) { Drawable tagIcon = ExtraTags . getDrawable ( thread . tagExtra , resources ) ; if ( tagIcon != null ) { if ( prefs . threadInfo_Tag ) { showImage ( forumTagOverlay , tagIcon ) ; } else { showImage ( inlineForumTagOverlay , tagIcon ) ; } } } // page count / author / last poster info line TextView info = item . findViewById ( R . id . thread_info ) ; info . setVisibility ( VISIBLE ) ; String tmp = String . format ( Locale . US , "" %d pgs | %s: %s "" , thread . getPageCount ( prefs . postPerPage ) , thread . hasBeenViewed ? "" Last "" : "" OP "" , NetworkUtils . unencodeHtml ( thread . hasBeenViewed ? thread . lastPoster : thread . author ) ) ; info . setText ( tmp . trim ( ) ) ; info . setTextColor ( ColorProvider . ALT_TEXT . getColor ( forumId ) ) ; // ratings ImageView threadRating = item . findViewById ( R . id . thread_rating ) ; ImageView inlineThreadRating = item . findViewById ( R . id . thread_rating_optional ) ; threadRating . setVisibility ( GONE ) ; inlineThreadRating . setVisibility ( GONE ) ; // if we're showing ratings... if ( prefs . threadInfo_Rating ) { Drawable ratingIcon = AwfulRatings . getDrawable ( thread . rating , resources ) ; // Film Dump replaces the actual thread tag, instead of using the separate rating view if ( AwfulRatings . getType ( thread . rating ) == AwfulRatings . TYPE_FILM_DUMP ) { showImage ( threadTag , ratingIcon ) ; } else { showImage ( prefs . threadInfo_Tag ? threadRating : inlineThreadRating , ratingIcon ) ; } } // locked and sticky status ImageView threadLocked = item . findViewById ( R . id . thread_locked ) ; ImageView threadSticky = item . findViewById ( R . id . thread_sticky ) ; threadSticky . setVisibility ( thread . isSticky ? VISIBLE : GONE ) ; threadLocked . setVisibility ( thread . isLocked && ! thread . isSticky ? VISIBLE : GONE ) ; if ( thread . isLocked && ! thread . isSticky ) { // <SATD_START> TODO: 03/06/2017 what's this about? <SATD_END> item . setBackgroundColor ( ColorProvider . BACKGROUND . getColor ( forumId ) ) ; } // unread counter TextView unread = item . findViewById ( R . id . unread_count ) ; unread . setVisibility ( GONE ) ; if ( thread . hasBeenViewed ) { unread . setVisibility ( VISIBLE ) ; unread . setTextColor ( ColorProvider . UNREAD_TEXT . getColor ( forumId ) ) ; unread . setText ( Integer . toString ( thread . unreadCount ) ) ; GradientDrawable counter = ( GradientDrawable ) resources . getDrawable ( R . drawable . unread_counter ) ; if ( counter != null ) { counter . mutate ( ) ; boolean dim = ! thread . hasNewPosts ( ) ; if ( thread . bookmarkType > 0 && prefs . coloredBookmarks ) { counter . setColor ( ColorProvider . getBookmarkColor ( thread . bookmarkType , dim ) ) ; } else { ColorProvider colorAttr = dim ? ColorProvider . UNREAD_BACKGROUND_DIM : ColorProvider . UNREAD_BACKGROUND ; counter . setColor ( colorAttr . getColor ( forumId ) ) ; } unread . setBackgroundDrawable ( counter ) ; } } }","@ SuppressWarnings ( "" deprecation "" ) public static void setDataOnThreadListItem  ( View item , AwfulPreferences prefs , Cursor data , AwfulFragment parent ) { AwfulThread thread = fromCursorRow ( data ) ; if ( thread == null ) { Timber . w ( "" setDataOnThreadView: unable to get data for thread! "" ) ; return ; } Resources resources = item . getResources ( ) ; Context context = item . getContext ( ) ; // get the forum ID for getting themed resources Integer forumId = null ; if ( parent instanceof ForumDisplayFragment ) { forumId = ( ( ForumDisplayFragment ) parent ) . getForumId ( ) ; } // thread title TextView title = item . findViewById ( R . id . title ) ; title . setText ( thread . title != null ? thread . title : "" UNKNOWN "" ) ; title . setTextColor ( ColorProvider . PRIMARY_TEXT . getColor ( forumId ) ) ; // main thread tag final ImageView threadTag = item . findViewById ( R . id . thread_tag ) ; threadTag . setVisibility ( GONE ) ; if ( prefs . threadInfo_Tag ) { if ( ! TextUtils . isEmpty ( thread . tagCacheFile ) ) { threadTag . setVisibility ( VISIBLE ) ; String url = thread . tagUrl ; String localFileName = "" @drawable/ "" + url . substring ( url . lastIndexOf ( '/' ) + 1 , url . lastIndexOf ( '.' ) ) . replace ( '-' , '_' ) . toLowerCase ( ) ; int imageID = resources . getIdentifier ( localFileName , null , context . getPackageName ( ) ) ; if ( imageID == 0 ) { NetworkUtils . getImageLoader ( ) . get ( url , new ImageLoader . ImageListener ( ) { @ Override public void onResponse ( ImageLoader . ImageContainer response , boolean isImmediate ) { Drawable classicTag = AwfulPostIcon . getClassicIconDrawable ( response . getBitmap ( ) , threadTag . getContext ( ) ) ; threadTag . setImageDrawable ( classicTag ) ; } @ Override public void onErrorResponse ( VolleyError error ) { threadTag . setImageResource ( R . drawable . empty_thread_tag ) ; } } ) ; } else { threadTag . setImageResource ( imageID ) ; } } } // tag overlay (secondary tags etc) ImageView forumTagOverlay = item . findViewById ( R . id . thread_tag_overlay ) ; ImageView inlineForumTagOverlay = item . findViewById ( R . id . thread_tag_overlay_optional ) ; forumTagOverlay . setVisibility ( GONE ) ; inlineForumTagOverlay . setVisibility ( GONE ) ; if ( ExtraTags . getType ( thread . tagExtra ) != ExtraTags . TYPE_NO_TAG ) { Drawable tagIcon = ExtraTags . getDrawable ( thread . tagExtra , resources ) ; if ( tagIcon != null ) { if ( prefs . threadInfo_Tag ) { showImage ( forumTagOverlay , tagIcon ) ; } else { showImage ( inlineForumTagOverlay , tagIcon ) ; } } } // page count / author / last poster info line TextView info = item . findViewById ( R . id . thread_info ) ; info . setVisibility ( VISIBLE ) ; String tmp = String . format ( Locale . US , "" %d pgs | %s: %s "" , thread . getPageCount ( prefs . postPerPage ) , thread . hasBeenViewed ? "" Last "" : "" OP "" , NetworkUtils . unencodeHtml ( thread . hasBeenViewed ? thread . lastPoster : thread . author ) ) ; info . setText ( tmp . trim ( ) ) ; info . setTextColor ( ColorProvider . ALT_TEXT . getColor ( forumId ) ) ; // ratings ImageView threadRating = item . findViewById ( R . id . thread_rating ) ; ImageView inlineThreadRating = item . findViewById ( R . id . thread_rating_optional ) ; threadRating . setVisibility ( GONE ) ; inlineThreadRating . setVisibility ( GONE ) ; // if we're showing ratings... if ( prefs . threadInfo_Rating ) { Drawable ratingIcon = AwfulRatings . getDrawable ( thread . rating , resources ) ; // Film Dump replaces the actual thread tag, instead of using the separate rating view if ( AwfulRatings . getType ( thread . rating ) == AwfulRatings . TYPE_FILM_DUMP ) { showImage ( threadTag , ratingIcon ) ; } else { showImage ( prefs . threadInfo_Tag ? threadRating : inlineThreadRating , ratingIcon ) ; } } // locked and sticky status ImageView threadLocked = item . findViewById ( R . id . thread_locked ) ; ImageView threadSticky = item . findViewById ( R . id . thread_sticky ) ; threadSticky . setVisibility ( thread . isSticky ? VISIBLE : GONE ) ; threadLocked . setVisibility ( thread . isLocked && ! thread . isSticky ? VISIBLE : GONE ) ; // unread counter TextView unread = item . findViewById ( R . id . unread_count ) ; unread . setVisibility ( GONE ) ; if ( thread . hasBeenViewed ) { unread . setVisibility ( VISIBLE ) ; unread . setTextColor ( ColorProvider . UNREAD_TEXT . getColor ( forumId ) ) ; unread . setText ( Integer . toString ( thread . unreadCount ) ) ; GradientDrawable counter = ( GradientDrawable ) resources . getDrawable ( R . drawable . unread_counter ) ; if ( counter != null ) { counter . mutate ( ) ; boolean dim = ! thread . hasNewPosts ( ) ; if ( thread . bookmarkType > 0 && prefs . coloredBookmarks ) { counter . setColor ( ColorProvider . getBookmarkColor ( thread . bookmarkType , dim ) ) ; } else { ColorProvider colorAttr = dim ? ColorProvider . UNREAD_BACKGROUND_DIM : ColorProvider . UNREAD_BACKGROUND ; counter . setColor ( colorAttr . getColor ( forumId ) ) ; } unread . setBackgroundDrawable ( counter ) ; } } }",2017-06-04 17:57:42 +0100,2021/6/4 12:31,24,Interrogative
426,284,https://www.github.com/hibernate/hibernate-search,close(),,196,196,196,196,TODO move directory provider cleaning to DirectoryProviderFactory,https://www.github.com/hibernate/hibernate-search/commit/6d28d98b1b2,https://www.github.com/hibernate/hibernate-search/commit/eb7a1583f2e0bf0ccffddf96814d1dca06e1edb8,hibernate-search/src/main/java/org/hibernate/search/impl/ImmutableSearchFactory.java,"public void close() {
if ( stopped.compareAndSet( false, true ) ) { //make sure we only stop once
try {
worker.close();
}
catch ( Exception e ) {
log.workerException( e );
}
try {
readerProvider.destroy();
}
catch ( Exception e ) {
log.readerProviderExceptionOnDestroy( e );
}
//TODO move directory provider cleaning to DirectoryProviderFactory
for ( DirectoryProvider dp : getDirectoryProviders() ) {
try {
dp.stop();
}
catch ( Exception e ) {
log.directoryProviderExceptionOnStop( e );
}
}
serviceManager.stopServices();
}
}","public void close() {
if ( stopped.compareAndSet( false, true ) ) { //make sure we only stop once
try {
worker.close();
}
catch ( Exception e ) {
log.workerException( e );
}
try {
readerProvider.destroy();
}
catch ( Exception e ) {
log.readerProviderExceptionOnDestroy( e );
}
this.allIndexesManager.stop();
serviceManager.stopServices();
}
}","public void close  ( ) { if ( stopped . compareAndSet ( false , true ) ) { //make sure we only stop once try { worker . close ( ) ; } catch ( Exception e ) { log . workerException ( e ) ; } try { readerProvider . destroy ( ) ; } catch ( Exception e ) { log . readerProviderExceptionOnDestroy ( e ) ; } //<SATD_START> TODO move directory provider cleaning to DirectoryProviderFactory <SATD_END> for ( DirectoryProvider dp : getDirectoryProviders ( ) ) { try { dp . stop ( ) ; } catch ( Exception e ) { log . directoryProviderExceptionOnStop ( e ) ; } } serviceManager . stopServices ( ) ; } }","public void close  ( ) { if ( stopped . compareAndSet ( false , true ) ) { //make sure we only stop once try { worker . close ( ) ; } catch ( Exception e ) { log . workerException ( e ) ; } try { readerProvider . destroy ( ) ; } catch ( Exception e ) { log . readerProviderExceptionOnDestroy ( e ) ; } this . allIndexesManager . stop ( ) ; serviceManager . stopServices ( ) ; } }",2010-03-10 08:23:04 +0000,2011-07-28 10:51:51 +0100,9,Other
921,690,https://www.github.com/apptentive/apptentive-android,init(),,241,241,241,241,TODO: Send AppInfo update if app info was updated.,https://www.github.com/apptentive/apptentive-android/commit/140fd8fa6,https://www.github.com/apptentive/apptentive-android/commit/c6c60f86e1a6d0cbfab7ea24e8a99eaf5f357e81,apptentive-android-sdk/src/com/apptentive/android/sdk/Apptentive.java,"private static void init() {
//
// First, initialize data relies on synchronous reads from local resources.
//
if(!GlobalInfo.initialized) {
SharedPreferences prefs = appContext.getSharedPreferences(Constants.PREF_NAME, Context.MODE_PRIVATE);
db = new ApptentiveDatabase(appContext);
NetworkStateReceiver.clearListeners();
// First, Get the api key, and figure out if app is debuggable.
GlobalInfo.isAppDebuggable = false;
String apiKey = null;
try {
ApplicationInfo ai = appContext.getPackageManager().getApplicationInfo(appContext.getPackageName(), PackageManager.GET_META_DATA);
if(ai != null && ai.metaData != null && ai.metaData.containsKey(Constants.MANIFEST_KEY_APPTENTIVE_API_KEY)) {
apiKey = ai.metaData.getString(Constants.MANIFEST_KEY_APPTENTIVE_API_KEY);
}
if(ai != null && ((ai.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0)) {
GlobalInfo.isAppDebuggable = true;
}
} catch(Exception e) {
Log.e(""Unexpected error while reading application info."", e);
}
// If we are in debug mode, but no api key is found, throw an exception. Otherwise, just assert log. We don't want to crash a production app.
String errorString = ""No Apptentive api key specified. Please make sure you have specified your api key in your AndroidManifest.xml"";
if((apiKey == null || apiKey.equals(""""))) {
if(GlobalInfo.isAppDebuggable) {
throw new RuntimeException(errorString);
} else {
Log.e(errorString);
}
}
GlobalInfo.apiKey = apiKey;
// Grab app info we need to access later on.
GlobalInfo.appPackage = appContext.getPackageName();
GlobalInfo.androidId = Settings.Secure.getString(appContext.getContentResolver(), android.provider.Settings.Secure.ANDROID_ID);
GlobalInfo.userEmail = Util.getUserEmail(appContext);
// Initialize modules.
RatingModule.getInstance().setContext(appContext);
MetricModule.setContext(appContext);
// Check the host app version, and notify modules if it's changed.
try {
PackageManager packageManager = appContext.getPackageManager();
PackageInfo packageInfo = packageManager.getPackageInfo(appContext.getPackageName(), 0);
int currentVersionCode = packageInfo.versionCode;
if(prefs.contains(Constants.PREF_KEY_APP_VERSION_CODE)) {
int previousVersionCode = prefs.getInt(Constants.PREF_KEY_APP_VERSION_CODE, 0);
if(previousVersionCode != currentVersionCode) {
onVersionChanged(previousVersionCode, currentVersionCode);
}
}
prefs.edit().putInt(Constants.PREF_KEY_APP_VERSION_CODE, currentVersionCode).commit();
GlobalInfo.appDisplayName = packageManager.getApplicationLabel(packageManager.getApplicationInfo(packageInfo.packageName, 0)).toString();
} catch(PackageManager.NameNotFoundException e) {
// Nothing we can do then.
GlobalInfo.appDisplayName = ""this app"";
}
// Listen for network state changes.
NetworkStateListener networkStateListener = new NetworkStateListener() {
				public void stateChanged(NetworkInfo networkInfo) {
if(networkInfo.getState() == NetworkInfo.State.CONNECTED){
Log.v(""Network connected."");
PayloadSendWorker.start();
}
if(networkInfo.getState() == NetworkInfo.State.DISCONNECTED){
Log.v(""Network disconnected."");
}
}
			};
NetworkStateReceiver.addListener(networkStateListener);
// Grab the conversation token from shared preferences.
if(prefs.contains(Constants.PREF_KEY_CONVERSATION_TOKEN) && prefs.contains(Constants.PREF_KEY_PERSON_ID)) {
GlobalInfo.conversationToken = prefs.getString(Constants.PREF_KEY_CONVERSATION_TOKEN, null);
GlobalInfo.personId = prefs.getString(Constants.PREF_KEY_PERSON_ID, null);
}
GlobalInfo.initialized = true;
Log.v(""Done initializing..."");
} else {
Log.v(""Already initialized..."");
}
// Initialize the Conversation Token, or fetch if needed. Fetch config it the token is available.
if(GlobalInfo.conversationToken == null || GlobalInfo.personId == null) {
asyncFetchConversationToken();
} else {
asyncFetchAppConfiguration();
}
// TODO: Do this on a dedicated thread if it takes too long. Some HTC devices might take like 30 seconds I think.
// See if the device info has changed.
Device deviceInfo = DeviceManager.storeDeviceAndReturnDiff(appContext);
if(deviceInfo != null) {
Log.d(""Device info was updated."");
Log.v(deviceInfo.toString());
Apptentive.getDatabase().addPayload(deviceInfo);
} else {
Log.d(""Device info was not updated."");
}
Sdk sdk = SdkManager.storeSdkAndReturnDiff(appContext);
if(sdk != null) {
Log.d(""Sdk was updated."");
Log.v(sdk.toString());
Apptentive.getDatabase().addPayload(sdk);
} else {
Log.d(""Sdk was not updated."");
}
// TODO: Send AppInfo update if app info was updated.
// TODO: Check out locale...
Log.e(""Default Locale: %s"", Locale.getDefault().toString());
// TODO: Handle upgrades to the database.
// Finally, ensure the send worker is running.
PayloadSendWorker.start();
}","private static void init() {
//
// First, initialize data relies on synchronous reads from local resources.
//
if(!GlobalInfo.initialized) {
SharedPreferences prefs = appContext.getSharedPreferences(Constants.PREF_NAME, Context.MODE_PRIVATE);
db = new ApptentiveDatabase(appContext);
NetworkStateReceiver.clearListeners();
// First, Get the api key, and figure out if app is debuggable.
GlobalInfo.isAppDebuggable = false;
String apiKey = null;
try {
ApplicationInfo ai = appContext.getPackageManager().getApplicationInfo(appContext.getPackageName(), PackageManager.GET_META_DATA);
if(ai != null && ai.metaData != null && ai.metaData.containsKey(Constants.MANIFEST_KEY_APPTENTIVE_API_KEY)) {
apiKey = ai.metaData.getString(Constants.MANIFEST_KEY_APPTENTIVE_API_KEY);
}
if(ai != null && ((ai.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0)) {
GlobalInfo.isAppDebuggable = true;
}
} catch(Exception e) {
Log.e(""Unexpected error while reading application info."", e);
}
// If we are in debug mode, but no api key is found, throw an exception. Otherwise, just assert log. We don't want to crash a production app.
String errorString = ""No Apptentive api key specified. Please make sure you have specified your api key in your AndroidManifest.xml"";
if((apiKey == null || apiKey.equals(""""))) {
if(GlobalInfo.isAppDebuggable) {
throw new RuntimeException(errorString);
} else {
Log.e(errorString);
}
}
GlobalInfo.apiKey = apiKey;
// Grab app info we need to access later on.
GlobalInfo.appPackage = appContext.getPackageName();
GlobalInfo.androidId = Settings.Secure.getString(appContext.getContentResolver(), android.provider.Settings.Secure.ANDROID_ID);
GlobalInfo.userEmail = Util.getUserEmail(appContext);
// Initialize modules.
RatingModule.getInstance().setContext(appContext);
MetricModule.setContext(appContext);
// Check the host app version, and notify modules if it's changed.
try {
PackageManager packageManager = appContext.getPackageManager();
PackageInfo packageInfo = packageManager.getPackageInfo(appContext.getPackageName(), 0);
int currentVersionCode = packageInfo.versionCode;
if(prefs.contains(Constants.PREF_KEY_APP_VERSION_CODE)) {
int previousVersionCode = prefs.getInt(Constants.PREF_KEY_APP_VERSION_CODE, 0);
if(previousVersionCode != currentVersionCode) {
onVersionChanged(previousVersionCode, currentVersionCode);
}
} else {
// First start.
onVersionChanged(-1, currentVersionCode);
}
prefs.edit().putInt(Constants.PREF_KEY_APP_VERSION_CODE, currentVersionCode).commit();
GlobalInfo.appDisplayName = packageManager.getApplicationLabel(packageManager.getApplicationInfo(packageInfo.packageName, 0)).toString();
} catch(PackageManager.NameNotFoundException e) {
// Nothing we can do then.
GlobalInfo.appDisplayName = ""this app"";
}
// Listen for network state changes.
NetworkStateListener networkStateListener = new NetworkStateListener() {
				public void stateChanged(NetworkInfo networkInfo) {
if(networkInfo.getState() == NetworkInfo.State.CONNECTED){
Log.v(""Network connected."");
PayloadSendWorker.start();
}
if(networkInfo.getState() == NetworkInfo.State.DISCONNECTED){
Log.v(""Network disconnected."");
}
}
			};
NetworkStateReceiver.addListener(networkStateListener);
// Grab the conversation token from shared preferences.
if(prefs.contains(Constants.PREF_KEY_CONVERSATION_TOKEN) && prefs.contains(Constants.PREF_KEY_PERSON_ID)) {
GlobalInfo.conversationToken = prefs.getString(Constants.PREF_KEY_CONVERSATION_TOKEN, null);
GlobalInfo.personId = prefs.getString(Constants.PREF_KEY_PERSON_ID, null);
}
GlobalInfo.initialized = true;
Log.v(""Done initializing..."");
} else {
Log.v(""Already initialized..."");
}
// Initialize the Conversation Token, or fetch if needed. Fetch config it the token is available.
if(GlobalInfo.conversationToken == null || GlobalInfo.personId == null) {
asyncFetchConversationToken();
} else {
asyncFetchAppConfiguration();
}
// TODO: Do this on a dedicated thread if it takes too long. Some HTC devices might take like 30 seconds I think.
// See if the device info has changed.
Device deviceInfo = DeviceManager.storeDeviceAndReturnDiff(appContext);
if(deviceInfo != null) {
Log.d(""Device info was updated."");
Log.v(deviceInfo.toString());
Apptentive.getDatabase().addPayload(deviceInfo);
} else {
Log.d(""Device info was not updated."");
}
Sdk sdk = SdkManager.storeSdkAndReturnDiff(appContext);
if(sdk != null) {
Log.d(""Sdk was updated."");
Log.v(sdk.toString());
Apptentive.getDatabase().addPayload(sdk);
} else {
Log.d(""Sdk was not updated."");
}
// TODO: Check out locale...
Log.e(""Default Locale: %s"", Locale.getDefault().toString());
// Finally, ensure the send worker is running.
PayloadSendWorker.start();
}","private static void init  ( ) { // // First, initialize data relies on synchronous reads from local resources. // if ( ! GlobalInfo . initialized ) { SharedPreferences prefs = appContext . getSharedPreferences ( Constants . PREF_NAME , Context . MODE_PRIVATE ) ; db = new ApptentiveDatabase ( appContext ) ; NetworkStateReceiver . clearListeners ( ) ; // First, Get the api key, and figure out if app is debuggable. GlobalInfo . isAppDebuggable = false ; String apiKey = null ; try { ApplicationInfo ai = appContext . getPackageManager ( ) . getApplicationInfo ( appContext . getPackageName ( ) , PackageManager . GET_META_DATA ) ; if ( ai != null && ai . metaData != null && ai . metaData . containsKey ( Constants . MANIFEST_KEY_APPTENTIVE_API_KEY ) ) { apiKey = ai . metaData . getString ( Constants . MANIFEST_KEY_APPTENTIVE_API_KEY ) ; } if ( ai != null && ( ( ai . flags & ApplicationInfo . FLAG_DEBUGGABLE ) != 0 ) ) { GlobalInfo . isAppDebuggable = true ; } } catch ( Exception e ) { Log . e ( "" Unexpected error while reading application info. "" , e ) ; } // If we are in debug mode, but no api key is found, throw an exception. Otherwise, just assert log. We don't want to crash a production app. String errorString = "" No Apptentive api key specified. Please make sure you have specified your api key in your AndroidManifest.xml "" ; if ( ( apiKey == null || apiKey . equals ( "" "" ) ) ) { if ( GlobalInfo . isAppDebuggable ) { throw new RuntimeException ( errorString ) ; } else { Log . e ( errorString ) ; } } GlobalInfo . apiKey = apiKey ; // Grab app info we need to access later on. GlobalInfo . appPackage = appContext . getPackageName ( ) ; GlobalInfo . androidId = Settings . Secure . getString ( appContext . getContentResolver ( ) , android . provider . Settings . Secure . ANDROID_ID ) ; GlobalInfo . userEmail = Util . getUserEmail ( appContext ) ; // Initialize modules. RatingModule . getInstance ( ) . setContext ( appContext ) ; MetricModule . setContext ( appContext ) ; // Check the host app version, and notify modules if it's changed. try { PackageManager packageManager = appContext . getPackageManager ( ) ; PackageInfo packageInfo = packageManager . getPackageInfo ( appContext . getPackageName ( ) , 0 ) ; int currentVersionCode = packageInfo . versionCode ; if ( prefs . contains ( Constants . PREF_KEY_APP_VERSION_CODE ) ) { int previousVersionCode = prefs . getInt ( Constants . PREF_KEY_APP_VERSION_CODE , 0 ) ; if ( previousVersionCode != currentVersionCode ) { onVersionChanged ( previousVersionCode , currentVersionCode ) ; } } prefs . edit ( ) . putInt ( Constants . PREF_KEY_APP_VERSION_CODE , currentVersionCode ) . commit ( ) ; GlobalInfo . appDisplayName = packageManager . getApplicationLabel ( packageManager . getApplicationInfo ( packageInfo . packageName , 0 ) ) . toString ( ) ; } catch ( PackageManager . NameNotFoundException e ) { // Nothing we can do then. GlobalInfo . appDisplayName = "" this app "" ; } // Listen for network state changes. NetworkStateListener networkStateListener = new NetworkStateListener ( ) { public void stateChanged ( NetworkInfo networkInfo ) { if ( networkInfo . getState ( ) == NetworkInfo . State . CONNECTED ) { Log . v ( "" Network connected. "" ) ; PayloadSendWorker . start ( ) ; } if ( networkInfo . getState ( ) == NetworkInfo . State . DISCONNECTED ) { Log . v ( "" Network disconnected. "" ) ; } } } ; NetworkStateReceiver . addListener ( networkStateListener ) ; // Grab the conversation token from shared preferences. if ( prefs . contains ( Constants . PREF_KEY_CONVERSATION_TOKEN ) && prefs . contains ( Constants . PREF_KEY_PERSON_ID ) ) { GlobalInfo . conversationToken = prefs . getString ( Constants . PREF_KEY_CONVERSATION_TOKEN , null ) ; GlobalInfo . personId = prefs . getString ( Constants . PREF_KEY_PERSON_ID , null ) ; } GlobalInfo . initialized = true ; Log . v ( "" Done initializing... "" ) ; } else { Log . v ( "" Already initialized... "" ) ; } // Initialize the Conversation Token, or fetch if needed. Fetch config it the token is available. if ( GlobalInfo . conversationToken == null || GlobalInfo . personId == null ) { asyncFetchConversationToken ( ) ; } else { asyncFetchAppConfiguration ( ) ; } // TODO: Do this on a dedicated thread if it takes too long. Some HTC devices might take like 30 seconds I think. // See if the device info has changed. Device deviceInfo = DeviceManager . storeDeviceAndReturnDiff ( appContext ) ; if ( deviceInfo != null ) { Log . d ( "" Device info was updated. "" ) ; Log . v ( deviceInfo . toString ( ) ) ; Apptentive . getDatabase ( ) . addPayload ( deviceInfo ) ; } else { Log . d ( "" Device info was not updated. "" ) ; } Sdk sdk = SdkManager . storeSdkAndReturnDiff ( appContext ) ; if ( sdk != null ) { Log . d ( "" Sdk was updated. "" ) ; Log . v ( sdk . toString ( ) ) ; Apptentive . getDatabase ( ) . addPayload ( sdk ) ; } else { Log . d ( "" Sdk was not updated. "" ) ; } // <SATD_START> TODO: Send AppInfo update if app info was updated. <SATD_END> // TODO: Check out locale... Log . e ( "" Default Locale: %s "" , Locale . getDefault ( ) . toString ( ) ) ; // TODO: Handle upgrades to the database. // Finally, ensure the send worker is running. PayloadSendWorker . start ( ) ; }","private static void init  ( ) { // // First, initialize data relies on synchronous reads from local resources. // if ( ! GlobalInfo . initialized ) { SharedPreferences prefs = appContext . getSharedPreferences ( Constants . PREF_NAME , Context . MODE_PRIVATE ) ; db = new ApptentiveDatabase ( appContext ) ; NetworkStateReceiver . clearListeners ( ) ; // First, Get the api key, and figure out if app is debuggable. GlobalInfo . isAppDebuggable = false ; String apiKey = null ; try { ApplicationInfo ai = appContext . getPackageManager ( ) . getApplicationInfo ( appContext . getPackageName ( ) , PackageManager . GET_META_DATA ) ; if ( ai != null && ai . metaData != null && ai . metaData . containsKey ( Constants . MANIFEST_KEY_APPTENTIVE_API_KEY ) ) { apiKey = ai . metaData . getString ( Constants . MANIFEST_KEY_APPTENTIVE_API_KEY ) ; } if ( ai != null && ( ( ai . flags & ApplicationInfo . FLAG_DEBUGGABLE ) != 0 ) ) { GlobalInfo . isAppDebuggable = true ; } } catch ( Exception e ) { Log . e ( "" Unexpected error while reading application info. "" , e ) ; } // If we are in debug mode, but no api key is found, throw an exception. Otherwise, just assert log. We don't want to crash a production app. String errorString = "" No Apptentive api key specified. Please make sure you have specified your api key in your AndroidManifest.xml "" ; if ( ( apiKey == null || apiKey . equals ( "" "" ) ) ) { if ( GlobalInfo . isAppDebuggable ) { throw new RuntimeException ( errorString ) ; } else { Log . e ( errorString ) ; } } GlobalInfo . apiKey = apiKey ; // Grab app info we need to access later on. GlobalInfo . appPackage = appContext . getPackageName ( ) ; GlobalInfo . androidId = Settings . Secure . getString ( appContext . getContentResolver ( ) , android . provider . Settings . Secure . ANDROID_ID ) ; GlobalInfo . userEmail = Util . getUserEmail ( appContext ) ; // Initialize modules. RatingModule . getInstance ( ) . setContext ( appContext ) ; MetricModule . setContext ( appContext ) ; // Check the host app version, and notify modules if it's changed. try { PackageManager packageManager = appContext . getPackageManager ( ) ; PackageInfo packageInfo = packageManager . getPackageInfo ( appContext . getPackageName ( ) , 0 ) ; int currentVersionCode = packageInfo . versionCode ; if ( prefs . contains ( Constants . PREF_KEY_APP_VERSION_CODE ) ) { int previousVersionCode = prefs . getInt ( Constants . PREF_KEY_APP_VERSION_CODE , 0 ) ; if ( previousVersionCode != currentVersionCode ) { onVersionChanged ( previousVersionCode , currentVersionCode ) ; } } else { // First start. onVersionChanged ( - 1 , currentVersionCode ) ; } prefs . edit ( ) . putInt ( Constants . PREF_KEY_APP_VERSION_CODE , currentVersionCode ) . commit ( ) ; GlobalInfo . appDisplayName = packageManager . getApplicationLabel ( packageManager . getApplicationInfo ( packageInfo . packageName , 0 ) ) . toString ( ) ; } catch ( PackageManager . NameNotFoundException e ) { // Nothing we can do then. GlobalInfo . appDisplayName = "" this app "" ; } // Listen for network state changes. NetworkStateListener networkStateListener = new NetworkStateListener ( ) { public void stateChanged ( NetworkInfo networkInfo ) { if ( networkInfo . getState ( ) == NetworkInfo . State . CONNECTED ) { Log . v ( "" Network connected. "" ) ; PayloadSendWorker . start ( ) ; } if ( networkInfo . getState ( ) == NetworkInfo . State . DISCONNECTED ) { Log . v ( "" Network disconnected. "" ) ; } } } ; NetworkStateReceiver . addListener ( networkStateListener ) ; // Grab the conversation token from shared preferences. if ( prefs . contains ( Constants . PREF_KEY_CONVERSATION_TOKEN ) && prefs . contains ( Constants . PREF_KEY_PERSON_ID ) ) { GlobalInfo . conversationToken = prefs . getString ( Constants . PREF_KEY_CONVERSATION_TOKEN , null ) ; GlobalInfo . personId = prefs . getString ( Constants . PREF_KEY_PERSON_ID , null ) ; } GlobalInfo . initialized = true ; Log . v ( "" Done initializing... "" ) ; } else { Log . v ( "" Already initialized... "" ) ; } // Initialize the Conversation Token, or fetch if needed. Fetch config it the token is available. if ( GlobalInfo . conversationToken == null || GlobalInfo . personId == null ) { asyncFetchConversationToken ( ) ; } else { asyncFetchAppConfiguration ( ) ; } // TODO: Do this on a dedicated thread if it takes too long. Some HTC devices might take like 30 seconds I think. // See if the device info has changed. Device deviceInfo = DeviceManager . storeDeviceAndReturnDiff ( appContext ) ; if ( deviceInfo != null ) { Log . d ( "" Device info was updated. "" ) ; Log . v ( deviceInfo . toString ( ) ) ; Apptentive . getDatabase ( ) . addPayload ( deviceInfo ) ; } else { Log . d ( "" Device info was not updated. "" ) ; } Sdk sdk = SdkManager . storeSdkAndReturnDiff ( appContext ) ; if ( sdk != null ) { Log . d ( "" Sdk was updated. "" ) ; Log . v ( sdk . toString ( ) ) ; Apptentive . getDatabase ( ) . addPayload ( sdk ) ; } else { Log . d ( "" Sdk was not updated. "" ) ; } // TODO: Check out locale... Log . e ( "" Default Locale: %s "" , Locale . getDefault ( ) . toString ( ) ) ; // Finally, ensure the send worker is running. PayloadSendWorker . start ( ) ; }",2013/3/4 16:18,2013/4/30 20:14,1,Other
3048,290,https://www.github.com/modelmapper/modelmapper,shouldShadeWhenNullEncountered(),DESIGN,67,67,67,67,TODO this line should pass since the source message is null,https://www.github.com/modelmapper/modelmapper/commit/19492712,https://www.github.com/modelmapper/modelmapper/commit/3107b8c517fae7fc73f43e454a6c0bb7b2fb7347,core/src/test/java/org/modelmapper/functional/shading/NullMapping2.java,"public void shouldShadeWhenNullEncountered() {
Container c = new Container();
List<Item> items = new ArrayList<Item>(10);
for (int i = 0; i < 5; i++)
items.add(new Item(i == 2 ? null : new Message(""value1"", ""value2"")));
c.items = items;
ContainerDTO dto = modelMapper.map(c, ContainerDTO.class);
for (int i = 0; i < dto.items.size(); i++)
if (i == 2) {
// TODO this line should pass since the source message is null
// assertNull(dto.items.get(i).message);
assertNull(dto.items.get(i).message.value1);
assertNull(dto.items.get(i).message.value2);
} else {
assertNotNull(dto.items.get(i).message.value1);
assertNotNull(dto.items.get(i).message.value2);
}
}","public void shouldShadeWhenNullEncountered() {
Container c = new Container();
List<Item> items = new ArrayList<Item>(10);
for (int i = 0; i < 5; i++)
items.add(new Item(i == 2 ? null : new Message(""value1"", ""value2"")));
c.items = items;
ContainerDTO dto = modelMapper.map(c, ContainerDTO.class);
for (int i = 0; i < dto.items.size(); i++)
if (i == 2) {
assertNull(dto.items.get(i).message);
} else {
assertNotNull(dto.items.get(i).message.value1);
assertNotNull(dto.items.get(i).message.value2);
}
}","public void shouldShadeWhenNullEncountered  ( ) { Container c = new Container ( ) ; List < Item > items = new ArrayList < Item > ( 10 ) ; for ( int i = 0 ; i < 5 ; i ++ ) items . add ( new Item ( i == 2 ? null : new Message ( "" value1 "" , "" value2 "" ) ) ) ; c . items = items ; ContainerDTO dto = modelMapper . map ( c , ContainerDTO . class ) ; for ( int i = 0 ; i < dto . items . size ( ) ; i ++ ) if ( i == 2 ) { // <SATD_START> TODO this line should pass since the source message is null <SATD_END> // assertNull(dto.items.get(i).message); assertNull ( dto . items . get ( i ) . message . value1 ) ; assertNull ( dto . items . get ( i ) . message . value2 ) ; } else { assertNotNull ( dto . items . get ( i ) . message . value1 ) ; assertNotNull ( dto . items . get ( i ) . message . value2 ) ; } }","public void shouldShadeWhenNullEncountered  ( ) { Container c = new Container ( ) ; List < Item > items = new ArrayList < Item > ( 10 ) ; for ( int i = 0 ; i < 5 ; i ++ ) items . add ( new Item ( i == 2 ? null : new Message ( "" value1 "" , "" value2 "" ) ) ) ; c . items = items ; ContainerDTO dto = modelMapper . map ( c , ContainerDTO . class ) ; for ( int i = 0 ; i < dto . items . size ( ) ; i ++ ) if ( i == 2 ) { assertNull ( dto . items . get ( i ) . message ) ; } else { assertNotNull ( dto . items . get ( i ) . message . value1 ) ; assertNotNull ( dto . items . get ( i ) . message . value2 ) ; } }",2012/7/20 15:01,2013/1/5 19:04,6,Exclamatory
2848,121,https://www.github.com/erlang/erlide_eclipse,store(IEclipsePreferences),,170,170,170,170,TODO remove these later,https://www.github.com/erlang/erlide_eclipse/commit/fee3f6450d,https://www.github.com/erlang/erlide_eclipse/commit/b8529b14b7bb32fd4bcae18cf054bb8ed0338c9d,org.erlide.core/src/org/erlide/core/preferences/OldErlangProjectProperties.java,"public void store(final IEclipsePreferences node) {
if (project == null) {
return;
}
if (""true"".equals(System.getProperty(""erlide.newprops""))) {
try {
final ErlProjectInfo npp = PropertiesUtils.convertOld(this);
final ErlProjectInfoBuilder builder = new ErlProjectInfoBuilder();
builder.storeToPreferences(npp,
                        (IEclipsePreferences) node.node(""test""));
} catch (final BackingStoreException e) {
e.printStackTrace();
} catch (final URISyntaxException e) {
e.printStackTrace();
}
}
node.removePreferenceChangeListener(this);
try {
node.put(ProjectPreferencesConstants.SOURCE_DIRS,
                    PathSerializer.packList(sourceDirs));
node.put(ProjectPreferencesConstants.INCLUDE_DIRS,
                    PathSerializer.packList(includeDirs));
node.put(ProjectPreferencesConstants.OUTPUT_DIR,
                    outputDir.toString());
node.put(ProjectPreferencesConstants.EXTERNAL_INCLUDES,
                    externalIncludesFile);
if (runtimeVersion.isDefined()) {
node.put(ProjectPreferencesConstants.RUNTIME_VERSION,
                        runtimeVersion.asMinor().toString());
} else {
node.remove(ProjectPreferencesConstants.RUNTIME_VERSION);
}
if (runtimeName != null) {
node.put(ProjectPreferencesConstants.RUNTIME_NAME, runtimeName);
} else {
node.remove(ProjectPreferencesConstants.RUNTIME_NAME);
}
// TODO remove these later
node.remove(""backend_cookie"");
node.remove(""backend_node"");
// end todo
node.put(ProjectPreferencesConstants.PROJECT_EXTERNAL_MODULES,
                    externalModulesFile);
try {
node.flush();
} catch (final BackingStoreException e1) {
}
} finally {
node.addPreferenceChangeListener(this);
}
}","public void store(final IEclipsePreferences node) {
if (project == null) {
return;
}
if (""true"".equals(System.getProperty(""erlide.newprops""))) {
try {
final ErlProjectInfo npp = PropertiesUtils.convertOld(this);
final ErlProjectInfoBuilder builder = new ErlProjectInfoBuilder();
builder.storeToPreferences(npp,
                        (IEclipsePreferences) node.node(""test""));
} catch (final BackingStoreException e) {
e.printStackTrace();
} catch (final URISyntaxException e) {
e.printStackTrace();
}
}
node.removePreferenceChangeListener(this);
try {
node.put(ProjectPreferencesConstants.SOURCE_DIRS,
                    PathSerializer.packList(sourceDirs));
node.put(ProjectPreferencesConstants.INCLUDE_DIRS,
                    PathSerializer.packList(includeDirs));
node.put(ProjectPreferencesConstants.OUTPUT_DIR,
                    outputDir.toString());
node.put(ProjectPreferencesConstants.EXTERNAL_INCLUDES,
                    externalIncludesFile);
if (runtimeVersion.isDefined()) {
node.put(ProjectPreferencesConstants.RUNTIME_VERSION,
                        runtimeVersion.asMinor().toString());
} else {
node.remove(ProjectPreferencesConstants.RUNTIME_VERSION);
}
if (runtimeName != null) {
node.put(ProjectPreferencesConstants.RUNTIME_NAME, runtimeName);
} else {
node.remove(ProjectPreferencesConstants.RUNTIME_NAME);
}
node.put(ProjectPreferencesConstants.PROJECT_EXTERNAL_MODULES,
                    externalModulesFile);
try {
node.flush();
} catch (final BackingStoreException e1) {
}
} finally {
node.addPreferenceChangeListener(this);
}
}","public void store  ( final IEclipsePreferences node ) { if ( project == null ) { return ; } if ( "" true "" . equals ( System . getProperty ( "" erlide.newprops "" ) ) ) { try { final ErlProjectInfo npp = PropertiesUtils . convertOld ( this ) ; final ErlProjectInfoBuilder builder = new ErlProjectInfoBuilder ( ) ; builder . storeToPreferences ( npp , ( IEclipsePreferences ) node . node ( "" test "" ) ) ; } catch ( final BackingStoreException e ) { e . printStackTrace ( ) ; } catch ( final URISyntaxException e ) { e . printStackTrace ( ) ; } } node . removePreferenceChangeListener ( this ) ; try { node . put ( ProjectPreferencesConstants . SOURCE_DIRS , PathSerializer . packList ( sourceDirs ) ) ; node . put ( ProjectPreferencesConstants . INCLUDE_DIRS , PathSerializer . packList ( includeDirs ) ) ; node . put ( ProjectPreferencesConstants . OUTPUT_DIR , outputDir . toString ( ) ) ; node . put ( ProjectPreferencesConstants . EXTERNAL_INCLUDES , externalIncludesFile ) ; if ( runtimeVersion . isDefined ( ) ) { node . put ( ProjectPreferencesConstants . RUNTIME_VERSION , runtimeVersion . asMinor ( ) . toString ( ) ) ; } else { node . remove ( ProjectPreferencesConstants . RUNTIME_VERSION ) ; } if ( runtimeName != null ) { node . put ( ProjectPreferencesConstants . RUNTIME_NAME , runtimeName ) ; } else { node . remove ( ProjectPreferencesConstants . RUNTIME_NAME ) ; } // <SATD_START> TODO remove these later <SATD_END> node . remove ( "" backend_cookie "" ) ; node . remove ( "" backend_node "" ) ; // end todo node . put ( ProjectPreferencesConstants . PROJECT_EXTERNAL_MODULES , externalModulesFile ) ; try { node . flush ( ) ; } catch ( final BackingStoreException e1 ) { } } finally { node . addPreferenceChangeListener ( this ) ; } }","public void store  ( final IEclipsePreferences node ) { if ( project == null ) { return ; } if ( "" true "" . equals ( System . getProperty ( "" erlide.newprops "" ) ) ) { try { final ErlProjectInfo npp = PropertiesUtils . convertOld ( this ) ; final ErlProjectInfoBuilder builder = new ErlProjectInfoBuilder ( ) ; builder . storeToPreferences ( npp , ( IEclipsePreferences ) node . node ( "" test "" ) ) ; } catch ( final BackingStoreException e ) { e . printStackTrace ( ) ; } catch ( final URISyntaxException e ) { e . printStackTrace ( ) ; } } node . removePreferenceChangeListener ( this ) ; try { node . put ( ProjectPreferencesConstants . SOURCE_DIRS , PathSerializer . packList ( sourceDirs ) ) ; node . put ( ProjectPreferencesConstants . INCLUDE_DIRS , PathSerializer . packList ( includeDirs ) ) ; node . put ( ProjectPreferencesConstants . OUTPUT_DIR , outputDir . toString ( ) ) ; node . put ( ProjectPreferencesConstants . EXTERNAL_INCLUDES , externalIncludesFile ) ; if ( runtimeVersion . isDefined ( ) ) { node . put ( ProjectPreferencesConstants . RUNTIME_VERSION , runtimeVersion . asMinor ( ) . toString ( ) ) ; } else { node . remove ( ProjectPreferencesConstants . RUNTIME_VERSION ) ; } if ( runtimeName != null ) { node . put ( ProjectPreferencesConstants . RUNTIME_NAME , runtimeName ) ; } else { node . remove ( ProjectPreferencesConstants . RUNTIME_NAME ) ; } node . put ( ProjectPreferencesConstants . PROJECT_EXTERNAL_MODULES , externalModulesFile ) ; try { node . flush ( ) ; } catch ( final BackingStoreException e1 ) { } } finally { node . addPreferenceChangeListener ( this ) ; } }",2010-09-10 16:19:25 +0200,2010-12-25 19:24:41 +0100,5,Other
738,541,https://www.github.com/jboss-logging/jboss-logmanager,publish(ExtLogRecord),NOT_DESIGN,389,389,389,389,todo - error handler,https://www.github.com/jboss-logging/jboss-logmanager/commit/f1ca8a8b,https://www.github.com/jboss-logging/jboss-logmanager/commit/bc6c0ab785a50b01442914da479a6e9dd4d3e5f2,core/src/main/java/org/jboss/logmanager/LoggerNode.java,"void publish(final ExtLogRecord record) {
for (Handler handler : handlers) try {
handler.publish(record);
} catch (VirtualMachineError e) {
throw e;
} catch (Throwable t) {
// todo - error handler
}
if (useParentHandlers) {
final LoggerNode parent = this.parent;
if (parent != null) parent.publish(record);
}
}","void publish(final ExtLogRecord record) {
for (Handler handler : handlers) try {
handler.publish(record);
} catch (VirtualMachineError e) {
throw e;
} catch (Throwable t) {
ErrorManager errorManager = AccessController.doPrivileged(new PrivilegedAction<ErrorManager>() {
                @Override
public ErrorManager run() {
return handler.getErrorManager();
}
            });
if (errorManager != null) {
Exception e;
if (t instanceof Exception) {
e = (Exception) t;
} else {
e = new UndeclaredThrowableException(t);
e.setStackTrace(EMPTY_STACK);
}
try {
errorManager.error(""Handler publication threw an exception"", e, ErrorManager.WRITE_FAILURE);
} catch (Throwable t2) {
StandardOutputStreams.printError(t2, ""Handler.reportError caught an exception"");
}
}
}
if (useParentHandlers) {
final LoggerNode parent = this.parent;
if (parent != null) parent.publish(record);
}
}",void publish  ( final ExtLogRecord record ) { for ( Handler handler : handlers ) try { handler . publish ( record ) ; } catch ( VirtualMachineError e ) { throw e ; } catch ( Throwable t ) { // <SATD_START> todo - error handler <SATD_END> } if ( useParentHandlers ) { final LoggerNode parent = this . parent ; if ( parent != null ) parent . publish ( record ) ; } },"void publish  ( final ExtLogRecord record ) { for ( Handler handler : handlers ) try { handler . publish ( record ) ; } catch ( VirtualMachineError e ) { throw e ; } catch ( Throwable t ) { ErrorManager errorManager = AccessController . doPrivileged ( new PrivilegedAction < ErrorManager > ( ) { @ Override public ErrorManager run ( ) { return handler . getErrorManager ( ) ; } } ) ; if ( errorManager != null ) { Exception e ; if ( t instanceof Exception ) { e = ( Exception ) t ; } else { e = new UndeclaredThrowableException ( t ) ; e . setStackTrace ( EMPTY_STACK ) ; } try { errorManager . error ( "" Handler publication threw an exception "" , e , ErrorManager . WRITE_FAILURE ) ; } catch ( Throwable t2 ) { StandardOutputStreams . printError ( t2 , "" Handler.reportError caught an exception "" ) ; } } } if ( useParentHandlers ) { final LoggerNode parent = this . parent ; if ( parent != null ) parent . publish ( record ) ; } }",2010-07-29 21:41:19 +0000,2022/3/18 14:00,20,Other
1201,27,https://www.github.com/aosp-mirror/platform_packages_apps_packageinstaller,"configure(String, Context)",DESIGN,81,81,81,81,TODO: STOPSHIP: MATCH_CATEGORY_SCHEME ?,https://www.github.com/aosp-mirror/platform_packages_apps_packageinstaller/commit/7ee58500e6,https://www.github.com/aosp-mirror/platform_packages_apps_packageinstaller/commit/89db9b4e76d4b347afa6c74b4166ad89431f877e,src/com/android/packageinstaller/role/model/PreferredActivity.java,"public void configure(@NonNull String packageName, @NonNull Context context) {
IntentFilter intentFilter = mActivity.getIntentFilterData().createIntentFilter();
List<ComponentName> activities = mActivity.getQualifyingComponentsAsUser(
                Process.myUserHandle(), context);
ComponentName packageActivity = mActivity.getQualifyingComponentForPackage(
                packageName, context);
// TODO: STOPSHIP: Race condition, what if packageActivity became null? Just don't crash?
if (packageActivity == null) {
return;
}
PackageManager packageManager = context.getPackageManager();
// TODO: STOPSHIP: MATCH_CATEGORY_SCHEME ?
packageManager.replacePreferredActivity(intentFilter, IntentFilter.MATCH_CATEGORY_SCHEME
| IntentFilter.MATCH_ADJUSTMENT_NORMAL, activities, packageActivity);
}","public void configure(@NonNull String packageName, @NonNull Context context) {
PackageManager packageManager = context.getPackageManager();
IntentFilterData intentFilterData = mActivity.getIntentFilterData();
IntentFilter intentFilter = intentFilterData.createIntentFilter();
// PackageManager.replacePreferredActivity() expects filter to have no data authorities,
// paths, or types; and at most one scheme.
int match = intentFilterData.getDataScheme() != null ? IntentFilter.MATCH_CATEGORY_SCHEME
: IntentFilter.MATCH_CATEGORY_EMPTY;
List<ComponentName> activities = mActivity.getQualifyingComponentsAsUser(
                Process.myUserHandle(), context);
ComponentName packageActivity = mActivity.getQualifyingComponentForPackage(
                packageName, context);
// TODO: STOPSHIP: Race condition, what if packageActivity became null? Just don't crash?
if (packageActivity == null) {
return;
}
packageManager.replacePreferredActivity(intentFilter, match, activities, packageActivity);
}","public void configure  ( @ NonNull String packageName , @ NonNull Context context ) { IntentFilter intentFilter = mActivity . getIntentFilterData ( ) . createIntentFilter ( ) ; List < ComponentName > activities = mActivity . getQualifyingComponentsAsUser ( Process . myUserHandle ( ) , context ) ; ComponentName packageActivity = mActivity . getQualifyingComponentForPackage ( packageName , context ) ; // TODO: STOPSHIP: Race condition, what if packageActivity became null? Just don't crash? if ( packageActivity == null ) { return ; } PackageManager packageManager = context . getPackageManager ( ) ; // <SATD_START> TODO: STOPSHIP: MATCH_CATEGORY_SCHEME ? <SATD_END> packageManager . replacePreferredActivity ( intentFilter , IntentFilter . MATCH_CATEGORY_SCHEME | IntentFilter . MATCH_ADJUSTMENT_NORMAL , activities , packageActivity ) ; }","public void configure  ( @ NonNull String packageName , @ NonNull Context context ) { PackageManager packageManager = context . getPackageManager ( ) ; IntentFilterData intentFilterData = mActivity . getIntentFilterData ( ) ; IntentFilter intentFilter = intentFilterData . createIntentFilter ( ) ; // PackageManager.replacePreferredActivity() expects filter to have no data authorities, // paths, or types; and at most one scheme. int match = intentFilterData . getDataScheme ( ) != null ? IntentFilter . MATCH_CATEGORY_SCHEME : IntentFilter . MATCH_CATEGORY_EMPTY ; List < ComponentName > activities = mActivity . getQualifyingComponentsAsUser ( Process . myUserHandle ( ) , context ) ; ComponentName packageActivity = mActivity . getQualifyingComponentForPackage ( packageName , context ) ; // TODO: STOPSHIP: Race condition, what if packageActivity became null? Just don't crash? if ( packageActivity == null ) { return ; } packageManager . replacePreferredActivity ( intentFilter , match , activities , packageActivity ) ; }",2018/11/9 13:26,2019/1/10 16:44,19,Interrogative
600,197,https://www.github.com/apache/mina-sshd,testFallbackResolver(),NOT_DESIGN,47,47,47,47,TODO use some,https://www.github.com/apache/mina-sshd/commit/2867cbe674,https://www.github.com/apache/mina-sshd/commit/3767115ed1b207cc103da202aeb78647ea6bd59e,sshd-common/src/test/java/org/apache/sshd/common/config/keys/PublicKeyEntryTest.java,"@Test
public void testFallbackResolver() throws Exception {
PublicKeyEntry entry =  // TODO use some
PublicKeyEntry.parsePublicKeyEntry(
                        GenericUtils.join(
                                Arrays.asList(getCurrentTestName(), ""AAAA"", getClass().getSimpleName()), ' '));
for (PublicKeyEntryResolver resolver : new PublicKeyEntryResolver[]{
            null, PublicKeyEntryResolver.FAILING, PublicKeyEntryResolver.IGNORING}) {
try {
PublicKey key = entry.resolvePublicKey(resolver);
assertSame(""Mismatched successful resolver"", PublicKeyEntryResolver.IGNORING, resolver);
assertNull(""Unexpected success for resolver="" + resolver + "": "" + KeyUtils.getFingerPrint(key), key);
} catch (GeneralSecurityException e) {
assertObjectInstanceOf(""Mismatched thrown exception for resolver="" + resolver, InvalidKeySpecException.class, e);
}
}
}","@Test
public void testFallbackResolver() throws Exception {
PublicKeyEntry entry =
            PublicKeyEntry.parsePublicKeyEntry(
                GenericUtils.join(
                    Arrays.asList(getCurrentTestName(), ""AAAA"", getClass().getSimpleName()), ' '));
for (PublicKeyEntryResolver resolver : new PublicKeyEntryResolver[]{
            null, PublicKeyEntryResolver.FAILING, PublicKeyEntryResolver.IGNORING}) {
try {
PublicKey key = entry.resolvePublicKey(null, resolver);
assertSame(""Mismatched successful resolver"", PublicKeyEntryResolver.IGNORING, resolver);
assertNull(""Unexpected success for resolver="" + resolver + "": "" + KeyUtils.getFingerPrint(key), key);
} catch (GeneralSecurityException e) {
assertObjectInstanceOf(""Mismatched thrown exception for resolver="" + resolver, InvalidKeySpecException.class, e);
}
}
}","@ Test public void testFallbackResolver  ( ) throws Exception  { PublicKeyEntry entry = // <SATD_START> TODO use some <SATD_END> PublicKeyEntry . parsePublicKeyEntry ( GenericUtils . join ( Arrays . asList ( getCurrentTestName ( ) , "" AAAA "" , getClass ( ) . getSimpleName ( ) ) , ' ' ) ) ; for ( PublicKeyEntryResolver resolver : new PublicKeyEntryResolver [ ] { null , PublicKeyEntryResolver . FAILING , PublicKeyEntryResolver . IGNORING } ) { try { PublicKey key = entry . resolvePublicKey ( resolver ) ; assertSame ( "" Mismatched successful resolver "" , PublicKeyEntryResolver . IGNORING , resolver ) ; assertNull ( "" Unexpected success for resolver= "" + resolver + "" :  "" + KeyUtils . getFingerPrint ( key ) , key ) ; } catch ( GeneralSecurityException e ) { assertObjectInstanceOf ( "" Mismatched thrown exception for resolver= "" + resolver , InvalidKeySpecException . class , e ) ; } } }","@ Test public void testFallbackResolver  ( ) throws Exception  { PublicKeyEntry entry = PublicKeyEntry . parsePublicKeyEntry ( GenericUtils . join ( Arrays . asList ( getCurrentTestName ( ) , "" AAAA "" , getClass ( ) . getSimpleName ( ) ) , ' ' ) ) ; for ( PublicKeyEntryResolver resolver : new PublicKeyEntryResolver [ ] { null , PublicKeyEntryResolver . FAILING , PublicKeyEntryResolver . IGNORING } ) { try { PublicKey key = entry . resolvePublicKey ( null , resolver ) ; assertSame ( "" Mismatched successful resolver "" , PublicKeyEntryResolver . IGNORING , resolver ) ; assertNull ( "" Unexpected success for resolver= "" + resolver + "" :  "" + KeyUtils . getFingerPrint ( key ) , key ) ; } catch ( GeneralSecurityException e ) { assertObjectInstanceOf ( "" Mismatched thrown exception for resolver= "" + resolver , InvalidKeySpecException . class , e ) ; } } }",2015-11-23 12:59:44 +0200,2018-11-22 07:05:16 +0200,9,Other
2822,193,https://www.github.com/graylog2/graylog2-server,onStart(Application),,92,92,92,92,"TODO DI this is wrong, can we use the factory already here?",https://www.github.com/graylog2/graylog2-server/commit/bcbc9a50788,https://www.github.com/graylog2/graylog2-server/commit/9883bbff4ec4396b6f7ff6d51880f9af5a89978b,app/Global.java,"@Override
public void onStart(Application app) {
final String appSecret = app.configuration().getString(""application.secret"");
if (appSecret == null || appSecret.isEmpty()) {
log.error(""Please configure application.secret in your conf/graylog2-web-interface.conf"");
throw new IllegalStateException(""No application.secret configured."");
}
if (appSecret.length() < 16) {
log.error(""Please configure application.secret in your conf/graylog2-web-interface.conf to be longer than 16 characters. Suggested is using pwgen -s 96 or similar"");
throw new IllegalStateException(""application.secret is too short, use at least 16 characters! Suggested is to use pwgen -s 96 or similar"");
}
final String graylog2ServerUris = app.configuration().getString(""graylog2-server.uris"", """");
if (graylog2ServerUris.isEmpty()) {
log.error(""graylog2-server.uris is not set!"");
throw new IllegalStateException(""graylog2-server.uris is empty"");
}
final String[] uris = graylog2ServerUris.split("","");
if (uris.length == 0) {
log.error(""graylog2-server.uris is empty!"");
throw new IllegalStateException(""graylog2-server.uris is empty"");
}
final Node[] initialNodes = new Node[uris.length];
int i = 0;
for (String uri : uris) {
final NodeSummaryResponse r = new NodeSummaryResponse();
r.transportAddress = uri;
initialNodes[i++] = new Node(r); // TODO DI this is wrong, can we use the factory already here?
}
List<Module> modules = Lists.newArrayList();
modules.add(new AbstractModule() {
            @Override
protected void configure() {
bind(Node[].class).annotatedWith(Names.named(""Initial Nodes"")).toInstance(initialNodes);
}
        });
modules.add(new ModelFactoryModule());
injector = Guice.createInjector(modules);
// start the services that need starting
final ApiClient api = injector.getInstance(ApiClient.class);
api.start();
injector.getInstance(ServerNodesRefreshService.class).start();
// TODO replace with custom AuthenticatedAction filter
RedirectAuthenticator.userService = injector.getInstance(UserService.class);
// temporarily disabled for preview to prevent confusion.
//        LocalAdminUserRealm localAdminRealm = new LocalAdminUserRealm(""local-accounts"");
//        localAdminRealm.setCredentialsMatcher(new HashedCredentialsMatcher(""SHA2""));
//        setupLocalUser(api, localAdminRealm, app);
Realm serverRestInterfaceRealm = injector.getInstance(ServerRestInterfaceRealm.class);
final DefaultSecurityManager securityManager =
                new DefaultSecurityManager(
                        Lists.newArrayList(serverRestInterfaceRealm)
                );
final Authenticator authenticator = securityManager.getAuthenticator();
if (authenticator instanceof ModularRealmAuthenticator) {
ModularRealmAuthenticator a = (ModularRealmAuthenticator) authenticator;
a.setAuthenticationStrategy(new RethrowingFirstSuccessfulStrategy());
a.setAuthenticationListeners(
                    Lists.<AuthenticationListener>newArrayList(new PlayAuthenticationListener())
            );
}
SecurityUtils.setSecurityManager(securityManager);
}","@Override
public void onStart(Application app) {
final String appSecret = app.configuration().getString(""application.secret"");
if (appSecret == null || appSecret.isEmpty()) {
log.error(""Please configure application.secret in your conf/graylog2-web-interface.conf"");
throw new IllegalStateException(""No application.secret configured."");
}
if (appSecret.length() < 16) {
log.error(""Please configure application.secret in your conf/graylog2-web-interface.conf to be longer than 16 characters. Suggested is using pwgen -s 96 or similar"");
throw new IllegalStateException(""application.secret is too short, use at least 16 characters! Suggested is to use pwgen -s 96 or similar"");
}
final String graylog2ServerUris = app.configuration().getString(""graylog2-server.uris"", """");
if (graylog2ServerUris.isEmpty()) {
log.error(""graylog2-server.uris is not set!"");
throw new IllegalStateException(""graylog2-server.uris is empty"");
}
final String[] uris = graylog2ServerUris.split("","");
if (uris.length == 0) {
log.error(""graylog2-server.uris is empty!"");
throw new IllegalStateException(""graylog2-server.uris is empty"");
}
final URI[] initialNodes = new URI[uris.length];
int i = 0;
for (String uri : uris) {
initialNodes[i++] = URI.create(uri);
}
List<Module> modules = Lists.newArrayList();
modules.add(new AbstractModule() {
            @Override
protected void configure() {
bind(URI[].class).annotatedWith(Names.named(""Initial Nodes"")).toInstance(initialNodes);
}
        });
modules.add(new ModelFactoryModule());
injector = Guice.createInjector(modules);
// start the services that need starting
final ApiClient api = injector.getInstance(ApiClient.class);
api.start();
injector.getInstance(ServerNodesRefreshService.class).start();
// TODO replace with custom AuthenticatedAction filter
RedirectAuthenticator.userService = injector.getInstance(UserService.class);
// temporarily disabled for preview to prevent confusion.
//        LocalAdminUserRealm localAdminRealm = new LocalAdminUserRealm(""local-accounts"");
//        localAdminRealm.setCredentialsMatcher(new HashedCredentialsMatcher(""SHA2""));
//        setupLocalUser(api, localAdminRealm, app);
Realm serverRestInterfaceRealm = injector.getInstance(ServerRestInterfaceRealm.class);
final DefaultSecurityManager securityManager =
                new DefaultSecurityManager(
                        Lists.newArrayList(serverRestInterfaceRealm)
                );
final Authenticator authenticator = securityManager.getAuthenticator();
if (authenticator instanceof ModularRealmAuthenticator) {
ModularRealmAuthenticator a = (ModularRealmAuthenticator) authenticator;
a.setAuthenticationStrategy(new RethrowingFirstSuccessfulStrategy());
a.setAuthenticationListeners(
                    Lists.<AuthenticationListener>newArrayList(new PlayAuthenticationListener())
            );
}
SecurityUtils.setSecurityManager(securityManager);
}","@ Override public void onStart  ( Application app ) { final String appSecret = app . configuration ( ) . getString ( "" application.secret "" ) ; if ( appSecret == null || appSecret . isEmpty ( ) ) { log . error ( "" Please configure application.secret in your conf/graylog2-web-interface.conf "" ) ; throw new IllegalStateException ( "" No application.secret configured. "" ) ; } if ( appSecret . length ( ) < 16 ) { log . error ( "" Please configure application.secret in your conf/graylog2-web-interface.conf to be longer than 16 characters. Suggested is using pwgen -s 96 or similar "" ) ; throw new IllegalStateException ( "" application.secret is too short, use at least 16 characters! Suggested is to use pwgen -s 96 or similar "" ) ; } final String graylog2ServerUris = app . configuration ( ) . getString ( "" graylog2-server.uris "" , "" "" ) ; if ( graylog2ServerUris . isEmpty ( ) ) { log . error ( "" graylog2-server.uris is not set! "" ) ; throw new IllegalStateException ( "" graylog2-server.uris is empty "" ) ; } final String [ ] uris = graylog2ServerUris . split ( "" , "" ) ; if ( uris . length == 0 ) { log . error ( "" graylog2-server.uris is empty! "" ) ; throw new IllegalStateException ( "" graylog2-server.uris is empty "" ) ; } final Node [ ] initialNodes = new Node [ uris . length ] ; int i = 0 ; for ( String uri : uris ) { final NodeSummaryResponse r = new NodeSummaryResponse ( ) ; r . transportAddress = uri ; initialNodes [ i ++ ] = new Node ( r ) ; // <SATD_START> TODO DI this is wrong, can we use the factory already here? <SATD_END> } List < Module > modules = Lists . newArrayList ( ) ; modules . add ( new AbstractModule ( ) { @ Override protected void configure ( ) { bind ( Node [ ] . class ) . annotatedWith ( Names . named ( "" Initial Nodes "" ) ) . toInstance ( initialNodes ) ; } } ) ; modules . add ( new ModelFactoryModule ( ) ) ; injector = Guice . createInjector ( modules ) ; // start the services that need starting final ApiClient api = injector . getInstance ( ApiClient . class ) ; api . start ( ) ; injector . getInstance ( ServerNodesRefreshService . class ) . start ( ) ; // TODO replace with custom AuthenticatedAction filter RedirectAuthenticator . userService = injector . getInstance ( UserService . class ) ; // temporarily disabled for preview to prevent confusion. //        LocalAdminUserRealm localAdminRealm = new LocalAdminUserRealm(""local-accounts""); //        localAdminRealm.setCredentialsMatcher(new HashedCredentialsMatcher(""SHA2"")); //        setupLocalUser(api, localAdminRealm, app); Realm serverRestInterfaceRealm = injector . getInstance ( ServerRestInterfaceRealm . class ) ; final DefaultSecurityManager securityManager = new DefaultSecurityManager ( Lists . newArrayList ( serverRestInterfaceRealm ) ) ; final Authenticator authenticator = securityManager . getAuthenticator ( ) ; if ( authenticator instanceof ModularRealmAuthenticator ) { ModularRealmAuthenticator a = ( ModularRealmAuthenticator ) authenticator ; a . setAuthenticationStrategy ( new RethrowingFirstSuccessfulStrategy ( ) ) ; a . setAuthenticationListeners ( Lists . < AuthenticationListener > newArrayList ( new PlayAuthenticationListener ( ) ) ) ; } SecurityUtils . setSecurityManager ( securityManager ) ; }","@ Override public void onStart  ( Application app ) { final String appSecret = app . configuration ( ) . getString ( "" application.secret "" ) ; if ( appSecret == null || appSecret . isEmpty ( ) ) { log . error ( "" Please configure application.secret in your conf/graylog2-web-interface.conf "" ) ; throw new IllegalStateException ( "" No application.secret configured. "" ) ; } if ( appSecret . length ( ) < 16 ) { log . error ( "" Please configure application.secret in your conf/graylog2-web-interface.conf to be longer than 16 characters. Suggested is using pwgen -s 96 or similar "" ) ; throw new IllegalStateException ( "" application.secret is too short, use at least 16 characters! Suggested is to use pwgen -s 96 or similar "" ) ; } final String graylog2ServerUris = app . configuration ( ) . getString ( "" graylog2-server.uris "" , "" "" ) ; if ( graylog2ServerUris . isEmpty ( ) ) { log . error ( "" graylog2-server.uris is not set! "" ) ; throw new IllegalStateException ( "" graylog2-server.uris is empty "" ) ; } final String [ ] uris = graylog2ServerUris . split ( "" , "" ) ; if ( uris . length == 0 ) { log . error ( "" graylog2-server.uris is empty! "" ) ; throw new IllegalStateException ( "" graylog2-server.uris is empty "" ) ; } final URI [ ] initialNodes = new URI [ uris . length ] ; int i = 0 ; for ( String uri : uris ) { initialNodes [ i ++ ] = URI . create ( uri ) ; } List < Module > modules = Lists . newArrayList ( ) ; modules . add ( new AbstractModule ( ) { @ Override protected void configure ( ) { bind ( URI [ ] . class ) . annotatedWith ( Names . named ( "" Initial Nodes "" ) ) . toInstance ( initialNodes ) ; } } ) ; modules . add ( new ModelFactoryModule ( ) ) ; injector = Guice . createInjector ( modules ) ; // start the services that need starting final ApiClient api = injector . getInstance ( ApiClient . class ) ; api . start ( ) ; injector . getInstance ( ServerNodesRefreshService . class ) . start ( ) ; // TODO replace with custom AuthenticatedAction filter RedirectAuthenticator . userService = injector . getInstance ( UserService . class ) ; // temporarily disabled for preview to prevent confusion. //        LocalAdminUserRealm localAdminRealm = new LocalAdminUserRealm(""local-accounts""); //        localAdminRealm.setCredentialsMatcher(new HashedCredentialsMatcher(""SHA2"")); //        setupLocalUser(api, localAdminRealm, app); Realm serverRestInterfaceRealm = injector . getInstance ( ServerRestInterfaceRealm . class ) ; final DefaultSecurityManager securityManager = new DefaultSecurityManager ( Lists . newArrayList ( serverRestInterfaceRealm ) ) ; final Authenticator authenticator = securityManager . getAuthenticator ( ) ; if ( authenticator instanceof ModularRealmAuthenticator ) { ModularRealmAuthenticator a = ( ModularRealmAuthenticator ) authenticator ; a . setAuthenticationStrategy ( new RethrowingFirstSuccessfulStrategy ( ) ) ; a . setAuthenticationListeners ( Lists . < AuthenticationListener > newArrayList ( new PlayAuthenticationListener ( ) ) ) ; } SecurityUtils . setSecurityManager ( securityManager ) ; }",2013-09-30 13:14:07 +0200,2013-10-22 16:39:20 +0200,5,Exclamatory
2587,310,https://www.github.com/qcadoo/mes,"loadData(String, String)",,107,107,107,107,TODO BAKU add company,https://www.github.com/qcadoo/mes/commit/88d8931bf67,https://www.github.com/qcadoo/mes/commit/5b09bdaff039355bd3f4a74de22b71159a3de0e9,mes-plugins/mes-plugins-samples/src/main/java/com/qcadoo/mes/samples/GeneratedSamplesLoader.java,"@Override
void loadData(final String dataset, final String locale) {
// TODO BAKU add company
generateAndAddUser();
generateAndAddDictionary();
addParameters(singletonMap(""code"", ""PLN""));
for (int i = 0; i < iterations; i++) {
generateAndAddProduct();
generateAndAddWorkstationType();
generateAndAddContractor();
generateAndAddStaff();
}
for (int i = 0; i < 10; i++) {
generateAndAddShift();
}
if (isEnabled(TECHNOLOGY_PLUGIN_NAME)) {
for (int i = 0; i < iterations; i++) {
generateAndAddOperation();
}
generateAndAddTechnologies();
}
if (isEnabled(ORDERS_PLUGIN_IDENTIFIER)) {
for (int i = 0; i < iterations; i++) {
generateAndAddOrder();
}
if (isEnabled(ORDER_GROUPS_PLUGIN_NAME)) {
for (int i = 0; i < 10; i++) {
generateAndAddOrderGroup();
}
}
}
if (isEnabled(""workPlans"")) {
for (int i = 0; i < (iterations / 40); i++) {
generateAndAddWorkPlan();
}
}
}","@Override
void loadData(final String dataset, final String locale) {
generateAndAddUser();
generateAndAddDictionary();
addParameters(singletonMap(""code"", ""PLN""));
generateAndAddCompany();
for (int i = 0; i < iterations; i++) {
generateAndAddProduct();
generateAndAddWorkstationType();
generateAndAddStaff();
}
for (int i = 0; i < 10; i++) {
generateAndAddShift();
}
if (isEnabled(TECHNOLOGY_PLUGIN_NAME)) {
for (int i = 0; i < iterations; i++) {
generateAndAddOperation();
}
generateAndAddTechnologies();
}
if (isEnabled(ORDERS_PLUGIN_IDENTIFIER)) {
for (int i = 0; i < iterations; i++) {
generateAndAddOrder();
}
if (isEnabled(ORDER_GROUPS_PLUGIN_NAME)) {
for (int i = 0; i < 10; i++) {
generateAndAddOrderGroup();
}
}
}
if (isEnabled(""workPlans"")) {
for (int i = 0; i < (iterations / 40); i++) {
generateAndAddWorkPlan();
}
}
}","@ Override void loadData  ( final String dataset , final String locale ) { // <SATD_START> TODO BAKU add company <SATD_END> generateAndAddUser ( ) ; generateAndAddDictionary ( ) ; addParameters ( singletonMap ( "" code "" , "" PLN "" ) ) ; for ( int i = 0 ; i < iterations ; i ++ ) { generateAndAddProduct ( ) ; generateAndAddWorkstationType ( ) ; generateAndAddContractor ( ) ; generateAndAddStaff ( ) ; } for ( int i = 0 ; i < 10 ; i ++ ) { generateAndAddShift ( ) ; } if ( isEnabled ( TECHNOLOGY_PLUGIN_NAME ) ) { for ( int i = 0 ; i < iterations ; i ++ ) { generateAndAddOperation ( ) ; } generateAndAddTechnologies ( ) ; } if ( isEnabled ( ORDERS_PLUGIN_IDENTIFIER ) ) { for ( int i = 0 ; i < iterations ; i ++ ) { generateAndAddOrder ( ) ; } if ( isEnabled ( ORDER_GROUPS_PLUGIN_NAME ) ) { for ( int i = 0 ; i < 10 ; i ++ ) { generateAndAddOrderGroup ( ) ; } } } if ( isEnabled ( "" workPlans "" ) ) { for ( int i = 0 ; i < ( iterations / 40 ) ; i ++ ) { generateAndAddWorkPlan ( ) ; } } }","@ Override void loadData  ( final String dataset , final String locale ) { generateAndAddUser ( ) ; generateAndAddDictionary ( ) ; addParameters ( singletonMap ( "" code "" , "" PLN "" ) ) ; generateAndAddCompany ( ) ; for ( int i = 0 ; i < iterations ; i ++ ) { generateAndAddProduct ( ) ; generateAndAddWorkstationType ( ) ; generateAndAddStaff ( ) ; } for ( int i = 0 ; i < 10 ; i ++ ) { generateAndAddShift ( ) ; } if ( isEnabled ( TECHNOLOGY_PLUGIN_NAME ) ) { for ( int i = 0 ; i < iterations ; i ++ ) { generateAndAddOperation ( ) ; } generateAndAddTechnologies ( ) ; } if ( isEnabled ( ORDERS_PLUGIN_IDENTIFIER ) ) { for ( int i = 0 ; i < iterations ; i ++ ) { generateAndAddOrder ( ) ; } if ( isEnabled ( ORDER_GROUPS_PLUGIN_NAME ) ) { for ( int i = 0 ; i < 10 ; i ++ ) { generateAndAddOrderGroup ( ) ; } } } if ( isEnabled ( "" workPlans "" ) ) { for ( int i = 0 ; i < ( iterations / 40 ) ; i ++ ) { generateAndAddWorkPlan ( ) ; } } }",2011-12-07 11:18:50 +0100,2012-02-09 13:47:39 +0100,2,Other
332,26,https://www.github.com/aosp-mirror/platform_packages_apps_email,actionReschedule(Context),,148,148,57,57,TODO this needs to be passed through the controller and back to us,https://www.github.com/aosp-mirror/platform_packages_apps_email/commit/03cd72805d,https://www.github.com/aosp-mirror/platform_packages_apps_email/commit/f419287f22ae44f25e1ba1f757ec33c7941bbfa8,src/com/android/email/service/MailService.java,"@Override
public int onStartCommand(final Intent intent, int flags, final int startId) {
super.onStartCommand(intent, flags, startId);
EmailAsyncTask.runAsyncParallel(new Runnable() {
            @Override
public void run() {
reconcilePopImapAccountsSync(MailService.this);
}
        });
// TODO this needs to be passed through the controller and back to us
mStartId = startId;
String action = intent.getAction();
final long accountId = intent.getLongExtra(EXTRA_ACCOUNT, -1);
mController = Controller.getInstance(this);
mController.addResultCallback(mControllerCallback);
mContentResolver = getContentResolver();
mContext = this;
final AlarmManager alarmManager = (AlarmManager) getSystemService(Context.ALARM_SERVICE);
if (ACTION_CHECK_MAIL.equals(action)) {
// DB access required to satisfy this intent, so offload from UI thread
EmailAsyncTask.runAsyncParallel(new Runnable() {
                @Override
public void run() {
// If we have the data, restore the last-sync-times for each account
// These are cached in the wakeup intent in case the process was killed.
restoreSyncReports(intent);
// Sync a specific account if given
if (Email.DEBUG) {
Log.d(LOG_TAG, ""action: check mail for id="" + accountId);
}
if (accountId >= 0) {
setWatchdog(accountId, alarmManager);
}
// Start sync if account is given && auto-sync is allowed
boolean syncStarted = false;
if (accountId != -1 && ContentResolver.getMasterSyncAutomatically()) {
synchronized(mSyncReports) {
for (AccountSyncReport report: mSyncReports.values()) {
if (report.accountId == accountId) {
if (report.syncEnabled) {
syncStarted = syncOneAccount(mController, accountId,
                                                startId);
}
break;
}
}
}
}
// Reschedule if we didn't start sync.
if (!syncStarted) {
// Prevent runaway on the current account by pretending it updated
if (accountId != -1) {
updateAccountReport(accountId, 0);
}
// Find next account to sync, and reschedule
reschedule(alarmManager);
// Stop the service, unless actually syncing (which will stop the service)
stopSelf(startId);
}
}
            });
}
else if (ACTION_CANCEL.equals(action)) {
if (Email.DEBUG) {
Log.d(LOG_TAG, ""action: cancel"");
}
cancel();
stopSelf(startId);
}
else if (ACTION_DELETE_EXCHANGE_ACCOUNTS.equals(action)) {
if (Email.DEBUG) {
Log.d(LOG_TAG, ""action: delete exchange accounts"");
}
EmailAsyncTask.runAsyncParallel(new Runnable() {
                @Override
public void run() {
Cursor c = mContentResolver.query(Account.CONTENT_URI, Account.ID_PROJECTION,
                            null, null, null);
try {
while (c.moveToNext()) {
long accountId = c.getLong(Account.ID_PROJECTION_COLUMN);
if (""eas"".equals(Account.getProtocol(mContext, accountId))) {
// Always log this
Log.d(LOG_TAG, ""Deleting EAS account: "" + accountId);
mController.deleteAccountSync(accountId, mContext);
}
}
} finally {
c.close();
}
}
            });
stopSelf(startId);
}
else if (ACTION_SEND_PENDING_MAIL.equals(action)) {
if (Email.DEBUG) {
Log.d(LOG_TAG, ""action: send pending mail"");
}
EmailAsyncTask.runAsyncParallel(new Runnable() {
                @Override
public void run() {
mController.sendPendingMessages(accountId);
}
            });
stopSelf(startId);
}
else if (ACTION_RESCHEDULE.equals(action)) {
if (Email.DEBUG) {
Log.d(LOG_TAG, ""action: reschedule"");
}
// DB access required to satisfy this intent, so offload from UI thread
EmailAsyncTask.runAsyncParallel(new Runnable() {
                @Override
public void run() {
// When called externally, we refresh the sync reports table to pick up
// any changes in the account list or account settings
refreshSyncReports();
// Finally, scan for the next needing update, and set an alarm for it
reschedule(alarmManager);
stopSelf(startId);
}
            });
}
// Returning START_NOT_STICKY means that if a mail check is killed (e.g. due to memory
// pressure, there will be no explicit restart.  This is OK;  Note that we set a watchdog
// alarm before each mailbox check.  If the mailbox check never completes, the watchdog
// will fire and get things running again.
return START_NOT_STICKY;
}","@Override
public int onStartCommand(final Intent intent, int flags, final int startId) {
super.onStartCommand(intent, flags, startId);
EmailAsyncTask.runAsyncParallel(new Runnable() {
            @Override
public void run() {
reconcilePopImapAccountsSync(MailService.this);
}
        });
// Make sure our services are running, if necessary
MailActivityEmail.setServicesEnabledAsync(this);
// Returning START_NOT_STICKY means that if a mail check is killed (e.g. due to memory
// pressure, there will be no explicit restart.  This is OK;  Note that we set a watchdog
// alarm before each mailbox check.  If the mailbox check never completes, the watchdog
// will fire and get things running again.
return START_NOT_STICKY;
}","@ Override public int onStartCommand  ( final Intent intent , int flags , final int startId ) { super . onStartCommand ( intent , flags , startId ) ; EmailAsyncTask . runAsyncParallel ( new Runnable ( ) { @ Override public void run ( ) { reconcilePopImapAccountsSync ( MailService . this ) ; } } ) ; // <SATD_START> TODO this needs to be passed through the controller and back to us <SATD_END> mStartId = startId ; String action = intent . getAction ( ) ; final long accountId = intent . getLongExtra ( EXTRA_ACCOUNT , - 1 ) ; mController = Controller . getInstance ( this ) ; mController . addResultCallback ( mControllerCallback ) ; mContentResolver = getContentResolver ( ) ; mContext = this ; final AlarmManager alarmManager = ( AlarmManager ) getSystemService ( Context . ALARM_SERVICE ) ; if ( ACTION_CHECK_MAIL . equals ( action ) ) { // DB access required to satisfy this intent, so offload from UI thread EmailAsyncTask . runAsyncParallel ( new Runnable ( ) { @ Override public void run ( ) { // If we have the data, restore the last-sync-times for each account // These are cached in the wakeup intent in case the process was killed. restoreSyncReports ( intent ) ; // Sync a specific account if given if ( Email . DEBUG ) { Log . d ( LOG_TAG , "" action: check mail for id= "" + accountId ) ; } if ( accountId >= 0 ) { setWatchdog ( accountId , alarmManager ) ; } // Start sync if account is given && auto-sync is allowed boolean syncStarted = false ; if ( accountId != - 1 && ContentResolver . getMasterSyncAutomatically ( ) ) { synchronized ( mSyncReports ) { for ( AccountSyncReport report : mSyncReports . values ( ) ) { if ( report . accountId == accountId ) { if ( report . syncEnabled ) { syncStarted = syncOneAccount ( mController , accountId , startId ) ; } break ; } } } } // Reschedule if we didn't start sync. if ( ! syncStarted ) { // Prevent runaway on the current account by pretending it updated if ( accountId != - 1 ) { updateAccountReport ( accountId , 0 ) ; } // Find next account to sync, and reschedule reschedule ( alarmManager ) ; // Stop the service, unless actually syncing (which will stop the service) stopSelf ( startId ) ; } } } ) ; } else if ( ACTION_CANCEL . equals ( action ) ) { if ( Email . DEBUG ) { Log . d ( LOG_TAG , "" action: cancel "" ) ; } cancel ( ) ; stopSelf ( startId ) ; } else if ( ACTION_DELETE_EXCHANGE_ACCOUNTS . equals ( action ) ) { if ( Email . DEBUG ) { Log . d ( LOG_TAG , "" action: delete exchange accounts "" ) ; } EmailAsyncTask . runAsyncParallel ( new Runnable ( ) { @ Override public void run ( ) { Cursor c = mContentResolver . query ( Account . CONTENT_URI , Account . ID_PROJECTION , null , null , null ) ; try { while ( c . moveToNext ( ) ) { long accountId = c . getLong ( Account . ID_PROJECTION_COLUMN ) ; if ( "" eas "" . equals ( Account . getProtocol ( mContext , accountId ) ) ) { // Always log this Log . d ( LOG_TAG , "" Deleting EAS account:  "" + accountId ) ; mController . deleteAccountSync ( accountId , mContext ) ; } } } finally { c . close ( ) ; } } } ) ; stopSelf ( startId ) ; } else if ( ACTION_SEND_PENDING_MAIL . equals ( action ) ) { if ( Email . DEBUG ) { Log . d ( LOG_TAG , "" action: send pending mail "" ) ; } EmailAsyncTask . runAsyncParallel ( new Runnable ( ) { @ Override public void run ( ) { mController . sendPendingMessages ( accountId ) ; } } ) ; stopSelf ( startId ) ; } else if ( ACTION_RESCHEDULE . equals ( action ) ) { if ( Email . DEBUG ) { Log . d ( LOG_TAG , "" action: reschedule "" ) ; } // DB access required to satisfy this intent, so offload from UI thread EmailAsyncTask . runAsyncParallel ( new Runnable ( ) { @ Override public void run ( ) { // When called externally, we refresh the sync reports table to pick up // any changes in the account list or account settings refreshSyncReports ( ) ; // Finally, scan for the next needing update, and set an alarm for it reschedule ( alarmManager ) ; stopSelf ( startId ) ; } } ) ; } // Returning START_NOT_STICKY means that if a mail check is killed (e.g. due to memory // pressure, there will be no explicit restart.  This is OK;  Note that we set a watchdog // alarm before each mailbox check.  If the mailbox check never completes, the watchdog // will fire and get things running again. return START_NOT_STICKY ; }","@ Override public int onStartCommand  ( final Intent intent , int flags , final int startId ) { super . onStartCommand ( intent , flags , startId ) ; EmailAsyncTask . runAsyncParallel ( new Runnable ( ) { @ Override public void run ( ) { reconcilePopImapAccountsSync ( MailService . this ) ; } } ) ; // Make sure our services are running, if necessary MailActivityEmail . setServicesEnabledAsync ( this ) ; // Returning START_NOT_STICKY means that if a mail check is killed (e.g. due to memory // pressure, there will be no explicit restart.  This is OK;  Note that we set a watchdog // alarm before each mailbox check.  If the mailbox check never completes, the watchdog // will fire and get things running again. return START_NOT_STICKY ; }",2012/4/25 13:58,2012/6/28 11:15,3,Exclamatory
1760,121,https://www.github.com/erlang/erlide_eclipse,createContent(Composite),,250,250,250,250,XXX: Just hide? Would avoid constant recreations.,https://www.github.com/erlang/erlide_eclipse/commit/c9e0e6ecb3,https://www.github.com/erlang/erlide_eclipse/commit/1fb468ecfe6ff592d3e8b211455493ca8b47b136,org.erlide.ui/src/org/erlide/ui/util/eclipse/text/BrowserInformationControl.java,"@Override
protected void createContent(final Composite parent) {
fBrowser = new Browser(parent, SWT.NONE);
final Display display = getShell().getDisplay();
fBrowser.setForeground(display
.getSystemColor(SWT.COLOR_INFO_FOREGROUND));
fBrowser.setBackground(display
.getSystemColor(SWT.COLOR_INFO_BACKGROUND));
fBrowser.addKeyListener(new KeyListener() {

            @Override
public void keyPressed(final KeyEvent e) {
if (e.character == 0x1B) {
dispose();
// XXX: Just hide? Would avoid constant recreations.
}
}
@Override
public void keyReleased(final KeyEvent e) {
}
        });
fBrowser.addProgressListener(new ProgressAdapter() {
            @Override
public void completed(final ProgressEvent event) {
fCompleted = true;
}
        });
// Replace browser's built-in context menu with none
fBrowser.setMenu(new Menu(getShell(), SWT.NONE));
createTextLayout();
}","@Override
protected void createContent(final Composite parent) {
fBrowser = new Browser(parent, SWT.NONE);
fBrowser.setJavascriptEnabled(false);
final Display display = getShell().getDisplay();
fBrowser.setForeground(display
.getSystemColor(SWT.COLOR_INFO_FOREGROUND));
fBrowser.setBackground(display
.getSystemColor(SWT.COLOR_INFO_BACKGROUND));
fBrowser.addProgressListener(new ProgressAdapter() {
            @Override
public void completed(final ProgressEvent event) {
fCompleted = true;
}
        });
fBrowser.addOpenWindowListener(new OpenWindowListener() {
            @Override
public void open(final WindowEvent event) {
event.required = true; // Cancel opening of new windows
}
        });
// Replace browser's built-in context menu with none
fBrowser.setMenu(new Menu(getShell(), SWT.NONE));
createTextLayout();
}","@ Override protected void createContent  ( final Composite parent ) { fBrowser = new Browser ( parent , SWT . NONE ) ; final Display display = getShell ( ) . getDisplay ( ) ; fBrowser . setForeground ( display . getSystemColor ( SWT . COLOR_INFO_FOREGROUND ) ) ; fBrowser . setBackground ( display . getSystemColor ( SWT . COLOR_INFO_BACKGROUND ) ) ; fBrowser . addKeyListener ( new KeyListener ( ) { @ Override public void keyPressed ( final KeyEvent e ) { if ( e . character == 0x1B ) { dispose ( ) ; // <SATD_START> XXX: Just hide? Would avoid constant recreations. <SATD_END> } } @ Override public void keyReleased ( final KeyEvent e ) { } } ) ; fBrowser . addProgressListener ( new ProgressAdapter ( ) { @ Override public void completed ( final ProgressEvent event ) { fCompleted = true ; } } ) ; // Replace browser's built-in context menu with none fBrowser . setMenu ( new Menu ( getShell ( ) , SWT . NONE ) ) ; createTextLayout ( ) ; }","@ Override protected void createContent  ( final Composite parent ) { fBrowser = new Browser ( parent , SWT . NONE ) ; fBrowser . setJavascriptEnabled ( false ) ; final Display display = getShell ( ) . getDisplay ( ) ; fBrowser . setForeground ( display . getSystemColor ( SWT . COLOR_INFO_FOREGROUND ) ) ; fBrowser . setBackground ( display . getSystemColor ( SWT . COLOR_INFO_BACKGROUND ) ) ; fBrowser . addProgressListener ( new ProgressAdapter ( ) { @ Override public void completed ( final ProgressEvent event ) { fCompleted = true ; } } ) ; fBrowser . addOpenWindowListener ( new OpenWindowListener ( ) { @ Override public void open ( final WindowEvent event ) { event . required = true ; // Cancel opening of new windows } } ) ; // Replace browser's built-in context menu with none fBrowser . setMenu ( new Menu ( getShell ( ) , SWT . NONE ) ) ; createTextLayout ( ) ; }",2011-09-06 09:32:54 +0200,2013-06-20 09:53:19 +0200,29,Other
866,427,https://www.github.com/jbossas/console,asWidget(),DESIGN,60,60,60,60,todo: turn into pull down. But how is the the socket-binding group resolved?,https://www.github.com/jbossas/console/commit/c602dd4c0,https://www.github.com/jbossas/console/commit/dd97b0f6e4e54483accfde33f79b720310aa2529,gui/src/main/java/org/jboss/as/console/client/shared/subsys/web/NewConnectorWizard.java,"Widget asWidget() {
VerticalPanel layout = new VerticalPanel();
layout.setStyleName(""fill-layout-width"");
final Form<HttpConnector> form = new Form<HttpConnector>(HttpConnector.class);
TextBoxItem name = new TextBoxItem(""name"", ""Name"");
// todo: turn into pull down. But how is the the socket-binding group resolved?
TextBoxItem socket = new TextBoxItem(""socketBinding"", ""Socket Binding"") {

            private String errOrig;
@Override
public boolean validate(String value) {
boolean parentValid = super.validate(value);
boolean bindingValid = true;
if(parentValid)
{
for(HttpConnector existing : connectors)
{
if(existing.getSocketBinding().equals(value))
{
errOrig = getErrMessage();
setErrMessage(""Socket binding already in use"");
bindingValid = false;
}
}
}
return parentValid && bindingValid;
}
        };
ComboBoxItem protocol = new ComboBoxItem(""protocol"", ""Protocol"");
ComboBoxItem scheme = new ComboBoxItem(""scheme"", ""Scheme"");
protocol.setDefaultToFirstOption(true);
protocol.setValueMap(new String[]{""HTTP/1.1"", ""AJP/1.3""});
scheme.setDefaultToFirstOption(true);
scheme.setValueMap(new String[]{""http"", ""https""});
CheckBoxItem enabled = new CheckBoxItem(""enabled"", ""Enabled?"");
enabled.setValue(Boolean.TRUE);
form.setFields(name,socket,protocol,scheme, enabled);
final FormHelpPanel helpPanel = new FormHelpPanel(
                new FormHelpPanel.AddressCallback() {
                    @Override
public ModelNode getAddress() {
ModelNode address = Baseadress.get();
address.add(""subsystem"", ""web"");
address.add(""connector"", ""*"");
return address;
}
                }, form
        );
layout.add(helpPanel.asWidget());
layout.add(form.asWidget());
DialogueOptions options = new DialogueOptions(
                new ClickHandler() {

                    @Override
public void onClick(ClickEvent event) {
FormValidation validation = form.validate();
if(!validation.hasErrors())
presenter.onCreateConnector(form.getUpdatedEntity());
}
                },
                new ClickHandler() {

                    @Override
public void onClick(ClickEvent event) {
presenter.closeDialogue();
}
                }
        );
layout.add(options);
return new WindowContentBuilder(layout, options).build();
}","Widget asWidget() {
VerticalPanel layout = new VerticalPanel();
layout.setStyleName(""fill-layout-width"");
final Form<HttpConnector> form = new Form<HttpConnector>(HttpConnector.class);
TextBoxItem name = new TextBoxItem(""name"", ""Name"");
ComboBoxItem socket = new ComboBoxItem(""socketBinding"", ""Socket Binding"") {

            private String errOrig;
@Override
public boolean validate(String value) {
boolean parentValid = super.validate(value);
boolean bindingValid = true;
if(parentValid)
{
for(HttpConnector existing : connectors)
{
if(existing.getSocketBinding().equals(value))
{
errOrig = getErrMessage();
setErrMessage(""Socket binding already in use"");
bindingValid = false;
}
}
}
return parentValid && bindingValid;
}
        };
socket.setValueMap(socketBindings);
ComboBoxItem protocol = new ComboBoxItem(""protocol"", ""Protocol"");
ComboBoxItem scheme = new ComboBoxItem(""scheme"", ""Scheme"");
protocol.setDefaultToFirstOption(true);
protocol.setValueMap(new String[]{""HTTP/1.1"", ""AJP/1.3""});
scheme.setDefaultToFirstOption(true);
scheme.setValueMap(new String[]{""http"", ""https""});
CheckBoxItem enabled = new CheckBoxItem(""enabled"", ""Enabled?"");
enabled.setValue(Boolean.TRUE);
form.setFields(name,socket,protocol,scheme, enabled);
final FormHelpPanel helpPanel = new FormHelpPanel(
                new FormHelpPanel.AddressCallback() {
                    @Override
public ModelNode getAddress() {
ModelNode address = Baseadress.get();
address.add(""subsystem"", ""web"");
address.add(""connector"", ""*"");
return address;
}
                }, form
        );
layout.add(helpPanel.asWidget());
layout.add(form.asWidget());
DialogueOptions options = new DialogueOptions(
                new ClickHandler() {

                    @Override
public void onClick(ClickEvent event) {
FormValidation validation = form.validate();
if(!validation.hasErrors())
presenter.onCreateConnector(form.getUpdatedEntity());
}
                },
                new ClickHandler() {

                    @Override
public void onClick(ClickEvent event) {
presenter.closeDialogue();
}
                }
        );
layout.add(options);
return new WindowContentBuilder(layout, options).build();
}","Widget asWidget  ( ) { VerticalPanel layout = new VerticalPanel ( ) ; layout . setStyleName ( "" fill-layout-width "" ) ; final Form < HttpConnector > form = new Form < HttpConnector > ( HttpConnector . class ) ; TextBoxItem name = new TextBoxItem ( "" name "" , "" Name "" ) ; // <SATD_START> todo: turn into pull down. But how is the the socket-binding group resolved? <SATD_END> TextBoxItem socket = new TextBoxItem ( "" socketBinding "" , "" Socket Binding "" ) { private String errOrig ; @ Override public boolean validate ( String value ) { boolean parentValid = super . validate ( value ) ; boolean bindingValid = true ; if ( parentValid ) { for ( HttpConnector existing : connectors ) { if ( existing . getSocketBinding ( ) . equals ( value ) ) { errOrig = getErrMessage ( ) ; setErrMessage ( "" Socket binding already in use "" ) ; bindingValid = false ; } } } return parentValid && bindingValid ; } } ; ComboBoxItem protocol = new ComboBoxItem ( "" protocol "" , "" Protocol "" ) ; ComboBoxItem scheme = new ComboBoxItem ( "" scheme "" , "" Scheme "" ) ; protocol . setDefaultToFirstOption ( true ) ; protocol . setValueMap ( new String [ ] { "" HTTP/1.1 "" , "" AJP/1.3 "" } ) ; scheme . setDefaultToFirstOption ( true ) ; scheme . setValueMap ( new String [ ] { "" http "" , "" https "" } ) ; CheckBoxItem enabled = new CheckBoxItem ( "" enabled "" , "" Enabled? "" ) ; enabled . setValue ( Boolean . TRUE ) ; form . setFields ( name , socket , protocol , scheme , enabled ) ; final FormHelpPanel helpPanel = new FormHelpPanel ( new FormHelpPanel . AddressCallback ( ) { @ Override public ModelNode getAddress ( ) { ModelNode address = Baseadress . get ( ) ; address . add ( "" subsystem "" , "" web "" ) ; address . add ( "" connector "" , "" * "" ) ; return address ; } } , form ) ; layout . add ( helpPanel . asWidget ( ) ) ; layout . add ( form . asWidget ( ) ) ; DialogueOptions options = new DialogueOptions ( new ClickHandler ( ) { @ Override public void onClick ( ClickEvent event ) { FormValidation validation = form . validate ( ) ; if ( ! validation . hasErrors ( ) ) presenter . onCreateConnector ( form . getUpdatedEntity ( ) ) ; } } , new ClickHandler ( ) { @ Override public void onClick ( ClickEvent event ) { presenter . closeDialogue ( ) ; } } ) ; layout . add ( options ) ; return new WindowContentBuilder ( layout , options ) . build ( ) ; }","Widget asWidget  ( ) { VerticalPanel layout = new VerticalPanel ( ) ; layout . setStyleName ( "" fill-layout-width "" ) ; final Form < HttpConnector > form = new Form < HttpConnector > ( HttpConnector . class ) ; TextBoxItem name = new TextBoxItem ( "" name "" , "" Name "" ) ; ComboBoxItem socket = new ComboBoxItem ( "" socketBinding "" , "" Socket Binding "" ) { private String errOrig ; @ Override public boolean validate ( String value ) { boolean parentValid = super . validate ( value ) ; boolean bindingValid = true ; if ( parentValid ) { for ( HttpConnector existing : connectors ) { if ( existing . getSocketBinding ( ) . equals ( value ) ) { errOrig = getErrMessage ( ) ; setErrMessage ( "" Socket binding already in use "" ) ; bindingValid = false ; } } } return parentValid && bindingValid ; } } ; socket . setValueMap ( socketBindings ) ; ComboBoxItem protocol = new ComboBoxItem ( "" protocol "" , "" Protocol "" ) ; ComboBoxItem scheme = new ComboBoxItem ( "" scheme "" , "" Scheme "" ) ; protocol . setDefaultToFirstOption ( true ) ; protocol . setValueMap ( new String [ ] { "" HTTP/1.1 "" , "" AJP/1.3 "" } ) ; scheme . setDefaultToFirstOption ( true ) ; scheme . setValueMap ( new String [ ] { "" http "" , "" https "" } ) ; CheckBoxItem enabled = new CheckBoxItem ( "" enabled "" , "" Enabled? "" ) ; enabled . setValue ( Boolean . TRUE ) ; form . setFields ( name , socket , protocol , scheme , enabled ) ; final FormHelpPanel helpPanel = new FormHelpPanel ( new FormHelpPanel . AddressCallback ( ) { @ Override public ModelNode getAddress ( ) { ModelNode address = Baseadress . get ( ) ; address . add ( "" subsystem "" , "" web "" ) ; address . add ( "" connector "" , "" * "" ) ; return address ; } } , form ) ; layout . add ( helpPanel . asWidget ( ) ) ; layout . add ( form . asWidget ( ) ) ; DialogueOptions options = new DialogueOptions ( new ClickHandler ( ) { @ Override public void onClick ( ClickEvent event ) { FormValidation validation = form . validate ( ) ; if ( ! validation . hasErrors ( ) ) presenter . onCreateConnector ( form . getUpdatedEntity ( ) ) ; } } , new ClickHandler ( ) { @ Override public void onClick ( ClickEvent event ) { presenter . closeDialogue ( ) ; } } ) ; layout . add ( options ) ; return new WindowContentBuilder ( layout , options ) . build ( ) ; }",2011-05-12 18:17:01 +0200,2012-03-28 11:19:25 +0200,17,Exclamatory
2790,13,https://www.github.com/aosp-mirror/platform_packages_apps_settings,onActivityCreated(Bundle),,110,110,110,110,TODO: load channels in asynctask?,https://www.github.com/aosp-mirror/platform_packages_apps_settings/commit/5d1506a2af2d,https://www.github.com/aosp-mirror/platform_packages_apps_settings/commit/6f57f2c2af1f7d31ae5fa2cad3780bf3fa490aa2,src/com/android/settings/notification/AppNotificationSettings.java,"@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
if (mUid < 0 || TextUtils.isEmpty(mPkg) || mPkgInfo == null) {
Log.w(TAG, ""Missing package or uid or packageinfo"");
toastAndFinish();
return;
}
final Activity activity = getActivity();
mDashboardFeatureProvider =
FeatureFactory.getFactory(activity).getDashboardFeatureProvider(activity);
addPreferencesFromResource(R.xml.app_notification_settings);
getPreferenceScreen().setOrderingAsAdded(true);
mBlock = (RestrictedSwitchPreference) getPreferenceScreen().findPreference(KEY_BLOCK);
mBadge = (RestrictedSwitchPreference) getPreferenceScreen().findPreference(KEY_BADGE);
mChannels = (PreferenceCategory) findPreference(KEY_CHANNELS);
if (mPkgInfo != null) {
setupBlock();
setupBadge();
// load settings intent
ArrayMap<String, AppRow> rows = new ArrayMap<String, AppRow>();
rows.put(mAppRow.pkg, mAppRow);
collectConfigActivities(rows);
// TODO: load channels in asynctask?
mChannelGroupList = mBackend.getChannelGroups(mPkg, mUid).getList();
Collections.sort(mChannelGroupList, mChannelGroupComparator);
if (mChannelGroupList.isEmpty()) {
Preference empty = new Preference(getPrefContext());
empty.setTitle(R.string.no_channels);
empty.setEnabled(false);
mChannels.addPreference(empty);
} else {
for (NotificationChannelGroup group : mChannelGroupList) {
PreferenceCategory groupCategory = null;
if (group.getId() != null && group.getName() != null) {
groupCategory = new PreferenceCategory(getPrefContext());
groupCategory.setTitle(group.getName());
groupCategory.setKey(group.getId());
groupCategory.setOrderingAsAdded(true);
getPreferenceScreen().addPreference(groupCategory);
}
final List<NotificationChannel> channels = group.getChannels();
Collections.sort(channels, mChannelComparator);
int N = channels.size();
for (int i = 0; i < N; i++) {
final NotificationChannel channel = channels.get(i);
RestrictedPreference channelPref = new RestrictedPreference(
                                getPrefContext());
channelPref.setDisabledByAdmin(mSuspendedAppsAdmin);
channelPref.setKey(channel.getId());
channelPref.setTitle(channel.getName());
if (channel.isDeleted()) {
channelPref.setTitle(
                                    getString(R.string.deleted_channel_name, channel.getName()));
channelPref.setEnabled(false);
} else {
Bundle channelArgs = new Bundle();
channelArgs.putInt(AppInfoBase.ARG_PACKAGE_UID, mUid);
channelArgs.putBoolean(AppHeader.EXTRA_HIDE_INFO_BUTTON, true);
channelArgs.putString(AppInfoBase.ARG_PACKAGE_NAME, mPkg);
channelArgs.putString(Settings.EXTRA_CHANNEL_ID, channel.getId());
Intent channelIntent = Utils.onBuildStartFragmentIntent(getActivity(),
                                    ChannelNotificationSettings.class.getName(),
                                    channelArgs, null, 0, null, false);
channelPref.setIntent(channelIntent);
}
if (groupCategory != null) {
groupCategory.addPreference(channelPref);
} else {
mChannels.addPreference(channelPref);
}
}
}
}
updateDependents(mAppRow.banned);
}
if (mDashboardFeatureProvider.isEnabled()) {
final Preference pref = FeatureFactory.getFactory(activity)
.getApplicationFeatureProvider(activity)
.newAppHeaderController(this /* fragment */, null /* appHeader */)
.setIcon(mAppRow.icon)
.setLabel(mAppRow.label)
.setPackageName(mAppRow.pkg)
.setUid(mAppRow.uid)
.setAppNotifPrefIntent(mAppRow.settingsIntent)
.setButtonActions(AppHeaderController.ActionType.ACTION_APP_INFO,
                            AppHeaderController.ActionType.ACTION_NOTIF_PREFERENCE)
.done(getPrefContext());
getPreferenceScreen().addPreference(pref);
}
}","@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
if (mUid < 0 || TextUtils.isEmpty(mPkg) || mPkgInfo == null) {
Log.w(TAG, ""Missing package or uid or packageinfo"");
toastAndFinish();
return;
}
final Activity activity = getActivity();
mDashboardFeatureProvider =
FeatureFactory.getFactory(activity).getDashboardFeatureProvider(activity);
addPreferencesFromResource(R.xml.app_notification_settings);
getPreferenceScreen().setOrderingAsAdded(true);
mBlock = (RestrictedSwitchPreference) getPreferenceScreen().findPreference(KEY_BLOCK);
mBadge = (RestrictedSwitchPreference) getPreferenceScreen().findPreference(KEY_BADGE);
if (mPkgInfo != null) {
setupBlock();
setupBadge();
// load settings intent
ArrayMap<String, AppRow> rows = new ArrayMap<String, AppRow>();
rows.put(mAppRow.pkg, mAppRow);
collectConfigActivities(rows);
new AsyncTask<Void, Void, Void>() {
                @Override
protected Void doInBackground(Void... unused) {
mChannelGroupList = mBackend.getChannelGroups(mPkg, mUid).getList();
Collections.sort(mChannelGroupList, mChannelGroupComparator);
return null;
}
@Override
protected void onPostExecute(Void unused) {
populateChannelList();
}
            }.execute();
}
if (mDashboardFeatureProvider.isEnabled()) {
final Preference pref = FeatureFactory.getFactory(activity)
.getApplicationFeatureProvider(activity)
.newAppHeaderController(this /* fragment */, null /* appHeader */)
.setIcon(mAppRow.icon)
.setLabel(mAppRow.label)
.setPackageName(mAppRow.pkg)
.setUid(mAppRow.uid)
.setAppNotifPrefIntent(mAppRow.settingsIntent)
.setButtonActions(AppHeaderController.ActionType.ACTION_APP_INFO,
                            AppHeaderController.ActionType.ACTION_NOTIF_PREFERENCE)
.done(getPrefContext());
getPreferenceScreen().addPreference(pref);
}
}","@ Override public void onCreate  ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; if ( mUid < 0 || TextUtils . isEmpty ( mPkg ) || mPkgInfo == null ) { Log . w ( TAG , "" Missing package or uid or packageinfo "" ) ; toastAndFinish ( ) ; return ; } final Activity activity = getActivity ( ) ; mDashboardFeatureProvider = FeatureFactory . getFactory ( activity ) . getDashboardFeatureProvider ( activity ) ; addPreferencesFromResource ( R . xml . app_notification_settings ) ; getPreferenceScreen ( ) . setOrderingAsAdded ( true ) ; mBlock = ( RestrictedSwitchPreference ) getPreferenceScreen ( ) . findPreference ( KEY_BLOCK ) ; mBadge = ( RestrictedSwitchPreference ) getPreferenceScreen ( ) . findPreference ( KEY_BADGE ) ; mChannels = ( PreferenceCategory ) findPreference ( KEY_CHANNELS ) ; if ( mPkgInfo != null ) { setupBlock ( ) ; setupBadge ( ) ; // load settings intent ArrayMap < String , AppRow > rows = new ArrayMap < String , AppRow > ( ) ; rows . put ( mAppRow . pkg , mAppRow ) ; collectConfigActivities ( rows ) ; // <SATD_START> TODO: load channels in asynctask? <SATD_END> mChannelGroupList = mBackend . getChannelGroups ( mPkg , mUid ) . getList ( ) ; Collections . sort ( mChannelGroupList , mChannelGroupComparator ) ; if ( mChannelGroupList . isEmpty ( ) ) { Preference empty = new Preference ( getPrefContext ( ) ) ; empty . setTitle ( R . string . no_channels ) ; empty . setEnabled ( false ) ; mChannels . addPreference ( empty ) ; } else { for ( NotificationChannelGroup group : mChannelGroupList ) { PreferenceCategory groupCategory = null ; if ( group . getId ( ) != null && group . getName ( ) != null ) { groupCategory = new PreferenceCategory ( getPrefContext ( ) ) ; groupCategory . setTitle ( group . getName ( ) ) ; groupCategory . setKey ( group . getId ( ) ) ; groupCategory . setOrderingAsAdded ( true ) ; getPreferenceScreen ( ) . addPreference ( groupCategory ) ; } final List < NotificationChannel > channels = group . getChannels ( ) ; Collections . sort ( channels , mChannelComparator ) ; int N = channels . size ( ) ; for ( int i = 0 ; i < N ; i ++ ) { final NotificationChannel channel = channels . get ( i ) ; RestrictedPreference channelPref = new RestrictedPreference ( getPrefContext ( ) ) ; channelPref . setDisabledByAdmin ( mSuspendedAppsAdmin ) ; channelPref . setKey ( channel . getId ( ) ) ; channelPref . setTitle ( channel . getName ( ) ) ; if ( channel . isDeleted ( ) ) { channelPref . setTitle ( getString ( R . string . deleted_channel_name , channel . getName ( ) ) ) ; channelPref . setEnabled ( false ) ; } else { Bundle channelArgs = new Bundle ( ) ; channelArgs . putInt ( AppInfoBase . ARG_PACKAGE_UID , mUid ) ; channelArgs . putBoolean ( AppHeader . EXTRA_HIDE_INFO_BUTTON , true ) ; channelArgs . putString ( AppInfoBase . ARG_PACKAGE_NAME , mPkg ) ; channelArgs . putString ( Settings . EXTRA_CHANNEL_ID , channel . getId ( ) ) ; Intent channelIntent = Utils . onBuildStartFragmentIntent ( getActivity ( ) , ChannelNotificationSettings . class . getName ( ) , channelArgs , null , 0 , null , false ) ; channelPref . setIntent ( channelIntent ) ; } if ( groupCategory != null ) { groupCategory . addPreference ( channelPref ) ; } else { mChannels . addPreference ( channelPref ) ; } } } } updateDependents ( mAppRow . banned ) ; } if ( mDashboardFeatureProvider . isEnabled ( ) ) { final Preference pref = FeatureFactory . getFactory ( activity ) . getApplicationFeatureProvider ( activity ) . newAppHeaderController ( this /* fragment */ , null /* appHeader */ ) . setIcon ( mAppRow . icon ) . setLabel ( mAppRow . label ) . setPackageName ( mAppRow . pkg ) . setUid ( mAppRow . uid ) . setAppNotifPrefIntent ( mAppRow . settingsIntent ) . setButtonActions ( AppHeaderController . ActionType . ACTION_APP_INFO , AppHeaderController . ActionType . ACTION_NOTIF_PREFERENCE ) . done ( getPrefContext ( ) ) ; getPreferenceScreen ( ) . addPreference ( pref ) ; } }","@ Override public void onCreate  ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; if ( mUid < 0 || TextUtils . isEmpty ( mPkg ) || mPkgInfo == null ) { Log . w ( TAG , "" Missing package or uid or packageinfo "" ) ; toastAndFinish ( ) ; return ; } final Activity activity = getActivity ( ) ; mDashboardFeatureProvider = FeatureFactory . getFactory ( activity ) . getDashboardFeatureProvider ( activity ) ; addPreferencesFromResource ( R . xml . app_notification_settings ) ; getPreferenceScreen ( ) . setOrderingAsAdded ( true ) ; mBlock = ( RestrictedSwitchPreference ) getPreferenceScreen ( ) . findPreference ( KEY_BLOCK ) ; mBadge = ( RestrictedSwitchPreference ) getPreferenceScreen ( ) . findPreference ( KEY_BADGE ) ; if ( mPkgInfo != null ) { setupBlock ( ) ; setupBadge ( ) ; // load settings intent ArrayMap < String , AppRow > rows = new ArrayMap < String , AppRow > ( ) ; rows . put ( mAppRow . pkg , mAppRow ) ; collectConfigActivities ( rows ) ; new AsyncTask < Void , Void , Void > ( ) { @ Override protected Void doInBackground ( Void ... unused ) { mChannelGroupList = mBackend . getChannelGroups ( mPkg , mUid ) . getList ( ) ; Collections . sort ( mChannelGroupList , mChannelGroupComparator ) ; return null ; } @ Override protected void onPostExecute ( Void unused ) { populateChannelList ( ) ; } } . execute ( ) ; } if ( mDashboardFeatureProvider . isEnabled ( ) ) { final Preference pref = FeatureFactory . getFactory ( activity ) . getApplicationFeatureProvider ( activity ) . newAppHeaderController ( this /* fragment */ , null /* appHeader */ ) . setIcon ( mAppRow . icon ) . setLabel ( mAppRow . label ) . setPackageName ( mAppRow . pkg ) . setUid ( mAppRow . uid ) . setAppNotifPrefIntent ( mAppRow . settingsIntent ) . setButtonActions ( AppHeaderController . ActionType . ACTION_APP_INFO , AppHeaderController . ActionType . ACTION_NOTIF_PREFERENCE ) . done ( getPrefContext ( ) ) ; getPreferenceScreen ( ) . addPreference ( pref ) ; } }",2017/1/30 14:58,2017/2/8 14:49,1,Interrogative
2695,13,https://www.github.com/aosp-mirror/platform_packages_apps_settings,"launchIntentOrSelectProfile(FragmentActivity, Tile, Intent, int, TopLevelHighlightMixin)",,445,445,445,445,TODO(b/201970810): Add test cases.,https://www.github.com/aosp-mirror/platform_packages_apps_settings/commit/3855d6e58777,https://www.github.com/aosp-mirror/platform_packages_apps_settings/commit/2cb3f925a3cb605e319d7894d9b77c42db4550f1,src/com/android/settings/dashboard/DashboardFeatureProviderImpl.java,"private void launchIntentOrSelectProfile(FragmentActivity activity, Tile tile, Intent intent,
            int sourceMetricCategory, TopLevelHighlightMixin highlightMixin) {
if (!isIntentResolvable(intent)) {
Log.w(TAG, ""Cannot resolve intent, skipping. "" + intent);
return;
}
ProfileSelectDialog.updateUserHandlesIfNeeded(mContext, tile);
mMetricsFeatureProvider.logStartedIntent(intent, sourceMetricCategory);
//TODO(b/201970810): Add test cases.
if (tile.isNewTask(mContext)) {
intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
}
if (tile.userHandle == null || tile.isPrimaryProfileOnly()) {
activity.startActivity(intent);
} else if (tile.userHandle.size() == 1) {
activity.startActivityAsUser(intent, tile.userHandle.get(0));
} else {
final UserHandle userHandle = intent.getParcelableExtra(EXTRA_USER);
if (userHandle != null && tile.userHandle.contains(userHandle)) {
activity.startActivityAsUser(intent, userHandle);
return;
}
final List<UserHandle> resolvableUsers = getResolvableUsers(intent, tile);
if (resolvableUsers.size() == 1) {
activity.startActivityAsUser(intent, resolvableUsers.get(0));
return;
}
ProfileSelectDialog.show(activity.getSupportFragmentManager(), tile,
                    sourceMetricCategory, /* onShowListener= */ highlightMixin,
                    /* onDismissListener= */ highlightMixin,
                    /* onCancelListener= */ highlightMixin);
}
}","private void launchIntentOrSelectProfile(FragmentActivity activity, Tile tile, Intent intent,
            int sourceMetricCategory, TopLevelHighlightMixin highlightMixin) {
if (!isIntentResolvable(intent)) {
Log.w(TAG, ""Cannot resolve intent, skipping. "" + intent);
return;
}
ProfileSelectDialog.updateUserHandlesIfNeeded(mContext, tile);
mMetricsFeatureProvider.logStartedIntent(intent, sourceMetricCategory);
if (tile.userHandle == null || tile.isPrimaryProfileOnly()) {
activity.startActivity(intent);
} else if (tile.userHandle.size() == 1) {
activity.startActivityAsUser(intent, tile.userHandle.get(0));
} else {
final UserHandle userHandle = intent.getParcelableExtra(EXTRA_USER);
if (userHandle != null && tile.userHandle.contains(userHandle)) {
activity.startActivityAsUser(intent, userHandle);
return;
}
final List<UserHandle> resolvableUsers = getResolvableUsers(intent, tile);
if (resolvableUsers.size() == 1) {
activity.startActivityAsUser(intent, resolvableUsers.get(0));
return;
}
ProfileSelectDialog.show(activity.getSupportFragmentManager(), tile,
                    sourceMetricCategory, /* onShowListener= */ highlightMixin,
                    /* onDismissListener= */ highlightMixin,
                    /* onCancelListener= */ highlightMixin);
}
}","private void launchIntentOrSelectProfile  ( FragmentActivity activity , Tile tile , Intent intent , int sourceMetricCategory , TopLevelHighlightMixin highlightMixin ) { if ( ! isIntentResolvable ( intent ) ) { Log . w ( TAG , "" Cannot resolve intent, skipping.  "" + intent ) ; return ; } ProfileSelectDialog . updateUserHandlesIfNeeded ( mContext , tile ) ; mMetricsFeatureProvider . logStartedIntent ( intent , sourceMetricCategory ) ; //<SATD_START> TODO(b/201970810): Add test cases. <SATD_END> if ( tile . isNewTask ( mContext ) ) { intent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ; } if ( tile . userHandle == null || tile . isPrimaryProfileOnly ( ) ) { activity . startActivity ( intent ) ; } else if ( tile . userHandle . size ( ) == 1 ) { activity . startActivityAsUser ( intent , tile . userHandle . get ( 0 ) ) ; } else { final UserHandle userHandle = intent . getParcelableExtra ( EXTRA_USER ) ; if ( userHandle != null && tile . userHandle . contains ( userHandle ) ) { activity . startActivityAsUser ( intent , userHandle ) ; return ; } final List < UserHandle > resolvableUsers = getResolvableUsers ( intent , tile ) ; if ( resolvableUsers . size ( ) == 1 ) { activity . startActivityAsUser ( intent , resolvableUsers . get ( 0 ) ) ; return ; } ProfileSelectDialog . show ( activity . getSupportFragmentManager ( ) , tile , sourceMetricCategory , /* onShowListener= */ highlightMixin , /* onDismissListener= */ highlightMixin , /* onCancelListener= */ highlightMixin ) ; } }","private void launchIntentOrSelectProfile  ( FragmentActivity activity , Tile tile , Intent intent , int sourceMetricCategory , TopLevelHighlightMixin highlightMixin ) { if ( ! isIntentResolvable ( intent ) ) { Log . w ( TAG , "" Cannot resolve intent, skipping.  "" + intent ) ; return ; } ProfileSelectDialog . updateUserHandlesIfNeeded ( mContext , tile ) ; mMetricsFeatureProvider . logStartedIntent ( intent , sourceMetricCategory ) ; if ( tile . userHandle == null || tile . isPrimaryProfileOnly ( ) ) { activity . startActivity ( intent ) ; } else if ( tile . userHandle . size ( ) == 1 ) { activity . startActivityAsUser ( intent , tile . userHandle . get ( 0 ) ) ; } else { final UserHandle userHandle = intent . getParcelableExtra ( EXTRA_USER ) ; if ( userHandle != null && tile . userHandle . contains ( userHandle ) ) { activity . startActivityAsUser ( intent , userHandle ) ; return ; } final List < UserHandle > resolvableUsers = getResolvableUsers ( intent , tile ) ; if ( resolvableUsers . size ( ) == 1 ) { activity . startActivityAsUser ( intent , resolvableUsers . get ( 0 ) ) ; return ; } ProfileSelectDialog . show ( activity . getSupportFragmentManager ( ) , tile , sourceMetricCategory , /* onShowListener= */ highlightMixin , /* onDismissListener= */ highlightMixin , /* onCancelListener= */ highlightMixin ) ; } }",2021-10-04 16:36:19 +0800,2022-02-11 15:34:41 +0800,19,Other
187,591,https://www.github.com/jenkinsci/remoting,"setupLogging(Path, Path)",DESIGN,312,312,312,312,TODO: This message is suspected to break the CI,https://www.github.com/jenkinsci/remoting/commit/76c9b8ccf,https://www.github.com/jenkinsci/remoting/commit/f47c65a22030d14a302d55d926b60f011fb24f06,src/main/java/org/jenkinsci/remoting/engine/WorkDirManager.java,"public void setupLogging(@CheckForNull Path internalDirPath, @CheckForNull Path overrideLogPath) throws IOException {
if (loggingInitialized) {
// Do nothing, in Remoting initialization there may be two calls due to the
// legacy -agentLog behavior implementation.
LOGGER.log(Level.CONFIG, ""Logging system has been already initialized"");
return;
}
final File configFile = getLoggingConfigFile();
if (configFile != null) {
// TODO: There is a risk of second configuration call in the case of java.util.logging.config.file, but it's safe
LOGGER.log(Level.FINE, ""Reading Logging configuration from file: {0}"", configFile);
try(FileInputStream fis =  new FileInputStream(configFile)) {
LogManager.getLogManager().readConfiguration(fis);
}
}
if (overrideLogPath != null) { // Legacy behavior
LOGGER.log(Level.INFO, ""Using {0} as an agent error log destination; output log will not be generated"", overrideLogPath);
System.out.flush(); // Just in case the channel
System.err.flush();
System.setErr(legacyCreateTeeStream(System.err, overrideLogPath));
this.loggingInitialized = true;
} else if (internalDirPath != null) { // New behavior
LOGGER.log(Level.INFO, ""Both error and output logs will be printed to {0}"", internalDirPath);
System.out.flush();
System.err.flush();
// Also redirect JUL to files if custom logging is not specified
final File internalDirFile = internalDirPath.toFile();
createInternalDirIfRequired(internalDirFile, DirType.LOGS_DIR);
final File logsDir = getLocation(DirType.LOGS_DIR);
if (configFile == null) {
final Logger rootLogger = Logger.getLogger("""");
final File julLog = new File(logsDir, ""remoting.log"");
final FileHandler logHandler = new FileHandler(julLog.getAbsolutePath(),
                                         10*1024*1024, 5, false);
logHandler.setFormatter(new SimpleFormatter());
logHandler.setLevel(Level.INFO);
rootLogger.addHandler(logHandler);
}
this.loggingInitialized = true;
} else {
// TODO: This message is suspected to break the CI
// System.err.println(""WARNING: Log location is not specified (neither -workDir nor -agentLog set)"");
}
}","public void setupLogging(@CheckForNull Path internalDirPath, @CheckForNull Path overrideLogPath) throws IOException {
if (loggingInitialized) {
// Do nothing, in Remoting initialization there may be two calls due to the
// legacy -agentLog behavior implementation.
LOGGER.log(Level.CONFIG, ""Logging system has been already initialized"");
return;
}
final File configFile = getLoggingConfigFile();
if (configFile != null) {
// TODO: There is a risk of second configuration call in the case of java.util.logging.config.file, but it's safe
LOGGER.log(Level.FINE, ""Reading Logging configuration from file: {0}"", configFile);
try(FileInputStream fis =  new FileInputStream(configFile)) {
LogManager.getLogManager().readConfiguration(fis);
}
}
if (overrideLogPath != null) { // Legacy behavior
LOGGER.log(Level.INFO, ""Using {0} as an agent error log destination; output log will not be generated"", overrideLogPath);
System.out.flush(); // Just in case the channel
System.err.flush();
System.setErr(legacyCreateTeeStream(System.err, overrideLogPath));
this.loggingInitialized = true;
} else if (internalDirPath != null) { // New behavior
LOGGER.log(Level.INFO, ""Both error and output logs will be printed to {0}"", internalDirPath);
System.out.flush();
System.err.flush();
// Also redirect JUL to files if custom logging is not specified
final File internalDirFile = internalDirPath.toFile();
createInternalDirIfRequired(internalDirFile, DirType.LOGS_DIR);
final File logsDir = getLocation(DirType.LOGS_DIR);
if (configFile == null) {
final Logger rootLogger = Logger.getLogger("""");
final File julLog = new File(logsDir, ""remoting.log"");
final FileHandler logHandler = new FileHandler(julLog.getAbsolutePath(),
                                         10*1024*1024, 5, false);
logHandler.setFormatter(new SimpleFormatter());
logHandler.setLevel(Level.INFO);
rootLogger.addHandler(logHandler);
}
this.loggingInitialized = true;
}
}","public void setupLogging  ( @ CheckForNull Path internalDirPath , @ CheckForNull Path overrideLogPath ) throws IOException { if ( loggingInitialized ) { // Do nothing, in Remoting initialization there may be two calls due to the // legacy -agentLog behavior implementation. LOGGER . log ( Level . CONFIG , "" Logging system has been already initialized "" ) ; return ; } final File configFile = getLoggingConfigFile ( ) ; if ( configFile != null ) { // TODO: There is a risk of second configuration call in the case of java.util.logging.config.file, but it's safe LOGGER . log ( Level . FINE , "" Reading Logging configuration from file: {0} "" , configFile ) ; try ( FileInputStream fis = new FileInputStream ( configFile ) ) { LogManager . getLogManager ( ) . readConfiguration ( fis ) ; } } if ( overrideLogPath != null ) { // Legacy behavior LOGGER . log ( Level . INFO , "" Using {0} as an agent error log destination; output log will not be generated "" , overrideLogPath ) ; System . out . flush ( ) ; // Just in case the channel System . err . flush ( ) ; System . setErr ( legacyCreateTeeStream ( System . err , overrideLogPath ) ) ; this . loggingInitialized = true ; } else if ( internalDirPath != null ) { // New behavior LOGGER . log ( Level . INFO , "" Both error and output logs will be printed to {0} "" , internalDirPath ) ; System . out . flush ( ) ; System . err . flush ( ) ; // Also redirect JUL to files if custom logging is not specified final File internalDirFile = internalDirPath . toFile ( ) ; createInternalDirIfRequired ( internalDirFile , DirType . LOGS_DIR ) ; final File logsDir = getLocation ( DirType . LOGS_DIR ) ; if ( configFile == null ) { final Logger rootLogger = Logger . getLogger ( "" "" ) ; final File julLog = new File ( logsDir , "" remoting.log "" ) ; final FileHandler logHandler = new FileHandler ( julLog . getAbsolutePath ( ) , 10 * 1024 * 1024 , 5 , false ) ; logHandler . setFormatter ( new SimpleFormatter ( ) ) ; logHandler . setLevel ( Level . INFO ) ; rootLogger . addHandler ( logHandler ) ; } this . loggingInitialized = true ; } else { // <SATD_START> TODO: This message is suspected to break the CI <SATD_END> // System.err.println(""WARNING: Log location is not specified (neither -workDir nor -agentLog set)""); } }","public void setupLogging  ( @ CheckForNull Path internalDirPath , @ CheckForNull Path overrideLogPath ) throws IOException { if ( loggingInitialized ) { // Do nothing, in Remoting initialization there may be two calls due to the // legacy -agentLog behavior implementation. LOGGER . log ( Level . CONFIG , "" Logging system has been already initialized "" ) ; return ; } final File configFile = getLoggingConfigFile ( ) ; if ( configFile != null ) { // TODO: There is a risk of second configuration call in the case of java.util.logging.config.file, but it's safe LOGGER . log ( Level . FINE , "" Reading Logging configuration from file: {0} "" , configFile ) ; try ( FileInputStream fis = new FileInputStream ( configFile ) ) { LogManager . getLogManager ( ) . readConfiguration ( fis ) ; } } if ( overrideLogPath != null ) { // Legacy behavior LOGGER . log ( Level . INFO , "" Using {0} as an agent error log destination; output log will not be generated "" , overrideLogPath ) ; System . out . flush ( ) ; // Just in case the channel System . err . flush ( ) ; System . setErr ( legacyCreateTeeStream ( System . err , overrideLogPath ) ) ; this . loggingInitialized = true ; } else if ( internalDirPath != null ) { // New behavior LOGGER . log ( Level . INFO , "" Both error and output logs will be printed to {0} "" , internalDirPath ) ; System . out . flush ( ) ; System . err . flush ( ) ; // Also redirect JUL to files if custom logging is not specified final File internalDirFile = internalDirPath . toFile ( ) ; createInternalDirIfRequired ( internalDirFile , DirType . LOGS_DIR ) ; final File logsDir = getLocation ( DirType . LOGS_DIR ) ; if ( configFile == null ) { final Logger rootLogger = Logger . getLogger ( "" "" ) ; final File julLog = new File ( logsDir , "" remoting.log "" ) ; final FileHandler logHandler = new FileHandler ( julLog . getAbsolutePath ( ) , 10 * 1024 * 1024 , 5 , false ) ; logHandler . setFormatter ( new SimpleFormatter ( ) ) ; logHandler . setLevel ( Level . INFO ) ; rootLogger . addHandler ( logHandler ) ; } this . loggingInitialized = true ; } }",2017-05-07 10:52:14 +0300,2020/10/21 9:02,41,Other
507,26,https://www.github.com/aosp-mirror/platform_packages_apps_email,onAdminEnabled(boolean),,643,643,640,640,TODO: transition to enabled state,https://www.github.com/aosp-mirror/platform_packages_apps_email/commit/3d2b3b3b35,https://www.github.com/aosp-mirror/platform_packages_apps_email/commit/856e09d76ab62272e660fd4a08e25637f17319a0,src/com/android/email/SecurityPolicy.java,"void onAdminEnabled(boolean isEnabled) {
if (isEnabled && !mAdminEnabled) {
// TODO: transition to enabled state
} else if (!isEnabled && mAdminEnabled) {
// transition to disabled state
// Response:  clear *all* security state information from the accounts, forcing
// them back to the initial configurations requiring policy administration
ContentValues cv = new ContentValues();
cv.put(AccountColumns.SECURITY_FLAGS, 0);
cv.putNull(AccountColumns.SECURITY_SYNC_KEY);
mContext.getContentResolver().update(Account.CONTENT_URI, cv, null, null);
updatePolicies(-1);
}
mAdminEnabled = isEnabled;
}","void onAdminEnabled(boolean isEnabled) {
if (!isEnabled) {
// transition to disabled state
// Response:  clear *all* security state information from the accounts, forcing
// them back to the initial configurations requiring policy administration
ContentValues cv = new ContentValues();
cv.put(AccountColumns.SECURITY_FLAGS, 0);
cv.putNull(AccountColumns.SECURITY_SYNC_KEY);
mContext.getContentResolver().update(Account.CONTENT_URI, cv, null, null);
updatePolicies(-1);
}
}","void onAdminEnabled  ( boolean isEnabled ) { if ( isEnabled && ! mAdminEnabled ) { // <SATD_START> TODO: transition to enabled state <SATD_END> } else if ( ! isEnabled && mAdminEnabled ) { // transition to disabled state // Response:  clear *all* security state information from the accounts, forcing // them back to the initial configurations requiring policy administration ContentValues cv = new ContentValues ( ) ; cv . put ( AccountColumns . SECURITY_FLAGS , 0 ) ; cv . putNull ( AccountColumns . SECURITY_SYNC_KEY ) ; mContext . getContentResolver ( ) . update ( Account . CONTENT_URI , cv , null , null ) ; updatePolicies ( - 1 ) ; } mAdminEnabled = isEnabled ; }","void onAdminEnabled  ( boolean isEnabled ) { if ( ! isEnabled ) { // transition to disabled state // Response:  clear *all* security state information from the accounts, forcing // them back to the initial configurations requiring policy administration ContentValues cv = new ContentValues ( ) ; cv . put ( AccountColumns . SECURITY_FLAGS , 0 ) ; cv . putNull ( AccountColumns . SECURITY_SYNC_KEY ) ; mContext . getContentResolver ( ) . update ( Account . CONTENT_URI , cv , null , null ) ; updatePolicies ( - 1 ) ; } }",2010/2/5 11:10,2010/4/6 22:56,1,Other
972,11,https://www.github.com/nodebox/nodebox,paint(PPaintContext),DESIGN,47,47,47,47,TODO: Draw parameter dependencies using implicitColor.,https://www.github.com/nodebox/nodebox/commit/183bea61d,https://www.github.com/nodebox/nodebox/commit/721cfa477edf7694398e65d1543768c47027a9cf,src/java/nodebox/client/ConnectionLayer.java,"@Override
protected void paint(PPaintContext pPaintContext) {
// TODO: Draw parameter dependencies using implicitColor.
super.paint(pPaintContext);
Graphics2D g = pPaintContext.getGraphics();
Node activeNetwork = networkView.getActiveNetwork();
if (activeNetwork == null) return;
for (Connection c : activeNetwork.getConnections()) {
if (selection == c) {
g.setColor(Theme.CONNECTION_ACTION_COLOR);
} else {
g.setColor(Theme.CONNECTION_DEFAULT_COLOR);
}
paintConnection(g, c.getOutputNode(), c.getInput());
}
// Draw temporary connection
if (networkView.isConnecting() && networkView.getConnectionPoint() != null) {
// Set the color to some kind of yellow
g.setColor(Theme.CONNECTION_CONNECTING_COLOR);
Point2D pt = networkView.getConnectionPoint();
ConnectionLayer.paintConnection(g, networkView.getConnectionSource().getNode(), (float) pt.getX(), (float) pt.getY());
}
}","@Override
protected void paint(PPaintContext pPaintContext) {
super.paint(pPaintContext);
Graphics2D g = pPaintContext.getGraphics();
Node activeNetwork = networkView.getActiveNetwork();
if (activeNetwork == null) return;
for (Connection c : activeNetwork.getConnections()) {
if (selection == c) {
g.setColor(Theme.CONNECTION_ACTION_COLOR);
} else {
g.setColor(Theme.CONNECTION_DEFAULT_COLOR);
}
Node outputNode = activeNetwork.getChild(c.getOutputNode());
Node inputNode = activeNetwork.getChild(c.getInputNode());
Port inputPort = inputNode.getInput(c.getInputPort());
paintConnection(g, outputNode, inputNode, inputPort);
}
// Draw temporary connection
if (networkView.isConnecting() && networkView.getConnectionPoint() != null) {
// Set the color to some kind of yellow
g.setColor(Theme.CONNECTION_CONNECTING_COLOR);
Point2D pt = networkView.getConnectionPoint();
ConnectionLayer.paintConnection(g, networkView.getConnectionSource().getNode(), (float) pt.getX(), (float) pt.getY());
}
}","@ Override protected void paint  ( PPaintContext pPaintContext ) { // <SATD_START> TODO: Draw parameter dependencies using implicitColor. <SATD_END> super . paint ( pPaintContext ) ; Graphics2D g = pPaintContext . getGraphics ( ) ; Node activeNetwork = networkView . getActiveNetwork ( ) ; if ( activeNetwork == null ) return ; for ( Connection c : activeNetwork . getConnections ( ) ) { if ( selection == c ) { g . setColor ( Theme . CONNECTION_ACTION_COLOR ) ; } else { g . setColor ( Theme . CONNECTION_DEFAULT_COLOR ) ; } paintConnection ( g , c . getOutputNode ( ) , c . getInput ( ) ) ; } // Draw temporary connection if ( networkView . isConnecting ( ) && networkView . getConnectionPoint ( ) != null ) { // Set the color to some kind of yellow g . setColor ( Theme . CONNECTION_CONNECTING_COLOR ) ; Point2D pt = networkView . getConnectionPoint ( ) ; ConnectionLayer . paintConnection ( g , networkView . getConnectionSource ( ) . getNode ( ) , ( float ) pt . getX ( ) , ( float ) pt . getY ( ) ) ; } }","@ Override protected void paint  ( PPaintContext pPaintContext ) { super . paint ( pPaintContext ) ; Graphics2D g = pPaintContext . getGraphics ( ) ; Node activeNetwork = networkView . getActiveNetwork ( ) ; if ( activeNetwork == null ) return ; for ( Connection c : activeNetwork . getConnections ( ) ) { if ( selection == c ) { g . setColor ( Theme . CONNECTION_ACTION_COLOR ) ; } else { g . setColor ( Theme . CONNECTION_DEFAULT_COLOR ) ; } Node outputNode = activeNetwork . getChild ( c . getOutputNode ( ) ) ; Node inputNode = activeNetwork . getChild ( c . getInputNode ( ) ) ; Port inputPort = inputNode . getInput ( c . getInputPort ( ) ) ; paintConnection ( g , outputNode , inputNode , inputPort ) ; } // Draw temporary connection if ( networkView . isConnecting ( ) && networkView . getConnectionPoint ( ) != null ) { // Set the color to some kind of yellow g . setColor ( Theme . CONNECTION_CONNECTING_COLOR ) ; Point2D pt = networkView . getConnectionPoint ( ) ; ConnectionLayer . paintConnection ( g , networkView . getConnectionSource ( ) . getNode ( ) , ( float ) pt . getX ( ) , ( float ) pt . getY ( ) ) ; } }",2009-05-20 10:13:07 +0000,2012-05-08 10:37:40 +0200,17,Other
1397,15,https://www.github.com/aosp-mirror/platform_packages_apps_contacts,"setValues(DataKind, ValuesDelta, EntityDelta, boolean, ViewIdGenerator)",DESIGN,129,129,129,129,TODO: Change to android.R.attr.spinnerTextStyle when available,https://www.github.com/aosp-mirror/platform_packages_apps_contacts/commit/91d8e892d5,https://www.github.com/aosp-mirror/platform_packages_apps_contacts/commit/c69a9ccb6c6440127f75b51aca123afa6946474a,src/com/android/contacts/editor/EventFieldEditorView.java,"@Override
public void setValues(DataKind kind, ValuesDelta entry, EntityDelta state, boolean readOnly,
            ViewIdGenerator vig) {
if (kind.fieldList.size() != 1) throw new IllegalStateException(""kind must have 1 field"");
super.setValues(kind, entry, state, readOnly, vig);
if (mDateView == null) {
// TODO: Change to android.R.attr.spinnerTextStyle when available
// mDateView = new Button(getContext(), null, android.R.attr.editTextStyle);
mDateView = new Button(getContext());
// TODO: Remove hard-coded padding and gravity when android.R.attr.spinnerTextStyle
// becomes available
mDateView.setPadding(18, mDateView.getPaddingTop(),
                    mDateView.getPaddingRight(), mDateView.getPaddingBottom());
mDateView.setGravity(Gravity.LEFT | Gravity.CENTER_VERTICAL);
mDateView.setLayoutParams(new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT,
                    LayoutParams.WRAP_CONTENT));
mDateView.setEnabled(isEnabled() && !readOnly);
mDateView.setOnClickListener(new OnClickListener() {
                @Override
public void onClick(View v) {
showDialog(R.id.dialog_event_date_picker);
}
            });
addView(mDateView);
}
rebuildDateView();
}","@Override
public void setValues(DataKind kind, ValuesDelta entry, EntityDelta state, boolean readOnly,
            ViewIdGenerator vig) {
if (kind.fieldList.size() != 1) throw new IllegalStateException(""kind must have 1 field"");
super.setValues(kind, entry, state, readOnly, vig);
if (mDateView == null) {
mDateView = new Button(getContext(), null, android.R.attr.spinnerStyle);
mDateView.setLayoutParams(new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT,
                    LayoutParams.WRAP_CONTENT));
mDateView.setEnabled(isEnabled() && !readOnly);
mDateView.setOnClickListener(new OnClickListener() {
                @Override
public void onClick(View v) {
showDialog(R.id.dialog_event_date_picker);
}
            });
addView(mDateView);
}
rebuildDateView();
}","@ Override public void setValues  ( DataKind kind , ValuesDelta entry , EntityDelta state , boolean readOnly , ViewIdGenerator vig ) { if ( kind . fieldList . size ( ) != 1 ) throw new IllegalStateException ( "" kind must have 1 field "" ) ; super . setValues ( kind , entry , state , readOnly , vig ) ; if ( mDateView == null ) { // <SATD_START> TODO: Change to android.R.attr.spinnerTextStyle when available <SATD_END> // mDateView = new Button(getContext(), null, android.R.attr.editTextStyle); mDateView = new Button ( getContext ( ) ) ; // TODO: Remove hard-coded padding and gravity when android.R.attr.spinnerTextStyle // becomes available mDateView . setPadding ( 18 , mDateView . getPaddingTop ( ) , mDateView . getPaddingRight ( ) , mDateView . getPaddingBottom ( ) ) ; mDateView . setGravity ( Gravity . LEFT | Gravity . CENTER_VERTICAL ) ; mDateView . setLayoutParams ( new LinearLayout . LayoutParams ( LayoutParams . MATCH_PARENT , LayoutParams . WRAP_CONTENT ) ) ; mDateView . setEnabled ( isEnabled ( ) && ! readOnly ) ; mDateView . setOnClickListener ( new OnClickListener ( ) { @ Override public void onClick ( View v ) { showDialog ( R . id . dialog_event_date_picker ) ; } } ) ; addView ( mDateView ) ; } rebuildDateView ( ) ; }","@ Override public void setValues  ( DataKind kind , ValuesDelta entry , EntityDelta state , boolean readOnly , ViewIdGenerator vig ) { if ( kind . fieldList . size ( ) != 1 ) throw new IllegalStateException ( "" kind must have 1 field "" ) ; super . setValues ( kind , entry , state , readOnly , vig ) ; if ( mDateView == null ) { mDateView = new Button ( getContext ( ) , null , android . R . attr . spinnerStyle ) ; mDateView . setLayoutParams ( new LinearLayout . LayoutParams ( LayoutParams . MATCH_PARENT , LayoutParams . WRAP_CONTENT ) ) ; mDateView . setEnabled ( isEnabled ( ) && ! readOnly ) ; mDateView . setOnClickListener ( new OnClickListener ( ) { @ Override public void onClick ( View v ) { showDialog ( R . id . dialog_event_date_picker ) ; } } ) ; addView ( mDateView ) ; } rebuildDateView ( ) ; }",2010/12/8 9:59,2011/1/24 11:39,5,Other
518,76,https://www.github.com/ushahidi/ushahidi_android,onCreate(Bundle),DESIGN,262,262,262,262,TODO look into how to use xml R.string for that,https://www.github.com/ushahidi/ushahidi_android/commit/66a475def,https://www.github.com/ushahidi/ushahidi_android/commit/5ca317bef568a53cc7f013a27336849e58a0036c,src/org/addhen/ushahidi/AddIncident.java,"private void initComponents(){
btnPicture = (Button) findViewById(R.id.btnPicture);
btnAddCategory = (Button) findViewById(R.id.add_category);
incidentTitle = (EditText) findViewById(R.id.incident_title);
incidentLocation = (EditText) findViewById(R.id.incident_location);
incidentDesc = (EditText) findViewById(R.id.incident_desc);
btnSend = (Button) findViewById(R.id.incident_add_btn);
btnCancel = (Button) findViewById(R.id.incident_add_cancel);
incidentDate = (TextView) findViewById(R.id.lbl_date);
pickDate = (Button) findViewById(R.id.pick_date);
pickTime = (Button) findViewById(R.id.pick_time);
addLocation = (Button) findViewById(R.id.location);
//open location map window
addLocation.setOnClickListener( new View.OnClickListener(){
			public void onClick( View v ) {
Intent intent = new Intent( AddIncident.this,LocationMap.class);
startActivityForResult(intent,VIEW_MAP);
setResult( RESULT_OK, intent );
}
		});
btnSend.setOnClickListener(new View.OnClickListener() {
			public void onClick(View v){
//Dipo Fix
error = false;
if( TextUtils.isEmpty(incidentTitle.getText())) {
//TODO look into how to use xml R.string for that
errorMessage =""* Enter a title for the incident.\n"";
error = true;
}
if( TextUtils.isEmpty(incidentDesc.getText())) {
//TODO look into how to use xml R.string for that
errorMessage += ""* Enter a description for the incident.\n"";
error = true;
}
if( TextUtils.isEmpty(incidentLocation.getText())) {
//TODO look into how to use xml R.string for that
errorMessage += ""* Enter a location for the incident.\n"";
error = true;
}
//Dipo Fix
if(vectorCategories.size() == 0) {
//TODO look into how to use xml R.string for that
errorMessage += ""* Select at least one category.\n"";
error = true;
}
if( !error ) {
if( Util.isConnected(AddIncident.this) ){
if( !postToOnline() ) {
mHandler.post(mSentIncidentFail);
}else {
mHandler.post(mSentIncidentSuccess);
clearFields();
//after a successful upload, delete the file
File f = new File(UshahidiService.savePath + UshahidiService.fileName);
if(f.exists()){
f.delete();
}
}
}else {
final Thread tr = new Thread() {
						@Override
public void run() {
try {
mHandler.post(mSentIncidentOffline);
} finally {
}
}
					};
tr.start();
}
}else{
final Toast t = Toast.makeText(AddIncident.this,
							""Error!\n\n""+ errorMessage,
							Toast.LENGTH_LONG);
t.show();
errorMessage = """";
}
}
			});
btnPicture.setOnClickListener(new View.OnClickListener() {
			public void onClick(View v) {
showDialog(DIALOG_CHOOSE_IMAGE_METHOD);
}
		});
btnCancel.setOnClickListener( new View.OnClickListener() {
			public void onClick(View v) {
clearFields();
Intent intent = new Intent( AddIncident.this,Ushahidi.class);
startActivityForResult( intent, GOTOHOME );
setResult(RESULT_OK);
finish();
}
		});
btnAddCategory.setOnClickListener(new View.OnClickListener() {
			public void onClick(View v) {
showDialog(DIALOG_MULTIPLE_CATEGORY);
counter++;
}
		});
pickDate.setOnClickListener(new View.OnClickListener() {

            public void onClick(View v) {
showDialog(DATE_DIALOG_ID);
}
        });
pickTime.setOnClickListener(new View.OnClickListener() {

            public void onClick(View v) {
showDialog(TIME_DIALOG_ID);
}
        });
final Calendar c = Calendar.getInstance();
mYear = c.get(Calendar.YEAR);
mMonth = c.get(Calendar.MONTH);
mDay = c.get(Calendar.DAY_OF_MONTH);
mHour = c.get(Calendar.HOUR_OF_DAY);
mMinute = c.get(Calendar.MINUTE);
c.get(Calendar.AM_PM);
updateDisplay();
}","private void initComponents(){
btnPicture = (Button) findViewById(R.id.btnPicture);
btnAddCategory = (Button) findViewById(R.id.add_category);
incidentTitle = (EditText) findViewById(R.id.incident_title);
incidentTitle.setOnFocusChangeListener(new View.OnFocusChangeListener() {

			@Override
public void onFocusChange(View v, boolean hasFocus) {
if(TextUtils.isEmpty(incidentTitle.getText())) {
incidentTitle.setError(getString(R.string.empty_report_title));
}
}
			
		});
incidentLocation = (EditText) findViewById(R.id.incident_location);
incidentLocation.setOnFocusChangeListener( new View.OnFocusChangeListener() {

			@Override
public void onFocusChange(View v, boolean hasFocus) {
if( TextUtils.isEmpty(incidentLocation.getText())) {
incidentLocation.setError(getString(R.string.empty_report_location));
}
}
		});
incidentDesc = (EditText) findViewById(R.id.incident_desc);
incidentDesc.setOnFocusChangeListener(new View.OnFocusChangeListener() {

			@Override
public void onFocusChange(View v, boolean hasFocus) {
if(TextUtils.isEmpty(incidentDesc.getText())) {
incidentDesc.setError(getString(R.string.empty_report_description));
}
}
			
		});
btnSend = (Button) findViewById(R.id.incident_add_btn);
btnCancel = (Button) findViewById(R.id.incident_add_cancel);
incidentDate = (TextView) findViewById(R.id.lbl_date);
pickDate = (Button) findViewById(R.id.pick_date);
pickTime = (Button) findViewById(R.id.pick_time);
addLocation = (Button) findViewById(R.id.location);
//open location map window
addLocation.setOnClickListener( new View.OnClickListener(){
			public void onClick( View v ) {
Intent intent = new Intent( AddIncident.this,LocationMap.class);
startActivityForResult(intent,VIEW_MAP);
setResult( RESULT_OK, intent );
}
		});
btnSend.setOnClickListener(new View.OnClickListener() {
			public void onClick(View v){
//Dipo Fix
error = false;
if( TextUtils.isEmpty(incidentTitle.getText())) {
errorMessage =getString(R.string.empty_report_title);
error = true;
}
if( TextUtils.isEmpty(incidentDesc.getText())) {
errorMessage += getString(R.string.empty_report_description);
error = true;
}
if( TextUtils.isEmpty(incidentLocation.getText())) {
errorMessage += getString(R.string.empty_report_location);
error = true;
}
//Dipo Fix
if(vectorCategories.size() == 0) {
errorMessage += getString(R.string.empty_report_categories);
error = true;
}
if( !error ) {
if( Util.isConnected(AddIncident.this) ){
if( !postToOnline() ) {
mHandler.post(mSentIncidentFail);
}else {
mHandler.post(mSentIncidentSuccess);
clearFields();
//after a successful upload, delete the file
File f = new File(UshahidiService.savePath + UshahidiService.fileName);
if(f.exists()){
f.delete();
}
}
}else {
final Thread tr = new Thread() {
						@Override
public void run() {
try {
mHandler.post(mSentIncidentOffline);
} finally {
}
}
					};
tr.start();
}
}else{
final Toast t = Toast.makeText(AddIncident.this,
							""Error!\n\n""+ errorMessage,
							Toast.LENGTH_LONG);
t.show();
errorMessage = """";
}
}
			});
btnPicture.setOnClickListener(new View.OnClickListener() {
			public void onClick(View v) {
showDialog(DIALOG_CHOOSE_IMAGE_METHOD);
}
		});
btnCancel.setOnClickListener( new View.OnClickListener() {
			public void onClick(View v) {
clearFields();
Intent intent = new Intent( AddIncident.this,Ushahidi.class);
startActivityForResult( intent, GOTOHOME );
setResult(RESULT_OK);
finish();
}
		});
btnAddCategory.setOnClickListener(new View.OnClickListener() {
			public void onClick(View v) {
showDialog(DIALOG_MULTIPLE_CATEGORY);
counter++;
}
		});
pickDate.setOnClickListener(new View.OnClickListener() {

            public void onClick(View v) {
showDialog(DATE_DIALOG_ID);
}
        });
pickTime.setOnClickListener(new View.OnClickListener() {

            public void onClick(View v) {
showDialog(TIME_DIALOG_ID);
}
        });
final Calendar c = Calendar.getInstance();
mYear = c.get(Calendar.YEAR);
mMonth = c.get(Calendar.MONTH);
mDay = c.get(Calendar.DAY_OF_MONTH);
mHour = c.get(Calendar.HOUR_OF_DAY);
mMinute = c.get(Calendar.MINUTE);
c.get(Calendar.AM_PM);
updateDisplay();
}","private void initComponents  ( ) { btnPicture = ( Button ) findViewById ( R . id . btnPicture ) ; btnAddCategory = ( Button ) findViewById ( R . id . add_category ) ; incidentTitle = ( EditText ) findViewById ( R . id . incident_title ) ; incidentLocation = ( EditText ) findViewById ( R . id . incident_location ) ; incidentDesc = ( EditText ) findViewById ( R . id . incident_desc ) ; btnSend = ( Button ) findViewById ( R . id . incident_add_btn ) ; btnCancel = ( Button ) findViewById ( R . id . incident_add_cancel ) ; incidentDate = ( TextView ) findViewById ( R . id . lbl_date ) ; pickDate = ( Button ) findViewById ( R . id . pick_date ) ; pickTime = ( Button ) findViewById ( R . id . pick_time ) ; addLocation = ( Button ) findViewById ( R . id . location ) ; //open location map window addLocation . setOnClickListener ( new View . OnClickListener ( ) { public void onClick ( View v ) { Intent intent = new Intent ( AddIncident . this , LocationMap . class ) ; startActivityForResult ( intent , VIEW_MAP ) ; setResult ( RESULT_OK , intent ) ; } } ) ; btnSend . setOnClickListener ( new View . OnClickListener ( ) { public void onClick ( View v ) { //Dipo Fix error = false ; if ( TextUtils . isEmpty ( incidentTitle . getText ( ) ) ) { //<SATD_START> TODO look into how to use xml R.string for that <SATD_END> errorMessage = "" * Enter a title for the incident. \n "" ; error = true ; } if ( TextUtils . isEmpty ( incidentDesc . getText ( ) ) ) { //<SATD_START> TODO look into how to use xml R.string for that <SATD_END> errorMessage += "" * Enter a description for the incident. \n "" ; error = true ; } if ( TextUtils . isEmpty ( incidentLocation . getText ( ) ) ) { //<SATD_START> TODO look into how to use xml R.string for that <SATD_END> errorMessage += "" * Enter a location for the incident. \n "" ; error = true ; } //Dipo Fix if ( vectorCategories . size ( ) == 0 ) { //<SATD_START> TODO look into how to use xml R.string for that <SATD_END> errorMessage += "" * Select at least one category. \n "" ; error = true ; } if ( ! error ) { if ( Util . isConnected ( AddIncident . this ) ) { if ( ! postToOnline ( ) ) { mHandler . post ( mSentIncidentFail ) ; } else { mHandler . post ( mSentIncidentSuccess ) ; clearFields ( ) ; //after a successful upload, delete the file File f = new File ( UshahidiService . savePath + UshahidiService . fileName ) ; if ( f . exists ( ) ) { f . delete ( ) ; } } } else { final Thread tr = new Thread ( ) { @ Override public void run ( ) { try { mHandler . post ( mSentIncidentOffline ) ; } finally { } } } ; tr . start ( ) ; } } else { final Toast t = Toast . makeText ( AddIncident . this , "" Error! \n \n "" + errorMessage , Toast . LENGTH_LONG ) ; t . show ( ) ; errorMessage = "" "" ; } } } ) ; btnPicture . setOnClickListener ( new View . OnClickListener ( ) { public void onClick ( View v ) { showDialog ( DIALOG_CHOOSE_IMAGE_METHOD ) ; } } ) ; btnCancel . setOnClickListener ( new View . OnClickListener ( ) { public void onClick ( View v ) { clearFields ( ) ; Intent intent = new Intent ( AddIncident . this , Ushahidi . class ) ; startActivityForResult ( intent , GOTOHOME ) ; setResult ( RESULT_OK ) ; finish ( ) ; } } ) ; btnAddCategory . setOnClickListener ( new View . OnClickListener ( ) { public void onClick ( View v ) { showDialog ( DIALOG_MULTIPLE_CATEGORY ) ; counter ++ ; } } ) ; pickDate . setOnClickListener ( new View . OnClickListener ( ) { public void onClick ( View v ) { showDialog ( DATE_DIALOG_ID ) ; } } ) ; pickTime . setOnClickListener ( new View . OnClickListener ( ) { public void onClick ( View v ) { showDialog ( TIME_DIALOG_ID ) ; } } ) ; final Calendar c = Calendar . getInstance ( ) ; mYear = c . get ( Calendar . YEAR ) ; mMonth = c . get ( Calendar . MONTH ) ; mDay = c . get ( Calendar . DAY_OF_MONTH ) ; mHour = c . get ( Calendar . HOUR_OF_DAY ) ; mMinute = c . get ( Calendar . MINUTE ) ; c . get ( Calendar . AM_PM ) ; updateDisplay ( ) ; }","private void initComponents  ( ) { btnPicture = ( Button ) findViewById ( R . id . btnPicture ) ; btnAddCategory = ( Button ) findViewById ( R . id . add_category ) ; incidentTitle = ( EditText ) findViewById ( R . id . incident_title ) ; incidentTitle . setOnFocusChangeListener ( new View . OnFocusChangeListener ( ) { @ Override public void onFocusChange ( View v , boolean hasFocus ) { if ( TextUtils . isEmpty ( incidentTitle . getText ( ) ) ) { incidentTitle . setError ( getString ( R . string . empty_report_title ) ) ; } } } ) ; incidentLocation = ( EditText ) findViewById ( R . id . incident_location ) ; incidentLocation . setOnFocusChangeListener ( new View . OnFocusChangeListener ( ) { @ Override public void onFocusChange ( View v , boolean hasFocus ) { if ( TextUtils . isEmpty ( incidentLocation . getText ( ) ) ) { incidentLocation . setError ( getString ( R . string . empty_report_location ) ) ; } } } ) ; incidentDesc = ( EditText ) findViewById ( R . id . incident_desc ) ; incidentDesc . setOnFocusChangeListener ( new View . OnFocusChangeListener ( ) { @ Override public void onFocusChange ( View v , boolean hasFocus ) { if ( TextUtils . isEmpty ( incidentDesc . getText ( ) ) ) { incidentDesc . setError ( getString ( R . string . empty_report_description ) ) ; } } } ) ; btnSend = ( Button ) findViewById ( R . id . incident_add_btn ) ; btnCancel = ( Button ) findViewById ( R . id . incident_add_cancel ) ; incidentDate = ( TextView ) findViewById ( R . id . lbl_date ) ; pickDate = ( Button ) findViewById ( R . id . pick_date ) ; pickTime = ( Button ) findViewById ( R . id . pick_time ) ; addLocation = ( Button ) findViewById ( R . id . location ) ; //open location map window addLocation . setOnClickListener ( new View . OnClickListener ( ) { public void onClick ( View v ) { Intent intent = new Intent ( AddIncident . this , LocationMap . class ) ; startActivityForResult ( intent , VIEW_MAP ) ; setResult ( RESULT_OK , intent ) ; } } ) ; btnSend . setOnClickListener ( new View . OnClickListener ( ) { public void onClick ( View v ) { //Dipo Fix error = false ; if ( TextUtils . isEmpty ( incidentTitle . getText ( ) ) ) { errorMessage = getString ( R . string . empty_report_title ) ; error = true ; } if ( TextUtils . isEmpty ( incidentDesc . getText ( ) ) ) { errorMessage += getString ( R . string . empty_report_description ) ; error = true ; } if ( TextUtils . isEmpty ( incidentLocation . getText ( ) ) ) { errorMessage += getString ( R . string . empty_report_location ) ; error = true ; } //Dipo Fix if ( vectorCategories . size ( ) == 0 ) { errorMessage += getString ( R . string . empty_report_categories ) ; error = true ; } if ( ! error ) { if ( Util . isConnected ( AddIncident . this ) ) { if ( ! postToOnline ( ) ) { mHandler . post ( mSentIncidentFail ) ; } else { mHandler . post ( mSentIncidentSuccess ) ; clearFields ( ) ; //after a successful upload, delete the file File f = new File ( UshahidiService . savePath + UshahidiService . fileName ) ; if ( f . exists ( ) ) { f . delete ( ) ; } } } else { final Thread tr = new Thread ( ) { @ Override public void run ( ) { try { mHandler . post ( mSentIncidentOffline ) ; } finally { } } } ; tr . start ( ) ; } } else { final Toast t = Toast . makeText ( AddIncident . this , "" Error! \n \n "" + errorMessage , Toast . LENGTH_LONG ) ; t . show ( ) ; errorMessage = "" "" ; } } } ) ; btnPicture . setOnClickListener ( new View . OnClickListener ( ) { public void onClick ( View v ) { showDialog ( DIALOG_CHOOSE_IMAGE_METHOD ) ; } } ) ; btnCancel . setOnClickListener ( new View . OnClickListener ( ) { public void onClick ( View v ) { clearFields ( ) ; Intent intent = new Intent ( AddIncident . this , Ushahidi . class ) ; startActivityForResult ( intent , GOTOHOME ) ; setResult ( RESULT_OK ) ; finish ( ) ; } } ) ; btnAddCategory . setOnClickListener ( new View . OnClickListener ( ) { public void onClick ( View v ) { showDialog ( DIALOG_MULTIPLE_CATEGORY ) ; counter ++ ; } } ) ; pickDate . setOnClickListener ( new View . OnClickListener ( ) { public void onClick ( View v ) { showDialog ( DATE_DIALOG_ID ) ; } } ) ; pickTime . setOnClickListener ( new View . OnClickListener ( ) { public void onClick ( View v ) { showDialog ( TIME_DIALOG_ID ) ; } } ) ; final Calendar c = Calendar . getInstance ( ) ; mYear = c . get ( Calendar . YEAR ) ; mMonth = c . get ( Calendar . MONTH ) ; mDay = c . get ( Calendar . DAY_OF_MONTH ) ; mHour = c . get ( Calendar . HOUR_OF_DAY ) ; mMinute = c . get ( Calendar . MINUTE ) ; c . get ( Calendar . AM_PM ) ; updateDisplay ( ) ; }",2009-06-01 19:12:05 +0000,2010-04-11 12:09:06 +0000,1,Other
2783,739,https://www.github.com/sloeber/arduino-eclipse-plugin,restoreAllSelections(),,435,435,435,435,TODO add the options here,https://www.github.com/sloeber/arduino-eclipse-plugin/commit/f78f18e83,https://www.github.com/sloeber/arduino-eclipse-plugin/commit/d660675fa5883ac8516f0252cb7716882f86f047,it.baeyens.arduino.core/src/it/baeyens/arduino/ui/ArduinoSelectionPage.java,"private void restoreAllSelections() {
String boardFile = ArduinoInstancePreferences.getLastUsedBoardsFile();
String boardName = ArduinoInstancePreferences.getLastUsedArduinoBoardName();
String uploadPort = ArduinoInstancePreferences.getLastUsedUploadPort();
String uploadProtocol = ArduinoInstancePreferences.getLastUsedUploadProgrammer();
if ("""".equals(uploadProtocol))
uploadProtocol=""wiring"";
// TODO add the options here
if (page != null) {
ICConfigurationDescription confdesc = getResDesc().getConfiguration();
boardFile = Common.getBuildEnvironmentVariable(confdesc, ArduinoConst.ENV_KEY_JANTJE_BOARDS_FILE, boardFile);
boardName = Common.getBuildEnvironmentVariable(confdesc, ArduinoConst.ENV_KEY_JANTJE_BOARD_NAME, boardName);
uploadPort = Common.getBuildEnvironmentVariable(confdesc, ArduinoConst.ENV_KEY_JANTJE_COM_PORT, uploadPort);
uploadProtocol = Common.getBuildEnvironmentVariable(confdesc, ArduinoConst.ENV_KEY_JANTJE_COM_PROG, uploadProtocol);
}
mControlBoardsTxtFile.setText(boardFile);
// if no boards file is selected select the first
if (mControlBoardsTxtFile.getText().isEmpty()) {
mControlBoardsTxtFile.setText(mControlBoardsTxtFile.getItem(0));
}
int selectedBoardFile = mControlBoardsTxtFile.getSelectionIndex();
mcontrolBoardName.setItems(boardsFiles[selectedBoardFile].GetArduinoBoards());
mcontrolBoardName.setText(boardName);
BoardModifyListener.handleEvent(null);
controlUploadPort.setText(uploadPort);
controlUploadProtocol.setText(uploadProtocol);
if (page != null) {
for (int curCombo = 0; curCombo < boardOptionCombos[selectedBoardFile].length; curCombo++) {
String optionName = (String) boardOptionCombos[selectedBoardFile][curCombo].mCombo.getData(""Menu"");
String optionValue = Common.getBuildEnvironmentVariable(getResDesc().getConfiguration(), ArduinoConst.ENV_KEY_JANTJE_START
+ optionName, """", true);
boardOptionCombos[selectedBoardFile][curCombo].mCombo.setText(optionValue);
}
}
}","private void restoreAllSelections() {
String boardFile = ArduinoInstancePreferences.getLastUsedBoardsFile();
String boardName = ArduinoInstancePreferences.getLastUsedArduinoBoardName();
String uploadPort = ArduinoInstancePreferences.getLastUsedUploadPort();
String uploadProtocol = ArduinoInstancePreferences.getLastUsedUploadProgrammer();
if (page != null) {
ICConfigurationDescription confdesc = getResDesc().getConfiguration();
boardFile = Common.getBuildEnvironmentVariable(confdesc, ArduinoConst.ENV_KEY_JANTJE_BOARDS_FILE, boardFile);
boardName = Common.getBuildEnvironmentVariable(confdesc, ArduinoConst.ENV_KEY_JANTJE_BOARD_NAME, boardName);
uploadPort = Common.getBuildEnvironmentVariable(confdesc, ArduinoConst.ENV_KEY_JANTJE_COM_PORT, uploadPort);
uploadProtocol = Common.getBuildEnvironmentVariable(confdesc, ArduinoConst.ENV_KEY_JANTJE_COM_PROG, uploadProtocol);
}
mControlBoardsTxtFile.setText(boardFile);
// if no boards file is selected select the first
if (mControlBoardsTxtFile.getText().isEmpty()) {
mControlBoardsTxtFile.setText(mControlBoardsTxtFile.getItem(0));
}
int selectedBoardFile = mControlBoardsTxtFile.getSelectionIndex();
mcontrolBoardName.setItems(boardsFiles[selectedBoardFile].GetArduinoBoards());
mcontrolBoardName.setText(boardName);
BoardModifyListener.handleEvent(null);
controlUploadPort.setText(uploadPort);
controlUploadProtocol.setText(uploadProtocol);
if (page != null) {
for (int curCombo = 0; curCombo < boardOptionCombos[selectedBoardFile].length; curCombo++) {
String optionName = (String) boardOptionCombos[selectedBoardFile][curCombo].mCombo.getData(""Menu"");
String optionValue = Common.getBuildEnvironmentVariable(getResDesc().getConfiguration(), ArduinoConst.ENV_KEY_JANTJE_START
+ optionName, """", true);
boardOptionCombos[selectedBoardFile][curCombo].mCombo.setText(optionValue);
}
}
}","private void restoreAllSelections  ( ) { String boardFile = ArduinoInstancePreferences . getLastUsedBoardsFile ( ) ; String boardName = ArduinoInstancePreferences . getLastUsedArduinoBoardName ( ) ; String uploadPort = ArduinoInstancePreferences . getLastUsedUploadPort ( ) ; String uploadProtocol = ArduinoInstancePreferences . getLastUsedUploadProgrammer ( ) ; if ( "" "" . equals ( uploadProtocol ) ) uploadProtocol = "" wiring "" ; // <SATD_START> TODO add the options here <SATD_END> if ( page != null ) { ICConfigurationDescription confdesc = getResDesc ( ) . getConfiguration ( ) ; boardFile = Common . getBuildEnvironmentVariable ( confdesc , ArduinoConst . ENV_KEY_JANTJE_BOARDS_FILE , boardFile ) ; boardName = Common . getBuildEnvironmentVariable ( confdesc , ArduinoConst . ENV_KEY_JANTJE_BOARD_NAME , boardName ) ; uploadPort = Common . getBuildEnvironmentVariable ( confdesc , ArduinoConst . ENV_KEY_JANTJE_COM_PORT , uploadPort ) ; uploadProtocol = Common . getBuildEnvironmentVariable ( confdesc , ArduinoConst . ENV_KEY_JANTJE_COM_PROG , uploadProtocol ) ; } mControlBoardsTxtFile . setText ( boardFile ) ; // if no boards file is selected select the first if ( mControlBoardsTxtFile . getText ( ) . isEmpty ( ) ) { mControlBoardsTxtFile . setText ( mControlBoardsTxtFile . getItem ( 0 ) ) ; } int selectedBoardFile = mControlBoardsTxtFile . getSelectionIndex ( ) ; mcontrolBoardName . setItems ( boardsFiles [ selectedBoardFile ] . GetArduinoBoards ( ) ) ; mcontrolBoardName . setText ( boardName ) ; BoardModifyListener . handleEvent ( null ) ; controlUploadPort . setText ( uploadPort ) ; controlUploadProtocol . setText ( uploadProtocol ) ; if ( page != null ) { for ( int curCombo = 0 ; curCombo < boardOptionCombos [ selectedBoardFile ] . length ; curCombo ++ ) { String optionName = ( String ) boardOptionCombos [ selectedBoardFile ] [ curCombo ] . mCombo . getData ( "" Menu "" ) ; String optionValue = Common . getBuildEnvironmentVariable ( getResDesc ( ) . getConfiguration ( ) , ArduinoConst . ENV_KEY_JANTJE_START + optionName , "" "" , true ) ; boardOptionCombos [ selectedBoardFile ] [ curCombo ] . mCombo . setText ( optionValue ) ; } } }","private void restoreAllSelections  ( ) { String boardFile = ArduinoInstancePreferences . getLastUsedBoardsFile ( ) ; String boardName = ArduinoInstancePreferences . getLastUsedArduinoBoardName ( ) ; String uploadPort = ArduinoInstancePreferences . getLastUsedUploadPort ( ) ; String uploadProtocol = ArduinoInstancePreferences . getLastUsedUploadProgrammer ( ) ; if ( page != null ) { ICConfigurationDescription confdesc = getResDesc ( ) . getConfiguration ( ) ; boardFile = Common . getBuildEnvironmentVariable ( confdesc , ArduinoConst . ENV_KEY_JANTJE_BOARDS_FILE , boardFile ) ; boardName = Common . getBuildEnvironmentVariable ( confdesc , ArduinoConst . ENV_KEY_JANTJE_BOARD_NAME , boardName ) ; uploadPort = Common . getBuildEnvironmentVariable ( confdesc , ArduinoConst . ENV_KEY_JANTJE_COM_PORT , uploadPort ) ; uploadProtocol = Common . getBuildEnvironmentVariable ( confdesc , ArduinoConst . ENV_KEY_JANTJE_COM_PROG , uploadProtocol ) ; } mControlBoardsTxtFile . setText ( boardFile ) ; // if no boards file is selected select the first if ( mControlBoardsTxtFile . getText ( ) . isEmpty ( ) ) { mControlBoardsTxtFile . setText ( mControlBoardsTxtFile . getItem ( 0 ) ) ; } int selectedBoardFile = mControlBoardsTxtFile . getSelectionIndex ( ) ; mcontrolBoardName . setItems ( boardsFiles [ selectedBoardFile ] . GetArduinoBoards ( ) ) ; mcontrolBoardName . setText ( boardName ) ; BoardModifyListener . handleEvent ( null ) ; controlUploadPort . setText ( uploadPort ) ; controlUploadProtocol . setText ( uploadProtocol ) ; if ( page != null ) { for ( int curCombo = 0 ; curCombo < boardOptionCombos [ selectedBoardFile ] . length ; curCombo ++ ) { String optionName = ( String ) boardOptionCombos [ selectedBoardFile ] [ curCombo ] . mCombo . getData ( "" Menu "" ) ; String optionValue = Common . getBuildEnvironmentVariable ( getResDesc ( ) . getConfiguration ( ) , ArduinoConst . ENV_KEY_JANTJE_START + optionName , "" "" , true ) ; boardOptionCombos [ selectedBoardFile ] [ curCombo ] . mCombo . setText ( optionValue ) ; } } }",2013-09-16 00:25:12 +0200,2014-08-12 21:04:16 +0200,1,Other
159,181,https://www.github.com/jenkinsci/git-plugin,retrieveRevision_customRef(),NOT_DESIGN,486,486,486,486,TODO unignore once JENKINS-48385,https://www.github.com/jenkinsci/git-plugin/commit/5cfdeaa87,https://www.github.com/jenkinsci/git-plugin/commit/2eee3e5afa0b759f124da6439bd4652bfd3399af,src/test/java/jenkins/plugins/git/AbstractGitSCMSourceTest.java,"@Issue(""JENKINS-48061"")
@Test
@Ignore(""Cannot fix until JENKINS-48385 merged"") // TODO unignore once JENKINS-48385
public void retrieveRevision_customRef() throws Exception {
sampleRepo.init();
sampleRepo.write(""file"", ""v1"");
sampleRepo.git(""commit"", ""--all"", ""--message=v1"");
sampleRepo.git(""tag"", ""v1"");
String v1 = sampleRepo.head();
sampleRepo.write(""file"", ""v2"");
sampleRepo.git(""commit"", ""--all"", ""--message=v2""); // master
sampleRepo.git(""checkout"", ""-b"", ""dev"");
sampleRepo.write(""file"", ""v3"");
sampleRepo.git(""commit"", ""--all"", ""--message=v3""); // dev
String v3 = sampleRepo.head();
sampleRepo.git(""update-ref"", ""refs/custom/foo"", v3); // now this is an advertised ref so cannot be GC'd
sampleRepo.git(""reset"", ""--hard"", ""HEAD^""); // dev
sampleRepo.write(""file"", ""v4"");
sampleRepo.git(""commit"", ""--all"", ""--message=v4""); // dev
// SCM.checkout does not permit a null build argument, unfortunately.
Run<?,?> run = r.buildAndAssertSuccess(r.createFreeStyleProject());
GitSCMSource source = new GitSCMSource(sampleRepo.toString());
source.setTraits(Arrays.asList(new BranchDiscoveryTrait(), new TagDiscoveryTrait()));
StreamTaskListener listener = StreamTaskListener.fromStderr();
// Test retrieval of non head revision:
assertEquals(""v3"", fileAt(v3, run, source, listener));
}","@Issue(""JENKINS-48061"")
@Test
public void retrieveRevision_customRef() throws Exception {
sampleRepo.init();
sampleRepo.write(""file"", ""v1"");
sampleRepo.git(""commit"", ""--all"", ""--message=v1"");
sampleRepo.git(""tag"", ""v1"");
String v1 = sampleRepo.head();
sampleRepo.write(""file"", ""v2"");
sampleRepo.git(""commit"", ""--all"", ""--message=v2""); // master
sampleRepo.git(""checkout"", ""-b"", ""dev"");
sampleRepo.write(""file"", ""v3"");
sampleRepo.git(""commit"", ""--all"", ""--message=v3""); // dev
String v3 = sampleRepo.head();
sampleRepo.git(""update-ref"", ""refs/custom/foo"", v3); // now this is an advertised ref so cannot be GC'd
sampleRepo.git(""reset"", ""--hard"", ""HEAD^""); // dev
sampleRepo.write(""file"", ""v4"");
sampleRepo.git(""commit"", ""--all"", ""--message=v4""); // dev
// SCM.checkout does not permit a null build argument, unfortunately.
Run<?,?> run = r.buildAndAssertSuccess(r.createFreeStyleProject());
GitSCMSource source = new GitSCMSource(sampleRepo.toString());
source.setTraits(Arrays.asList(new BranchDiscoveryTrait(), new TagDiscoveryTrait()));
StreamTaskListener listener = StreamTaskListener.fromStderr();
// Test retrieval of non head revision:
assertEquals(""v3"", fileAt(v3, run, source, listener));
}","@ Issue ( "" JENKINS-48061 "" ) @ Test @ Ignore ( "" Cannot fix until JENKINS-48385 merged "" ) // <SATD_START> TODO unignore once JENKINS-48385 <SATD_END> public void retrieveRevision_customRef  ( ) throws Exception  { sampleRepo . init ( ) ; sampleRepo . write ( "" file "" , "" v1 "" ) ; sampleRepo . git ( "" commit "" , "" --all "" , "" --message=v1 "" ) ; sampleRepo . git ( "" tag "" , "" v1 "" ) ; String v1 = sampleRepo . head ( ) ; sampleRepo . write ( "" file "" , "" v2 "" ) ; sampleRepo . git ( "" commit "" , "" --all "" , "" --message=v2 "" ) ; // master sampleRepo . git ( "" checkout "" , "" -b "" , "" dev "" ) ; sampleRepo . write ( "" file "" , "" v3 "" ) ; sampleRepo . git ( "" commit "" , "" --all "" , "" --message=v3 "" ) ; // dev String v3 = sampleRepo . head ( ) ; sampleRepo . git ( "" update-ref "" , "" refs/custom/foo "" , v3 ) ; // now this is an advertised ref so cannot be GC'd sampleRepo . git ( "" reset "" , "" --hard "" , "" HEAD^ "" ) ; // dev sampleRepo . write ( "" file "" , "" v4 "" ) ; sampleRepo . git ( "" commit "" , "" --all "" , "" --message=v4 "" ) ; // dev // SCM.checkout does not permit a null build argument, unfortunately. Run < ? , ? > run = r . buildAndAssertSuccess ( r . createFreeStyleProject ( ) ) ; GitSCMSource source = new GitSCMSource ( sampleRepo . toString ( ) ) ; source . setTraits ( Arrays . asList ( new BranchDiscoveryTrait ( ) , new TagDiscoveryTrait ( ) ) ) ; StreamTaskListener listener = StreamTaskListener . fromStderr ( ) ; // Test retrieval of non head revision: assertEquals ( "" v3 "" , fileAt ( v3 , run , source , listener ) ) ; }","@ Issue ( "" JENKINS-48061 "" ) @ Test public void retrieveRevision_customRef  ( ) throws Exception  { sampleRepo . init ( ) ; sampleRepo . write ( "" file "" , "" v1 "" ) ; sampleRepo . git ( "" commit "" , "" --all "" , "" --message=v1 "" ) ; sampleRepo . git ( "" tag "" , "" v1 "" ) ; String v1 = sampleRepo . head ( ) ; sampleRepo . write ( "" file "" , "" v2 "" ) ; sampleRepo . git ( "" commit "" , "" --all "" , "" --message=v2 "" ) ; // master sampleRepo . git ( "" checkout "" , "" -b "" , "" dev "" ) ; sampleRepo . write ( "" file "" , "" v3 "" ) ; sampleRepo . git ( "" commit "" , "" --all "" , "" --message=v3 "" ) ; // dev String v3 = sampleRepo . head ( ) ; sampleRepo . git ( "" update-ref "" , "" refs/custom/foo "" , v3 ) ; // now this is an advertised ref so cannot be GC'd sampleRepo . git ( "" reset "" , "" --hard "" , "" HEAD^ "" ) ; // dev sampleRepo . write ( "" file "" , "" v4 "" ) ; sampleRepo . git ( "" commit "" , "" --all "" , "" --message=v4 "" ) ; // dev // SCM.checkout does not permit a null build argument, unfortunately. Run < ? , ? > run = r . buildAndAssertSuccess ( r . createFreeStyleProject ( ) ) ; GitSCMSource source = new GitSCMSource ( sampleRepo . toString ( ) ) ; source . setTraits ( Arrays . asList ( new BranchDiscoveryTrait ( ) , new TagDiscoveryTrait ( ) ) ) ; StreamTaskListener listener = StreamTaskListener . fromStderr ( ) ; // Test retrieval of non head revision: assertEquals ( "" v3 "" , fileAt ( v3 , run , source , listener ) ) ; }",2017-12-06 10:22:03 +0000,2018-03-15 17:14:27 +0100,2,Other
356,375,https://www.github.com/spring-projects/spring-hadoop,testServiceInterfaces(),DESIGN,112,112,112,112,TODO: if we didn't get a good port - skip test for now,https://www.github.com/spring-projects/spring-hadoop/commit/bd00c8c26,https://www.github.com/spring-projects/spring-hadoop/commit/66344ddabd6707ddbc19aa7a833c5085d0dfadaa,spring-yarn/spring-yarn-integration/src/test/java/org/springframework/yarn/integration/ip/mind/MindIntegrationRawTests.java,"@Test
public void testServiceInterfaces() throws Exception {
log.info(""randomTestPort="" + randomTestPort);
assertNotNull(mindAppmasterService);
assertNotNull(mindAppmasterServiceClient);
assumeTrue(mindAppmasterService.getPort() > 0); //TODO: if we didn't get a good port - skip test for now
assertThat(mindAppmasterService.getPort(), greaterThan(0));
SimpleTestRequest request = new SimpleTestRequest();
BaseResponseObject response = mindAppmasterServiceClient.doMindRequest(request);
assertNotNull(response);
}","@Test
public void testServiceInterfaces() throws Exception {
log.info(""randomTestPort="" + randomTestPort);
waitPort();
assertNotNull(mindAppmasterService);
assertNotNull(mindAppmasterServiceClient);
assertThat(mindAppmasterService.getPort(), greaterThan(0));
SimpleTestRequest request = new SimpleTestRequest();
BaseResponseObject response = mindAppmasterServiceClient.doMindRequest(request);
assertNotNull(response);
}","@ Test public void testServiceInterfaces  ( ) throws Exception  { log . info ( "" randomTestPort= "" + randomTestPort ) ; assertNotNull ( mindAppmasterService ) ; assertNotNull ( mindAppmasterServiceClient ) ; assumeTrue ( mindAppmasterService . getPort ( ) > 0 ) ; //<SATD_START> TODO: if we didn't get a good port - skip test for now <SATD_END> assertThat ( mindAppmasterService . getPort ( ) , greaterThan ( 0 ) ) ; SimpleTestRequest request = new SimpleTestRequest ( ) ; BaseResponseObject response = mindAppmasterServiceClient . doMindRequest ( request ) ; assertNotNull ( response ) ; }","@ Test public void testServiceInterfaces  ( ) throws Exception  { log . info ( "" randomTestPort= "" + randomTestPort ) ; waitPort ( ) ; assertNotNull ( mindAppmasterService ) ; assertNotNull ( mindAppmasterServiceClient ) ; assertThat ( mindAppmasterService . getPort ( ) , greaterThan ( 0 ) ) ; SimpleTestRequest request = new SimpleTestRequest ( ) ; BaseResponseObject response = mindAppmasterServiceClient . doMindRequest ( request ) ; assertNotNull ( response ) ; }",2013/6/18 10:57,2014-07-16 08:24:44 +0100,11,Exclamatory
1463,685,https://www.github.com/usc-isi-i2/web-karma,"generateJson(String, PrintWriter, VWorkspace)",,108,108,108,108,TODO Send Error update,https://www.github.com/usc-isi-i2/web-karma/commit/a059025927,https://www.github.com/usc-isi-i2/web-karma/commit/d042e517a4014062a4c8b90cca13614ae1072540,karma-commands/commands-update-jdbc/src/main/java/edu/isi/karma/controller/update/DatabaseTablesListUpdate.java,"@Override
public void generateJson(String prefix, PrintWriter pw,
			VWorkspace vWorkspace) {
ArrayList<String> listOfTables = null;
try {
AbstractJDBCUtil dbUtil = JDBCUtilFactory.getInstance(dbType);
listOfTables = dbUtil.getListOfTables(dbType, hostname, portnumber,
					username, password, dBorSIDName);
if (listOfTables == null) {
// TODO Send special update
return;
}
// Save the database connection preferences
JSONObject prefObject = new JSONObject();
prefObject.put(JsonKeys.dbType.name(), dbType.name());
prefObject.put(JsonKeys.hostname.name(), hostname);
prefObject.put(JsonKeys.portnumber.name(), portnumber);
prefObject.put(JsonKeys.username.name(), username);
prefObject.put(JsonKeys.dBorSIDName.name(), dBorSIDName);
vWorkspace.getWorkspace().getCommandPreferences().setCommandPreferences(
					""ImportDatabaseTableCommand""+""Preferences"", prefObject);
JSONStringer jsonStr = new JSONStringer();
JSONWriter writer = jsonStr.object().key(JsonKeys.commandId.name())
.value(commandId).key(GenericJsonKeys.updateType.name())
.value(""GetDatabaseTableList"");
JSONArray dataRows = new JSONArray();
dataRows.put(listOfTables);
writer.key(JsonKeys.TableList.name()).value(dataRows);
writer.endObject();
pw.print(jsonStr.toString());
} catch (SQLException e) {
// TODO Send error update
e.printStackTrace();
String message = e.getMessage().replaceAll(""\n"", """")
.replaceAll(""\"""", ""\\\"""");
ErrorUpdate er = new ErrorUpdate(message);
er.generateJson(prefix, pw, vWorkspace);
} catch (ClassNotFoundException e) {
// TODO Send error update
e.printStackTrace();
} catch (JSONException e) {
// TODO Send Error update
e.printStackTrace();
}
}","@Override
public void generateJson(String prefix, PrintWriter pw,
			VWorkspace vWorkspace) {
ArrayList<String> listOfTables = null;
try {
AbstractJDBCUtil dbUtil = JDBCUtilFactory.getInstance(dbType);
listOfTables = dbUtil.getListOfTables(dbType, hostname, portnumber,
					username, password, dBorSIDName);
if (listOfTables == null) {
// TODO Send special update
return;
}
// Save the database connection preferences
JSONObject prefObject = new JSONObject();
prefObject.put(JsonKeys.dbType.name(), dbType.name());
prefObject.put(JsonKeys.hostname.name(), hostname);
prefObject.put(JsonKeys.portnumber.name(), portnumber);
prefObject.put(JsonKeys.username.name(), username);
prefObject.put(JsonKeys.dBorSIDName.name(), dBorSIDName);
vWorkspace.getWorkspace().getCommandPreferences().setCommandPreferences(
					""ImportDatabaseTableCommand""+""Preferences"", prefObject);
JSONStringer jsonStr = new JSONStringer();
JSONWriter writer = jsonStr.object().key(JsonKeys.commandId.name())
.value(commandId).key(GenericJsonKeys.updateType.name())
.value(""GetDatabaseTableList"");
JSONArray dataRows = new JSONArray();
dataRows.put(listOfTables);
writer.key(JsonKeys.TableList.name()).value(dataRows);
writer.endObject();
pw.print(jsonStr.toString());
} catch (SQLException e) {
e.printStackTrace();
String message = e.getMessage().replaceAll(""\n"", """")
.replaceAll(""\"""", ""\\\"""");
ErrorUpdate er = new ErrorUpdate(message);
er.generateJson(prefix, pw, vWorkspace);
} catch (ClassNotFoundException e) {
e.printStackTrace();
ErrorUpdate er = new ErrorUpdate(""The driver for "" + dbType + "" was not found. Please add the driver to the path and try again"");
er.generateJson(prefix, pw, vWorkspace);
} catch (JSONException e) {
String message = e.getMessage().replaceAll(""\n"", """")
.replaceAll(""\"""", ""\\\"""");
ErrorUpdate er = new ErrorUpdate(message);
er.generateJson(prefix, pw, vWorkspace);
e.printStackTrace();
}
}","@ Override public void generateJson  ( String prefix , PrintWriter pw , VWorkspace vWorkspace ) { ArrayList < String > listOfTables = null ; try { AbstractJDBCUtil dbUtil = JDBCUtilFactory . getInstance ( dbType ) ; listOfTables = dbUtil . getListOfTables ( dbType , hostname , portnumber , username , password , dBorSIDName ) ; if ( listOfTables == null ) { // TODO Send special update return ; } // Save the database connection preferences JSONObject prefObject = new JSONObject ( ) ; prefObject . put ( JsonKeys . dbType . name ( ) , dbType . name ( ) ) ; prefObject . put ( JsonKeys . hostname . name ( ) , hostname ) ; prefObject . put ( JsonKeys . portnumber . name ( ) , portnumber ) ; prefObject . put ( JsonKeys . username . name ( ) , username ) ; prefObject . put ( JsonKeys . dBorSIDName . name ( ) , dBorSIDName ) ; vWorkspace . getWorkspace ( ) . getCommandPreferences ( ) . setCommandPreferences ( "" ImportDatabaseTableCommand "" + "" Preferences "" , prefObject ) ; JSONStringer jsonStr = new JSONStringer ( ) ; JSONWriter writer = jsonStr . object ( ) . key ( JsonKeys . commandId . name ( ) ) . value ( commandId ) . key ( GenericJsonKeys . updateType . name ( ) ) . value ( "" GetDatabaseTableList "" ) ; JSONArray dataRows = new JSONArray ( ) ; dataRows . put ( listOfTables ) ; writer . key ( JsonKeys . TableList . name ( ) ) . value ( dataRows ) ; writer . endObject ( ) ; pw . print ( jsonStr . toString ( ) ) ; } catch ( SQLException e ) { // TODO Send error update e . printStackTrace ( ) ; String message = e . getMessage ( ) . replaceAll ( "" \n "" , "" "" ) . replaceAll ( "" \"" "" , "" \\ \"" "" ) ; ErrorUpdate er = new ErrorUpdate ( message ) ; er . generateJson ( prefix , pw , vWorkspace ) ; } catch ( ClassNotFoundException e ) { // TODO Send error update e . printStackTrace ( ) ; } catch ( JSONException e ) { // <SATD_START> TODO Send Error update <SATD_END> e . printStackTrace ( ) ; } }","@ Override public void generateJson  ( String prefix , PrintWriter pw , VWorkspace vWorkspace ) { ArrayList < String > listOfTables = null ; try { AbstractJDBCUtil dbUtil = JDBCUtilFactory . getInstance ( dbType ) ; listOfTables = dbUtil . getListOfTables ( dbType , hostname , portnumber , username , password , dBorSIDName ) ; if ( listOfTables == null ) { // TODO Send special update return ; } // Save the database connection preferences JSONObject prefObject = new JSONObject ( ) ; prefObject . put ( JsonKeys . dbType . name ( ) , dbType . name ( ) ) ; prefObject . put ( JsonKeys . hostname . name ( ) , hostname ) ; prefObject . put ( JsonKeys . portnumber . name ( ) , portnumber ) ; prefObject . put ( JsonKeys . username . name ( ) , username ) ; prefObject . put ( JsonKeys . dBorSIDName . name ( ) , dBorSIDName ) ; vWorkspace . getWorkspace ( ) . getCommandPreferences ( ) . setCommandPreferences ( "" ImportDatabaseTableCommand "" + "" Preferences "" , prefObject ) ; JSONStringer jsonStr = new JSONStringer ( ) ; JSONWriter writer = jsonStr . object ( ) . key ( JsonKeys . commandId . name ( ) ) . value ( commandId ) . key ( GenericJsonKeys . updateType . name ( ) ) . value ( "" GetDatabaseTableList "" ) ; JSONArray dataRows = new JSONArray ( ) ; dataRows . put ( listOfTables ) ; writer . key ( JsonKeys . TableList . name ( ) ) . value ( dataRows ) ; writer . endObject ( ) ; pw . print ( jsonStr . toString ( ) ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; String message = e . getMessage ( ) . replaceAll ( "" \n "" , "" "" ) . replaceAll ( "" \"" "" , "" \\ \"" "" ) ; ErrorUpdate er = new ErrorUpdate ( message ) ; er . generateJson ( prefix , pw , vWorkspace ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; ErrorUpdate er = new ErrorUpdate ( "" The driver for  "" + dbType + ""  was not found. Please add the driver to the path and try again "" ) ; er . generateJson ( prefix , pw , vWorkspace ) ; } catch ( JSONException e ) { String message = e . getMessage ( ) . replaceAll ( "" \n "" , "" "" ) . replaceAll ( "" \"" "" , "" \\ \"" "" ) ; ErrorUpdate er = new ErrorUpdate ( message ) ; er . generateJson ( prefix , pw , vWorkspace ) ; e . printStackTrace ( ) ; } }",2011/10/5 18:26,2014/6/3 10:53,2,Other
2554,322,https://www.github.com/rstudio/rstudio,onWorkbenchReady(),,1381,1381,1381,1381,"TODO: Sending private key passphrase, potentially over unencrypted HTTP",https://www.github.com/rstudio/rstudio/commit/b07331aa280,https://www.github.com/rstudio/rstudio/commit/daa4d874aefd32013ed6d4529bccd15a023fe4f5,src/gwt/src/org/rstudio/studio/client/server/remote/RemoteServer.java,"@Override
public void askpassCompleted(String value,
                                ServerRequestCallback<Void> requestCallback)
{
// TODO: Sending private key passphrase, potentially over unencrypted HTTP
JSONArray params = new JSONArray();
params.set(0, value == null ? JSONNull.getInstance()
: new JSONString(value));
sendRequest(RPC_SCOPE, ASKPASS_COMPLETED, params, requestCallback);
}","@Override
public void askpassCompleted(String value,
                                ServerRequestCallback<Void> requestCallback)
{
JSONArray params = new JSONArray();
params.set(0, value == null ? JSONNull.getInstance()
: new JSONString(value));
sendRequest(RPC_SCOPE, ASKPASS_COMPLETED, params, true, requestCallback);
}","@ Override public void askpassCompleted  ( String value , ServerRequestCallback < Void > requestCallback ) { // <SATD_START> TODO: Sending private key passphrase, potentially over unencrypted HTTP <SATD_END> JSONArray params = new JSONArray ( ) ; params . set ( 0 , value == null ? JSONNull . getInstance ( ) : new JSONString ( value ) ) ; sendRequest ( RPC_SCOPE , ASKPASS_COMPLETED , params , requestCallback ) ; }","@ Override public void askpassCompleted  ( String value , ServerRequestCallback < Void > requestCallback ) { JSONArray params = new JSONArray ( ) ; params . set ( 0 , value == null ? JSONNull . getInstance ( ) : new JSONString ( value ) ) ; sendRequest ( RPC_SCOPE , ASKPASS_COMPLETED , params , true , requestCallback ) ; }",2011/9/12 14:41,2011/10/11 0:55,40,Other
2974,13,https://www.github.com/aosp-mirror/platform_packages_apps_settings,dispatchSetNewPasswordIntent(),,114,114,114,114,"TODO: handle the case with multiple biometrics, perhaps take an arg for biometric type?",https://www.github.com/aosp-mirror/platform_packages_apps_settings/commit/81dc0295d7e2,https://www.github.com/aosp-mirror/platform_packages_apps_settings/commit/87bb772e161d22671119845cc21d5d354155d059,src/com/android/settings/password/SetNewPasswordController.java,"public void dispatchSetNewPasswordIntent() {
final Bundle extras;
// TODO: handle the case with multiple biometrics, perhaps take an arg for biometric type?
if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_FACE)
&& mFaceManager != null
&& mFaceManager.isHardwareDetected()
&& !mFaceManager.hasEnrolledTemplates(mTargetUserId)
&& !isFaceDisabledByAdmin()) {
extras = getFaceChooseLockExtras();
} else if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_FINGERPRINT)
&& mFingerprintManager != null
&& mFingerprintManager.isHardwareDetected()
&& !mFingerprintManager.hasEnrolledFingerprints(mTargetUserId)
&& !isFingerprintDisabledByAdmin()) {
extras = getFingerprintChooseLockExtras();
} else {
extras = new Bundle();
}
// No matter we show fingerprint options or not, we should tell the next activity which
// user is setting new password.
extras.putInt(Intent.EXTRA_USER_ID, mTargetUserId);
mUi.launchChooseLock(extras);
}","public void dispatchSetNewPasswordIntent() {
final Bundle extras;
final boolean hasFeatureFingerprint = mPackageManager
.hasSystemFeature(PackageManager.FEATURE_FINGERPRINT);
final boolean hasFeatureFace = mPackageManager
.hasSystemFeature(PackageManager.FEATURE_FACE);
final boolean shouldShowFingerprintEnroll = mFingerprintManager != null
&& mFingerprintManager.isHardwareDetected()
&& !mFingerprintManager.hasEnrolledFingerprints(mTargetUserId)
&& !isFingerprintDisabledByAdmin();
final boolean shouldShowFaceEnroll = mFaceManager != null
&& mFaceManager.isHardwareDetected()
&& !mFaceManager.hasEnrolledTemplates(mTargetUserId)
&& !isFaceDisabledByAdmin();
if (hasFeatureFace && shouldShowFaceEnroll
&& hasFeatureFingerprint && shouldShowFingerprintEnroll) {
extras = getBiometricChooseLockExtras();
} else if (hasFeatureFace && shouldShowFaceEnroll) {
extras = getFaceChooseLockExtras();
} else if (hasFeatureFingerprint && shouldShowFingerprintEnroll) {
extras = getFingerprintChooseLockExtras();
} else {
extras = new Bundle();
}
// No matter we show fingerprint options or not, we should tell the next activity which
// user is setting new password.
extras.putInt(Intent.EXTRA_USER_ID, mTargetUserId);
mUi.launchChooseLock(extras);
}","public void dispatchSetNewPasswordIntent  ( ) { final Bundle extras ; // <SATD_START> TODO: handle the case with multiple biometrics, perhaps take an arg for biometric type? <SATD_END> if ( mPackageManager . hasSystemFeature ( PackageManager . FEATURE_FACE ) && mFaceManager != null && mFaceManager . isHardwareDetected ( ) && ! mFaceManager . hasEnrolledTemplates ( mTargetUserId ) && ! isFaceDisabledByAdmin ( ) ) { extras = getFaceChooseLockExtras ( ) ; } else if ( mPackageManager . hasSystemFeature ( PackageManager . FEATURE_FINGERPRINT ) && mFingerprintManager != null && mFingerprintManager . isHardwareDetected ( ) && ! mFingerprintManager . hasEnrolledFingerprints ( mTargetUserId ) && ! isFingerprintDisabledByAdmin ( ) ) { extras = getFingerprintChooseLockExtras ( ) ; } else { extras = new Bundle ( ) ; } // No matter we show fingerprint options or not, we should tell the next activity which // user is setting new password. extras . putInt ( Intent . EXTRA_USER_ID , mTargetUserId ) ; mUi . launchChooseLock ( extras ) ; }","public void dispatchSetNewPasswordIntent  ( ) { final Bundle extras ; final boolean hasFeatureFingerprint = mPackageManager . hasSystemFeature ( PackageManager . FEATURE_FINGERPRINT ) ; final boolean hasFeatureFace = mPackageManager . hasSystemFeature ( PackageManager . FEATURE_FACE ) ; final boolean shouldShowFingerprintEnroll = mFingerprintManager != null && mFingerprintManager . isHardwareDetected ( ) && ! mFingerprintManager . hasEnrolledFingerprints ( mTargetUserId ) && ! isFingerprintDisabledByAdmin ( ) ; final boolean shouldShowFaceEnroll = mFaceManager != null && mFaceManager . isHardwareDetected ( ) && ! mFaceManager . hasEnrolledTemplates ( mTargetUserId ) && ! isFaceDisabledByAdmin ( ) ; if ( hasFeatureFace && shouldShowFaceEnroll && hasFeatureFingerprint && shouldShowFingerprintEnroll ) { extras = getBiometricChooseLockExtras ( ) ; } else if ( hasFeatureFace && shouldShowFaceEnroll ) { extras = getFaceChooseLockExtras ( ) ; } else if ( hasFeatureFingerprint && shouldShowFingerprintEnroll ) { extras = getFingerprintChooseLockExtras ( ) ; } else { extras = new Bundle ( ) ; } // No matter we show fingerprint options or not, we should tell the next activity which // user is setting new password. extras . putInt ( Intent . EXTRA_USER_ID , mTargetUserId ) ; mUi . launchChooseLock ( extras ) ; }",2018/6/29 18:19,2020/9/16 23:30,135,Exclamatory
3336,695,https://www.github.com/demoiselle/framework,loadConfiguration(),,150,150,150,150,TODO Logar como warning.,https://www.github.com/demoiselle/framework/commit/62d7edd70,https://www.github.com/demoiselle/framework/commit/86fe2d78dcfc3f296e1c91beb7daf8861f67aa14,impl/core/src/main/java/br/gov/frameworkdemoiselle/internal/implementation/ConfigurationLoader.java,"private void loadConfiguration() {
org.apache.commons.configuration.Configuration config = createConfiguration();
if (config instanceof FileConfiguration) {
((FileConfiguration) config).setURL(Reflections.getResourceAsURL(this.resource));
try {
((FileConfiguration) config).load();
} catch (org.apache.commons.configuration.ConfigurationException cause) {
// TODO Logar como warning.
config = null;
}
}
this.configuration = config;
}","private void loadConfiguration() {
org.apache.commons.configuration.Configuration config = createConfiguration();
if (config instanceof FileConfiguration) {
((FileConfiguration) config).setURL(Reflections.getResourceAsURL(this.resource));
try {
((FileConfiguration) config).load();
} catch (org.apache.commons.configuration.ConfigurationException cause) {
getLogger().warn(getBundle().getString(""file-not-found"", this.resource));
config = null;
}
}
this.configuration = config;
}",private void loadConfiguration  ( ) { org . apache . commons . configuration . Configuration config = createConfiguration ( ) ; if ( config instanceof FileConfiguration ) { ( ( FileConfiguration ) config ) . setURL ( Reflections . getResourceAsURL ( this . resource ) ) ; try { ( ( FileConfiguration ) config ) . load ( ) ; } catch ( org . apache . commons . configuration . ConfigurationException cause ) { // <SATD_START> TODO Logar como warning. <SATD_END> config = null ; } } this . configuration = config ; },"private void loadConfiguration  ( ) { org . apache . commons . configuration . Configuration config = createConfiguration ( ) ; if ( config instanceof FileConfiguration ) { ( ( FileConfiguration ) config ) . setURL ( Reflections . getResourceAsURL ( this . resource ) ) ; try { ( ( FileConfiguration ) config ) . load ( ) ; } catch ( org . apache . commons . configuration . ConfigurationException cause ) { getLogger ( ) . warn ( getBundle ( ) . getString ( "" file-not-found "" , this . resource ) ) ; config = null ; } } this . configuration = config ; }",2013/4/4 15:39,2013/4/5 16:36,1,Other
